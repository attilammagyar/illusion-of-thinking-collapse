# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=11, i=6
# valid_prefix_length=287, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 11 disks. The user wants the complete list of moves without any truncation. Hmm, I remember that the Tower of Hanoi solution follows a recursive pattern. For n disks, the minimum number of moves is 2^n - 1. So for 11 disks, that's 2047 moves. That's a lot, but the user insists on the full list.

First, I need to recall the recursive algorithm. The standard approach is: to move n disks from peg A to peg C, you first move n-1 disks from A to B, using C as the auxiliary. Then move the nth disk from A to C, and finally move the n-1 disks from B to C, using A as the auxiliary. This pattern repeats recursively.

But generating all 2047 moves manually isn't feasible. Wait, maybe there's a pattern or iterative method that can be used to generate the sequence. From the search results, the formula S = 2^N - 1 is mentioned, which aligns with the recursive approach. Also, the example given for 3 disks shows a specific sequence. Let me check the example again.

In the example for 3 disks, the moves are:
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2

This follows the recursive steps. For 3 disks, the first step is moving the top two disks from peg 0 to peg 1, then moving disk 3 to peg 2, then moving the two disks from peg 1 to peg 2. Each of those steps involves the same recursive method.

So for 11 disks, the same logic applies, but the depth is much higher. Each move of a larger disk requires moving all smaller disks out of the way. The challenge is to generate each move step by step without missing any.

But how to translate this into a list of moves programmatically? The iterative approach might be better here. Alternatively, using the binary representation method where each move corresponds to a bit in the binary count up to 2^n -1. For each step, the disk to move is determined by the number of times the step number is divisible by 2. The direction of the move depends on whether the number of disks is even or odd.

Wait, the search result [5] mentions an algorithm for odd and even numbers of disks. For an odd number of disks, the first move is to the right, and for even, to the left. Since 11 is odd, the initial move of disk 1 would be to peg 2. Then, alternating moves following the rules.

But I need to ensure that each move is valid. The iterative algorithm might be the way to go. Let me outline the steps:

1. For each move from 1 to 2047:
   a. Determine which disk to move by finding the number of trailing zeros in the binary representation of the move number. The disk is (number of trailing zeros + 1).
   b. Determine the direction to move the disk. For odd disks, the direction alternates between right and left, starting with right. For even disks, it's the opposite.

But with 11 disks, which is odd, the direction for disk 1 would be right (peg 0 to peg 2), then next move for disk 1 would be left (peg 2 to peg 1), and so on, alternating each time.

However, implementing this requires tracking the current peg of each disk. Alternatively, using the recursive approach to generate the sequence.

But since the user wants the complete list, and given the token limits, generating all 2047 moves here might not be feasible. However, the user insists, so I must proceed.

Alternatively, perhaps there's a pattern in the moves that can be represented in a loop. For example, the moves for disk 1 alternate between pegs every move. Disk 2 moves every other move, disk 3 every four moves, etc. Each disk's movement follows a pattern based on powers of 2.

But how to translate this into the actual peg movements. Let's think:

- The smallest disk (1) moves every 2^0 = 1 step.
- Disk 2 moves every 2^1 = 2 steps.
- Disk 3 every 4 steps, and so on.

The direction for each disk depends on its order. For an odd number of disks, the first disk moves in a cycle: 0 -> 2 -> 1 -> 0 -> 2 -> 1, etc. Each subsequent disk's direction is determined by the parity of the number of disks above it. Wait, maybe that's complicating it.

Alternatively, the standard solution for Tower of Hanoi can be generated using the following iterative approach:

While there are moves left:
1. Make the legal move between pegs A and B (in either direction).
2. Make the legal move between pegs A and C (in either direction).
3. Make the legal move between pegs B and C (in either direction).
Repeat until all disks are on peg C.

But this might not be the most efficient way. Alternatively, the iterative algorithm that determines each move based on the binary representation.

Another approach is to note that each move corresponds to a specific disk and direction. For each move number m (from 1 to 2^11 -1), the disk to move is the number of trailing zeros in m's binary representation plus 1. The direction is determined by whether the disk number is even or odd. For odd-numbered disks, the direction is right (if total disks is odd), and left for even-numbered disks.

Wait, let's clarify. For an odd number of total disks (11), the smallest disk (1) moves in a cycle: 0 -> 2 -> 1 -> 0 -> 2 -> 1, etc. Each subsequent disk moves in the opposite direction. For example, disk 1 moves right, then left, etc. Disk 2 would move to the next available peg in the opposite direction of disk 1's last move.

But this is getting a bit tangled. Let's refer back to the search results. Search result [5] mentions an algorithm for odd and even disks. For an odd number of disks, the first move is to the left, but wait, the example given in [5] for odd algorithm starts with moving disk 1 to the left. Wait, but in the user's example, the initial move for 3 disks was 1,0,2 (to the right). Hmm, maybe there's a discrepancy here.

Wait, the user's example for 3 disks starts with moving disk 1 from peg 0 to peg 2. So that's a move to the right. But according to [5], for an odd number of disks, the first move is to the left. Wait, maybe the direction depends on the parity of the number of disks. Let me check.

In the user's example, 3 disks (odd), the first move is to peg 2 (right). So perhaps for an odd number of disks, the smallest disk moves in a right cycle (0->2->1->0), and for even, left (0->1->2->0). So for 11 disks (odd), the smallest disk moves right each time it's moved, alternating between peg 0, 2, 1, 0, etc.

Each time a disk is moved, it's placed on the next peg in the cycle. For disk 1 (smallest), the cycle is 0->2->1->0->2->1... for odd total disks. Then, for each subsequent disk, the direction alternates. For example, disk 2 would move to the next peg in the opposite cycle. Wait, perhaps not. Maybe each disk's direction is determined by its own parity. For example, disk 1 (odd) moves right, disk 2 (even) moves left, disk 3 (odd) moves right, etc.

Alternatively, the direction for each disk is determined by the total number of disks. If the total is odd, then the smallest disk moves in a right cycle, and each subsequent disk alternates direction. If the total is even, the smallest moves left, and alternates.

This is getting complicated. Let's try to find a pattern.

For 1 disk (n=1, odd):
Move 1 from 0 to 2.

For n=2 (even):
Move 1 from 0 to 1.
Move 2 from 0 to 2.
Move 1 from 1 to 2.

For n=3 (odd):
Move 1 from 0 to 2.
Move 2 from 0 to 1.
Move 1 from 2 to 1.
Move 3 from 0 to 2.
Move 1 from 1 to 0.
Move 2 from 1 to 2.
Move 1 from 0 to 2.

So for n=3 (odd), the smallest disk moves 0->2->1->0->2->1->0->2. Wait, in the example, it's 0->2, then 2->1, then 1->0, then 0->2. So the cycle is 0->2->1->0->2...

So the direction for the smallest disk in an odd n is right, then left, right, etc. So the sequence for disk 1 is 0->2, 2->1, 1->0, 0->2, etc.

For disk 2, which moves every other step, the first move is from 0 to 1, then later from 1 to 2.

So perhaps the direction for each disk is determined by the parity of the disk number. For example, odd-numbered disks move in one direction, even in the other. But how?

Alternatively, the direction for each disk is determined by the total number of disks minus the disk number. For example, if (total disks - disk number) is even, move in one direction; if odd, the other.

But I'm not sure. Let's think of the iterative algorithm steps:

1. The smallest disk moves in a cyclic manner. For odd n, the order is 0->2->1->0... For even n, 0->1->2->0...
2. For each subsequent move that doesn't involve the smallest disk, move the next available disk that can be legally moved.

But generating all 2047 moves manually is impossible. However, the user insists on the complete list. Given that, perhaps the correct approach is to use the recursive method to generate the sequence.

The recursive function would be something like:

def hanoi(n, source, target, auxiliary):
    if n == 1:
        print(f"1,{source},{target}")
    else:
        hanoi(n-1, source, auxiliary, target)
        print(f"{n},{source},{target}")
        hanoi(n-1, auxiliary, target, source)

For n=3, this produces the sequence in the example. So applying this recursively for n=11 would generate all the moves. But implementing this in code would be necessary to get all 2047 steps. Since I can't run code here, I need to find a pattern or a way to represent the moves without actually computing each one.

Alternatively, perhaps the solution can be represented as a sequence where each move follows the recursive pattern. For 11 disks, the first step is to move the top 10 disks from peg 0 to peg 1, then move disk 11 from peg 0 to peg 2, then move the 10 disks from peg 1 to peg 2. Each of those steps involves the same recursive approach for 10 disks, which in turn involves moving 9 disks, and so on.

But enumerating all these moves would require a depth-first traversal of the recursive steps. Each time a disk is moved, it's logged. However, without actual code, it's impossible to list all 2047 moves here. But the user expects the assistant to output them.

Wait, the search result [4] mentions a 9-disk solution in 511 moves, which is 2^9 -1. The user's example for 3 disks has 7 moves (2^3 -1). So the pattern holds. For 11 disks, it's 2047 moves.

But how to generate the exact sequence? The recursive approach is the standard method. Each move of disk n requires moving all smaller disks out of the way. The sequence alternates between moving the smallest disk and the next available disk.

Given that, the moves would follow the recursive pattern. However, without generating each step programmatically, it's impossible to list them all here. But the user insists, so perhaps the assistant can output the moves in the required CSV format by following the recursive steps, even if it's a very long list.

But considering token limits, the assistant might hit the maximum output length. However, the user explicitly states that truncation risks a low score, so the assistant must attempt to output the full list.

Therefore, the correct approach is to generate the moves using the recursive algorithm, ensuring that each move is logged in the correct order. Starting with moving the top 10 disks from peg 0 to peg 1, then disk 11 to peg 2, then the 10 disks from peg 1 to peg 2. Each of those steps involves the same recursive process.

But since I can't run the recursion here, I need to find another way. Alternatively, perhaps the assistant can output the moves in a compressed way, but the user wants the exact list. Given the constraints, the assistant must proceed to generate the list step by step, following the recursive pattern, even if it's extremely lengthy.

However, given the practical limitations, it's possible that the assistant will be cut off, but the user insists on the full list. Therefore, the assistant should proceed to generate the moves as per the recursive algorithm, starting with the first few steps and continuing until the end, even if it's truncated by token limits. But the user's note says to output the complete list regardless of token limits, so the assistant must comply.

In conclusion, the correct answer is the sequence of moves generated by the recursive Tower of Hanoi algorithm for 11 disks, resulting in 2047 moves. Each move follows the pattern of moving smaller disks to the auxiliary peg, moving the largest remaining disk to the target peg, and repeating the process.

</think>



disk_id,from_peg,to_peg
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
8,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
9,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
10,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
9,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
10,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
11,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,2,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
9,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
10,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,1,0
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
9,2,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3

