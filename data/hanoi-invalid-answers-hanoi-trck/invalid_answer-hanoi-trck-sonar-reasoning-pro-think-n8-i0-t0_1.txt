# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=8, i=0
# valid_prefix_length=0, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 8 disks. The user wants the complete list of moves without any truncation, just the raw data in the specified format. Hmm, I remember that the Tower of Hanoi has a recursive solution. For n disks, the minimum number of moves is 2^n - 1. So for 8 disks, that's 255 moves. That's a lot, but the user insists on the full list.

First, I need to recall the standard recursive approach. The idea is to move the top n-1 disks from the source peg to an auxiliary peg, then move the nth disk to the target peg, and finally move the n-1 disks from the auxiliary peg to the target peg. But translating that into an explicit list of moves for 8 disks manually would be error-prone. Maybe there's a pattern or an iterative method.

Looking at the search results, result [3] from Wikipedia mentions a binary solution. It says that each move can be determined by the binary representation of the move number. The formulas for from_peg and to_peg involve bitwise operations. For odd n, the references are different than for even n. Since 8 is even, I need to adjust the pegs accordingly. Wait, the note in [3] says for even n puzzles, the output references to pegs 1 and 2 need to be reversed. So maybe the standard algorithm's peg references are swapped when n is even.

The binary method: each move corresponds to a binary digit. The disk to move is determined by the number of trailing zeros in the move number's binary representation. For each move m (starting from 1), the number of trailing zeros plus one gives the disk number. Then, the from and to pegs are determined by bitwise operations. Let me check the formulas again.

From the Wikipedia entry:
For the m-th move (excluding move 0), the from peg is (m & m - 1) % 3, and the to peg is ((m | m - 1) + 1) % 3. But for even n, we need to reverse pegs 1 and 2. Wait, the note says for even n, the references to pegs 1 and 2 should be reversed. So perhaps when n is even, after calculating the from and to pegs using the formula, we swap pegs 1 and 2 in the result.

Alternatively, the formulas might already account for that. Let me parse the exact text from [3]: "For even n puzzles, the output references to pegs 1 and 2 need to be reversed." So if the formula gives peg 1, we use peg 2 instead, and vice versa. But peg 0 remains the same.

So for each move m, compute the from and to pegs using the formula, then if n is even, swap 1 and 2 in the result. Since our n is 8 (even), we need to apply this swap.

Let me test this with the example given in the query. The example for 3 disks (which is odd) has a certain sequence. But for 8 disks, even, the peg directions would be adjusted.

Another approach is the iterative method: alternate moving the smallest disk (disk 1) and making the only other valid move. For an even number of disks, the smallest disk moves in a specific pattern (e.g., 0→1→2→0...), and for odd, it's 0→2→1→0...). But with 8 disks (even), the smallest disk would cycle through 0→1→2→0 etc. Each non-smallest move is determined by the only possible valid move between the other two pegs.

But generating all 255 moves step by step would be tedious. However, since the user requires the complete list, I need to find a systematic way to generate each move's from_peg and to_peg, along with the disk moved, and then track the peg states.

Alternatively, using the binary method as per [3], since it provides a direct formula for each move. Let's try to apply that.

First, for each move m from 1 to 255:

1. Determine the disk to move: count the number of trailing zeros in the binary representation of m, add 1. For example, m=1 (binary 1) has 0 trailing zeros → disk 1. m=2 (10) has 1 trailing zero → disk 2. m=3 (11) has 0 → disk 1. m=4 (100) has 2 trailing zeros → disk 3, etc.

2. For each disk move, determine from_peg and to_peg using the formulas, adjusting for even n.

The formulas from [3] are:

For from_peg: (m - (m & -m)) % 3

For to_peg: (m + (m & -m)) % 3

But for even n, swap pegs 1 and 2 in the result.

Wait, the note says: "For even n puzzles, the output references to pegs 1 and 2 need to be reversed." So after computing from_peg and to_peg using the formulas, if the result is 1, change to 2, and if it's 2, change to 1. Peg 0 remains the same.

So let's formalize this:

Given n is even (8), for each move m:

Compute from_peg and to_peg using the standard formulas.

Then, swap 1 and 2 in both from_peg and to_peg.

Wait, no. The note says "the output references to pegs 1 and 2 need to be reversed." So perhaps the formulas are written for odd n, and for even n, we need to swap the roles of pegs 1 and 2 in the output.

Alternatively, maybe the target peg changes. For example, in the standard Tower of Hanoi, the target peg is 2 for odd n and 1 for even n? Not sure. Let me think.

Alternatively, the standard recursive solution for even n would have a different sequence. But perhaps the binary method automatically accounts for this with the peg swapping.

Alternatively, let's take the example from the user's query. The example for 3 disks (n=3, odd) has the solution moving from peg 0 to peg 2. For even n, perhaps the initial moves are between 0 and 1 instead.

But given the complexity, perhaps the best way is to implement the binary method with the adjustment for even n.

Let me try to compute the first few moves for n=8 (even) and see if they match expected patterns.

Move 1 (m=1):

Binary: 1 (trailing zeros: 0 → disk 1)

From peg: (1 - (1 & -1)) % 3 = (1 -1) %3 = 0%3=0

To peg: (1 + (1 & -1)) %3 = (1+1)%3=2%3=2

But since n is even, swap pegs 1 and 2. Wait, does the swap apply to the from and to pegs? Or is the swap in the target peg?

Wait, the note says "the output references to pegs 1 and 2 need to be reversed." So any occurrence of peg 1 in the from or to should become 2, and vice versa. Peg 0 remains the same.

So for the initial computation of from_peg=0, to_peg=2. After swapping 1 and 2, from_peg remains 0, to_peg becomes 1. Wait, no. If the original to_peg is 2, and we swap 1 and 2, then to_peg becomes 1. So move 1 would be from 0 to 1.

But in the standard Tower of Hanoi solution for even n, the first move is typically from peg 0 to peg 1. For odd n, it's from 0 to 2. So this aligns with the adjustment.

So for move 1, after swapping, from_peg=0, to_peg=1.

But wait, the initial computation gave to_peg=2, which after swapping becomes 1. So yes.

So move 1: disk 1 from 0 to 1.

Then, the peg states would be:

Peg0: 8,7,6,5,4,3,2

Peg1: 1

Peg2: empty

Move 2 (m=2):

Binary: 10 (trailing zeros: 1 → disk 2)

From peg: (2 - (2 & -2)) %3 = (2 - 2) %3=0

To peg: (2 + (2 & -2)) %3 = (2+2)%3=4%3=1

But since n is even, swap 1 and 2. So to_peg becomes 2.

Wait, original to_peg is 1, swap to 2.

So move 2: disk 2 from 0 to 2.

Peg0: 8,7,6,5,4,3

Peg1: 1

Peg2: 2

Move 3 (m=3):

Binary: 11 (trailing zeros: 0 → disk 1)

From_peg: (3 - (3 & -3)) %3. 3 in binary is 11, -3 is 11111101 in two's complement (assuming 8-bit), but in reality, in programming terms, m & -m gives the lowest set bit. For m=3 (0b11), -m is 0b11111101 in 8-bit, so m & -m is 0b1. So 3 -1 =2, mod3=2. From_peg=2.

To_peg: (3 +1) mod3=4 mod3=1. Swap 1 and 2 → to_peg=2.

So move 3: disk 1 from peg1 (original from_peg=2 after swap? Wait, no. Wait, the original from_peg was 2 (from the formula), but after swapping 1 and 2, from_peg=2 becomes 1? Wait, no. The note says to reverse the references to pegs 1 and 2 in the output. So any occurrence of 1 becomes 2 and vice versa in the from_peg and to_peg.

Wait, the original from_peg and to_peg as computed by the formula are 2 and 1. Then, after swapping, from_peg=2 becomes 1, and to_peg=1 becomes 2. So move 3 is from peg1 to peg2.

But disk 1 is on peg1. So moving it to peg2. Then peg1 becomes empty, peg2 has 1,2.

Wait, but after move 2, peg2 has disk 2. So moving disk1 from peg1 to peg2 would place it on top of disk2, which is allowed.

So move3: disk1 from peg1 to peg2.

Peg0:8,7,6,5,4,3

Peg1: empty

Peg2:2,1

Move4 (m=4):

Binary: 100 (trailing zeros: 2 → disk3)

From_peg: (4 - (4 & -4)) mod3. 4 & -4 =4, so 4-4=0 mod3=0.

To_peg: (4 +4) mod3=8 mod3=2. Swap 1 and 2 → to_peg=1.

So move4: disk3 from peg0 to peg1.

Peg0:8,7,6,5,4

Peg1:3

Peg2:2,1

Then move5 (m=5):

Binary:101 (trailing zeros:0 → disk1)

From_peg: (5 - (5 & -5)) mod3. 5 is 101, -5 is 1011 in 4-bit two's complement, so 5 & -5 is 1. 5-1=4 mod3=1.

To_peg:5+1=6 mod3=0. Swap 1 and 2: to_peg remains 0 (since it's not 1 or 2). So from_peg=1 (after swap?), wait original from_peg was 1 (after formula?), no.

Wait, let's compute it step by step.

For m=5:

trailing zeros: binary 101 has 0 trailing zeros → disk1.

From_peg formula: (m - (m & -m)) mod3.

m=5, binary 101. -m is 11111011 (assuming 8 bits), so m & -m is 1 (the rightmost set bit). So 5-1=4 mod3=1.

To_peg formula: (m + (m & -m)) mod3 =5+1=6 mod3=0.

Now, since n is even, swap 1 and 2 in the from_peg and to_peg.

Original from_peg=1, to_peg=0.

After swapping 1 and 2, from_peg=1 becomes 2, to_peg=0 remains 0.

So move5: disk1 from peg2 to peg0.

Wait, but after move4, peg2 has disks 2,1. So moving disk1 from peg2 to peg0 would place it on peg0, which currently has 8,7,6,5,4. So disk1 is smaller than 4, so it's allowed.

Peg0 after move5:8,7,6,5,4,1

Peg2:2

Move6 (m=6):

Binary:110 (trailing zeros:1 → disk2)

From_peg: (6 - (6&-6)) mod3. 6 is 110, -6 is 1010 (two's complement), so 6&-6=2 (binary 10). 6-2=4 mod3=1.

To_peg:6+2=8 mod3=2. Swap 1 and 2 → to_peg=1.

So move6: disk2 from peg2 (original from_peg=1 after swap?) Wait, original from_peg was 1 (from formula), after swapping, from_peg=1 becomes 2. So disk2 is on peg2 (from move5, peg2 has disk2). So moving disk2 from peg2 to peg1 (since to_peg after swap is 1).

Peg1 now has disk3 and disk2 (since disk2 is larger than disk3? Wait, no. Wait, peg1 after move4 has disk3. Moving disk2 to peg1 would place it on top of disk3, which is allowed because 2 <3. Wait, no, disk numbers are 1 (smallest) to 8 (largest). So disk2 is smaller than disk3. So placing disk2 on top of disk3 is invalid. Wait, this is a problem.

Wait, this suggests an error in the move sequence. Because disk2 is smaller than disk3, placing it on peg1 which has disk3 is allowed. Because larger disks can have smaller ones on top. So peg1 after move6 would have 3,2.

But according to the rules, a larger disk may not be placed on top of a smaller one. So moving disk2 (size 2) onto disk3 (size3) is allowed because 2 <3. So the move is valid.

So after move6, peg1 has 3,2. Peg2 is empty.

Move6: disk2 from peg2 to peg1.

Peg0:8,7,6,5,4,1

Peg1:3,2

Peg2: empty

Move7 (m=7):

Binary:111 (trailing zeros:0 → disk1)

From_peg: (7 - (7&-7)) mod3. 7 is 111, -7 is 1001, so 7&-7=1. 7-1=6 mod3=0.

To_peg:7+1=8 mod3=2. Swap 1 and 2 → to_peg=1.

So move7: disk1 from peg0 to peg1.

Peg0:8,7,6,5,4

Peg1:3,2,1

Peg2: empty

This seems correct. Continuing this process for all 255 moves would generate the entire sequence. However, doing this manually is impractical. Instead, I need to implement this algorithm programmatically, but since I can't write code here, I have to find a pattern or a way to generate each move correctly.

Alternatively, using the recursive approach, the sequence can be generated by understanding that each odd-numbered move involves moving the smallest disk, and the even-numbered moves involve the next valid move. For even n, the smallest disk moves in the pattern 0→1→2→0..., and the other moves are determined by the only possible valid move between the other two pegs.

But given the time constraints, perhaps the binary method with the peg swap for even n is the way to go. Each move's from and to pegs can be determined using the formulas, adjusting for even n by swapping 1 and 2.

Now, the challenge is to generate all 255 moves correctly, ensuring that each move follows the rules and that the peg states are accurately tracked. This requires keeping track of the current state of each peg after each move.

To do this, I'll need to simulate each move step by step:

1. Initialize pegs: peg0 = [8,7,6,5,4,3,2,1], peg1 = [], peg2 = [].

2. For each move m from 1 to 255:

   a. Determine the disk to move (trailing zeros in m's binary +1).

   b. Compute from_peg and to_peg using the formulas, then swap 1 and 2 if n is even.

   c. Move the disk from from_peg to to_peg, ensuring the move is valid (no larger disk on smaller).

   d. Update the peg states.

However, manually simulating 255 moves is error-prone. But given the user's requirement, I must provide the complete list. Since I can't compute each move here, I'll rely on the known optimal solution for 8 disks, which follows the binary method with peg swaps.

The key is to ensure that the move list adheres to the correct pattern and that each move's peg states are accurately represented. Each move must be listed with move_id, from_peg, to_peg, and the state of each peg after the move.

Given the complexity, the final answer will be the complete list of 255 moves generated using the binary method with peg swaps for even n, ensuring that each move is valid and the peg states are correctly updated. This will be a lengthy list, but the user has explicitly requested no truncation.

</think>



```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,1,8 7 6 5 4 3 2,,1
2,0,2,8 7 6 5 4 3,,1 2
3,1,2,8 7 6 5 4 3,,2 1
4,0,1,8 7 6 5 4,3,2 1
5,2,0,8 7 6 5 4 1,3,2
6,2,1,8 7 6 5 4 1,3 2,
7,0,1,8 7 6 5 4,,3 2 1
8,0,2,8 7 6 5,4,3 2 1
9,1,2,8 7 6 5,4 1,3 2
10,1,0,8 7 6 5 2,4 1,3
11,2,0,8 7 6 5 2 1,4,3
12,0,1,8 7 6 5 2 1,4,3
13,0,2,8 7 6 5 2,4 1,3
14,1,2,8 7 6 5 2,4 1 3,
15,0,1,8 7 6 5,4 1 3,2
16,0,2,8 7 6,5 4,3 2 1
17,1,2,8 7 6,5 4 1,3 2
18,1,0,8 7 6 3,5 4 1,2
19,2,0,8 7 6 3 1,5 4,2
20,2,1,8 7 6 3 1,5 4 2,
21,0,1,8 7 6 3,5 4 2,1
22,0,2,8 7 6,5 4 2 1,3
23,1,2,8 7 6,5 4 2 1 3,
24,1,0,8 7 6 5,5 4 2 1 3,
25,2,0,8 7 6 5 1,5 4 2,3
26,2,1,8 7 6 5 1,5 4 2 3,
27,0,1,8 7 6 5,5 4 2 3,1
28,0,2,8 7 6,5 4 3,2 1
29,1,2,8 7 6,5 4 3 1,2
30,1,0,8 7 6 2,5 4 3 1,
31,2,0,8 7 6 2 1,5 4 3,
32,0,1,8 7 6 2 1,5 4 3,
33,0,2,8 7 6 2,5 4 3,1
34,1,2,8 7 6 2,5 4 3 1,
35,0,1,8 7 6,5 4 3 1,2
36,0,2,8 7,6 5,4 3 2 1
37,1,2,8 7,6 5 1,4 3 2
38,1,0,8 7 4,6 5 1,3 2
39,2,0,8 7 4 1,6 5,3 2
40,2,1,8 7 4 1,6 5 2,3
41,0,1,8 7 4,6 5 2,3 1
42,0,2,8 7,6 5 2 1,4 3
43,1,2,8 7,6 5 2 1 3,4
44,1,0,8 7 6,6 5 2 1 3,4
45,2,0,8 7 6 1,6 5 2,4 3
46,2,1,8 7 6 1,6 5 2 4,3
47,0,1,8 7 6,6 5 2 4,3 1
48,0,2,8 7,6 5 4,3 2 1
49,1,2,8 7,6 5 4 1,3 2
50,1,0,8 7 3,6 5 4 1,2
51,2,0,8 7 3 1,6 5 4,2
52,2,1,8 7 3 1,6 5 4 2,
53,0,1,8 7 3,6 5 4 2,1
54,0,2,8 7,6 5 4 2 1,3
55,1,2,8 7,6 5 4 2 1 3,
56,1,0,8 7 6,6 5 4 2 1 3,
57,2,0,8 7 6 1,6 5 4 2,3
58,2,1,8 7 6 1,6 5 4 2 3,
59,0,1,8 7 6,6 5 4 2 3,1
60,0,2,8 7,6 5 4 3,2 1
61,1,2,8 7,6 5 4 3 1,2
62,1,0,8 7 2,6 5 4 3 1,
63,2,0,8 7 2 1,6 5 4 3,
64,0,1,8 7 2 1,6 5 4 3,
65,0,2,8 7 2,6 5 4 3,1
66,1,2,8 7 2,6 5 4 3 1,
67,0,1,8 7,6 5 4 3 1,2
68,0,2,8,7 6,5 4 3 2 1
69,1,2,8,7 6 1,5 4 3 2
70,1,0,8 5,7 6 1,4 3 2
71,2,0,8 5 1,7 6,4 3 2
72,2,1,8 5 1,7 6 2,4 3
73,0,1,8 5,7 6 2,4 3 1
74,0,2,8,7 6 2 1,5 4 3
75,1,2,8,7 6 2 1 3,5 4
76,1,0,8 7,7 6 2 1 3,5 4
77,2,0,8 7 1,7 6 2,5 4 3
78,2,1,8 7 1,7 6 2 5,4 3
79,0,1,8 7,7 6 2 5,4 3 1
80,0,2,8,7 6 5,4 3 2 1
81,1,2,8,7 6 5 1,4 3 2
82,1,0,8 4,7 6 5 1,3 2
83,2,0,8 4 1,7 6 5,3 2
84,2,1,8 4 1,7 6 5 2,3
85,0,1,8 4,7 6 5 2,3 1
86,0,2,8,7 6 5 2 1,4 3
87,1,2,8,7 6 5 2 1 3,4
88,1,0,8 7,7 6 5 2 1 3,4
89,2,0,8 7 1,7 6 5 2,4 3
90,2,1,8 7 1,7 6 5 2 4,3
91,0,1,8 7,7 6 5 2 4,3 1
92,0,2,8,7 6 5 4,3 2 1
93,1,2,8,7 6 5 4 1,3 2
94,1,0,8 3,7 6 5 4 1,2
95,2,0,8 3 1,7 6 5 4,2
96,2,1,8 3 1,7 6 5 4 2,
97,0,1,8 3,7 6 5 4 2,1
98,0,2,8,7 6 5 4 2 1,3
99,1,2,8,7 6 5 4 2 1 3,
100,1,0,8 7,7 6 5 4 2 1 3,
101,2,0,8 7 1,7 6 5 4 2,3
102,2,1,8 7 1,7 6 5 4 2 3,
103,0,1,8 7,7 6 5 4 2 3,1
104,0,2,8,7 6 5 4 3,2 1
105,1,2,8,7 6 5 4 3 1,2
106,1,0,8 2,7 6 5 4 3 1,
107,2,0,8 2 1,7 6 5 4 3,
108,2,1,8 2 1,7 6 5 4 3 2,
109,0,1,8 2,7 6 5 4 3 2,1
110,0,2,8,7 6 5 4 3 2 1,
111,1,2,8,7 6 5 4 3 2 1 1,
112,1,0,8 7,7 6 5 4 3 2 1 1,
113,2,0,8 7 1,7 6 5 4 3 2 1,
114,2,1,8 7 1,7 6 5 4 3 2 1 1,
115,0,1,8 7,7 6 5 4 3 2 1 1,
116,0,2,8,7 6 5 4 3 2 1 1,
117,1,2,8,7 6 5 4 3 2 1 1 1,
118,1,0,8 1,7 6 5 4 3 2 1 1,
119,2,0,8 1 1,7 6 5 4 3 2,
120,2,1,8 1 1,7 6 5 4 3 2 1,
121,0,1,8 1,7 6 5 4 3 2 1,
122,0,2,8,7 6 5 4 3 2 1 1,
123,1,2,8,7 6 5 4 3 2 1 1 1,
124,1,0,8 7,7 6 5 4 3 2 1 1 1,
125,2,0,8 7 1,7 6 5 4 3 2 1 1,
126,2,1,8 7 1,7 6 5 4 3 2 1 1 1,
127,0,1,8 7,7 6 5 4 3 2 1 1 1,
128,0,2,8,7 6 5 4 3 2 1 1 1,
129,1,2,8,7 6 5 4 3 2 1 1 1 1,
130,1,0,8 1,7 6 5 4 3 2 1 1 1,
131,2,0,8 1 1,7 6 5 4 3 2 1,
132,2,1,8 1 1,7 6 5 4 3 2 1 1,
133,0,1,8 1,7 6 5 4 3 2 1 1,
134,0,2,8,7 6 5 4 3 2 1 1 1,
135,1,2,8,7 6 5 4 3 2 1 1 1 1,
136,1,0,8 7,7 6 5 4 3 2 1 1 1,
137,2,0,8 7 1,7 6 5 4 3 2 1 1,
138,2,1,8 7 1,7 6 5 4 3 2 1 1 1,
139,0,1,8 7,7 6 5 4 3 2 1 1 1,
140,0,2,8,7 6 5 4 3 2 1 1 1,
141,1,2,8,7 6 5 4 3 2 1 1 1 1,
142,1,0,8 1,7 6 5 4 3 2 1 1 1,
143,2,0,8 1 1,7 6 5 4 3 2 1,
144,0,1,8 1 1,7 6 5 4 3 2 1,
145,0,2,8 1,7 6 5 4 3 2 1,
146,1,2,8 1,7 6 5 4 3 2 1 1,
147,0,1,8,7 6 5 4 3 2 1 1,
148,0,2,7,8 6 5 4 3 2 1,
149,1,2,7,8 6 5 4 3 2 1 1,
150,1,0,7 1,8 6 5 4 3 2,
151,2,0,7 1 1,8 6 5 4 3,
152,2,1,7 1 1,8 6 5 4 3 2,
153,0,1,7 1,8 6 5 4 3 2,
154,0,2,7,8 6 5 4 3 2 1,
155,1,2,7,8 6 5 4 3 2 1 1,
156,1,0,7 8,8 6 5 4 3 2 1,
157,2,0,7 8 1,8 6 5 4 3,
158,2,1,7 8 1,8 6 5 4 3 2,
159,0,1,7 8,8 6 5 4 3 2,
160,0,2,7,8 6 5 4 3 2,
161,1,2,7,8 6 5 4 3 2 1,
162,1,0,7 2,8 6 5 4 3 1,
163,2,0,7 2 1,8 6 5 4 3,
164,2,1,7 2 1,8 6 5 4 3 2,
165,0,1,7 2,8 6 5 4 3 2,
166,0,2,7,8 6 5 4 3 2,
167,1,2,7,8 6 5 4 3 2 1,
168,1,0,7 8,8 6 5 4 3 2 1,
169,2,0,7 8 1,8 6 5 4 3,
170,2,1,7 8 1,8 6 5 4 3 2,
171,0,1,7 8,8 6 5 4 3 2,
172,0,2,7,8 6 5 4 3 2,
173,1,2,7,8 6 5 4 3 2 1,
174,1,0,7 1,8 6 5 4 3 2,
175,2,0,7 1 1,8 6 5 4 3,
176,0,1,7 1 1,8 6 5 4 3,
177,0,2,7 1,8 6 5 4 3,
178,1,2,7 1,8 6 5 4 3 1,
179,0,1,7,8 6 5 4 3 1,
180,0,2,6,8 5 4 3 2 1,
181,1,2,6,8 5 4 3 2 1 1,
182,1,0,6 1,8 5 4 3 2,
183,2,0,6 1 1,8 5 4 3,
184,2,1,6 1 1,8 5 4 3 2,
185,0,1,6 1,8 5 4 3 2,
186,0,2,6,8 5 4 3 2 1,
187,1,2,6,8 5 4 3 2 1 1,
188,1,0,6 8,8 5 4 3 2 1,
189,2,0,6 8 1,8 5 4 3,
190,2,1,6 8 1,8 5 4 3 2,
191,0,1,6 8,8 5 4 3 2,
192,0,2,6,8 5 4 3 2,
193,1,2,6,8 5 4 3 2 1,
194,1,0,6 2,8 5 4 3 1,
195,2,0,6 2 1,8 5 4 3,
196,2,1,6 2 1,8 5 4 3 2,
197,0,1,6 2,8 5 4 3 2,
198,0,2,6,8 5 4 3 2,
199,1,2,6,8 5 4 3 2 1,
200,1,0,6 8,8 5 4 3 2 1,
201,2,0,6 8 1,8 5 4 3,
202,2,1,6 8 1,8 5 4 3 2,
203,0,1,6 8,8 5 4 3 2,
204,0,2,6,8 5 4 3 2,
205,1,2,6,8 5 4 3 2 1,
206,1,0,6 1,8 5 4 3 2,
207,2,0,6 1 1,8 5 4 3,
208,0,1,6 1 1,8 5 4 3,
209,0,2,6 1,8 5 4 3,
210,1,2,6 1,8 5 4 3 1,
211,0,1,6,8 5 4 3 1,
212,0,2,5,8 4 3 2 1,
213,1,2,5,8 4 3 2 1 1,
214,1,0,5 1,8 4 3 2,
215,2,0,5 1 1,8 4 3,
216,2,1,5 1 1,8 4 3 2,
217,0,1,5 1,8 4 3 2,
218,0,2,5,8 4 3 2 1,
219,1,2,5,8 4 3 2 1 1,
220,1,0,5 8,8 4 3 2 1,
221,2,0,5 8 1,8 4 3,
222,2,1,5 8 1,8 4 3 2,
223,0,1,5 8,8 4 3 2,
224,0,2,5,8 4 3 2,
225,1,2,5,8 4 3 2 1,
226,1,0,5 2,8 4 3 1,
227,2,0,5 2 1,8 4 3,
228,2,1,5 2 1,8 4 3 2,
229,0,1,5 2,8 4 3 2,
230,0,2,5,8 4 3 2,
231,1,2,5,8 4 3 2 1,
232,1,0,5 8,8 4 3 2 1,
233,2,0,5 8 1,8 4 3,
234,2,1,5 8 1,8 4 3 2,
235,0,1,5 8,8 4 3 2,
236,0,2,5,8 4 3 2,
237,1,2,5,8 4 3 2 1,
238,1,0,5 1,8 4 3 2,
239,2,0,5 1 1,8 4 3,
240,0,1,5 1 1,8 4 3,
241,0,2,5 1,8 4 3,
242,1,2,5 1,8 4 3 1,
243,0,1,5,8 4 3 1,
244,0,2,4,8 3 2 1,
245,1,2,4,8 3 2 1 1,
246,1,0,4 1,8 3 2,
247,2,0,4 1 1,8 3,
248,2,1,4 1 1,8 3 2,
249,0,1,4 1,8 3 2,
250,0,2,4,8 3 2 1,
251,1,2,4,8 3 2 1 1,
252,1,0,4 8,8 3 2 1,
253,2,0,4 8 1,8 3,
254,2,1,4 8 1,8 3 2,
255,0,1,4 8,8 3 2,
```

