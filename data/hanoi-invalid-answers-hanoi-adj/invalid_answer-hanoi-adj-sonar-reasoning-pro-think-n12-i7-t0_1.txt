# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=12, i=7
# valid_prefix_length=5, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 12 disks. The user wants the complete list of moves without any truncation. Hmm, the standard solution for Tower of Hanoi is recursive: move n-1 disks from the source to the auxiliary peg, then move the nth disk to the target, and then move the n-1 disks from auxiliary to target. But with 12 disks, that's 2^12 - 1 = 4095 moves. That's a lot to list out manually. 

Wait, the search results mention a Gray code solution. The Gray code method determines which disk to move at each step. For each move, the disk corresponds to the number of times the move number can be divided by 2. Since the number of disks is even (12), the smallest disk moves in the order f → r → t → f → r → t, etc. The starting peg is 0, target is 2, so the remaining peg is 1. So the smallest disk (1) should cycle 0 → 1 → 2 → 0 → 1 → 2...

But how do I determine the direction for each subsequent disk? The Gray code approach might help here. Each move corresponds to a bit change, and the disk to move is determined by the number of trailing zeros in the move number's binary representation. For each move m (starting from 1), the disk is the number of times m can be divided by 2, which is the same as the position of the rightmost 1 bit in binary. So for move 1 (binary 1), disk 1 (since 0 trailing zeros, but maybe disk is index +1?), wait the note in the search result says disks are numbered starting from 0. Wait, the example in the search result [1] says "identifying the disks by numbers starting from 0 in order of increasing size", so disk 0 is the smallest, disk 11 is the largest (since there are 12 disks). But the problem states the disks are numbered 1 (smallest) to 12 (largest). Wait, the user's problem says the disks are numbered 1 (smallest) to 12 (largest). So in the initial configuration, Peg 0 has 12 at the bottom, then 11, ..., 1 on top. So the disks are labeled 1 to 12, with 1 being the smallest. So when applying the Gray code method, the disk to move is determined by the number of trailing zeros in the move number (starting from 1). For each move m, the disk is the number of trailing zeros in (m-1) in binary. Wait, maybe I need to adjust the formula. Let me check the search result [1] again: "the ordinal of the disk to be moved during move m is the number of times m can be divided by 2." So for move m, divide m by 2 until it's odd, the count is the disk number. Wait, but the example given in the search result for 3 disks has moves starting with moving disk 1 (smallest). Let's see: for move 1, m=1, divided by 2 once gives 0.5, so count is 0? Or maybe it's the exponent of 2 in m. Wait, the number of times m can be divided by 2 is the number of trailing zeros in m's binary representation plus one if m is even. Wait, maybe it's the number of trailing zeros in (m-1). Let me think. For example, in the sample move list provided, the first move is moving disk 1. According to the formula, for move m=1, the number of times m can be divided by 2 is 0 (since 1 is odd). But the disk moved is 1. Hmm, maybe the formula is (number of trailing zeros in m) + 1. Wait, the search result says: "the ordinal of the disk to be moved during move m is the number of times m can be divided by 2." So for m=1, divided by 2 zero times (since it's odd), so disk 0 (if disks are 0-indexed). But in the example, the first move is disk 1. Wait, the example in the user's query has disks numbered 1 (smallest) to 3 (largest), and the first move is disk 1. So perhaps the formula gives the disk number as (number of times m can be divided by 2) + 1. Because in the example, for move 1, divided by 2 zero times, so disk 0+1=1. That makes sense. So for the user's problem, disks are numbered 1 to 12, so the formula would be: for each move m (starting at 1), the disk to move is (number of times m can be divided by 2) + 1. Wait, but the search result says "the ordinal of the disk to be moved during move m is the number of times m can be divided by 2." But in their example, the disks are numbered starting from 0. So if the user's disks are numbered starting from 1, we need to adjust. Alternatively, maybe the formula is correct, and the disk numbers in the problem are 1-based, so we need to add 1. Hmm, this is a bit confusing. Let me recheck the search result [1]: "identifying the disks by numbers starting from 0 in order of increasing size". So in their example, disk 0 is the smallest. But the user's problem has disks numbered 1 (smallest) to 12 (largest). So to apply the formula, we need to subtract 1 from the disk number. For example, in the user's case, the smallest disk is 1, which would correspond to disk 0 in the formula. So when the formula says the disk is 0, we move disk 1. Wait, that's a problem. So perhaps the formula gives the disk index (0-based), and the user's disks are 1-based. So to get the correct disk, we need to add 1. For example, in the sample move list provided by the user, the first move is disk 1. According to the formula, for move m=1, the number of times divided by 2 is 0, so disk 0 (0-based), which is disk 1 in the user's numbering. So yes, the formula gives the 0-based disk index, and we need to add 1 to get the user's disk number. Therefore, for each move m, the disk to move is (number of times m can be divided by 2) + 1. Wait, no. Wait, the formula in the search result says: "the ordinal of the disk to be moved during move m is the number of times m can be divided by 2." So if m is 1, divided by 2 zero times → disk 0 (0-based). But in the user's example, the first move is disk 1 (1-based). So the formula's disk number is 0-based, and the user's disk numbers are 1-based. Therefore, to get the correct disk, we take the formula's result (0-based) and add 1. So for move m, disk = (number of times m can be divided by 2) + 1. Wait, but in the sample provided by the user, the first move is disk 1, which would correspond to (0) +1 =1. That works. Then the second move in the sample is disk 2. Let's see: move m=2. Number of times 2 can be divided by 2 is 1. So (1) +1=2. Which matches the sample. Third move is disk 1 again (m=3). 3 divided by 2 once gives 1.5, so number of times is 0. So disk 0+1=1. Yes. So the formula works. Therefore, for the user's problem, each move m (starting at 1), the disk to move is (number of times m can be divided by 2) +1. Now, the next part is determining where to move the disk. For the smallest disk (disk 1), the movement depends on whether the total number of disks is even or odd. The user has 12 disks, which is even. According to the search result [1], for even number of disks, the smallest disk cycles in the order f → r → t → f → r → t, etc. Wait, the search result says: "If the number of disks is even, this must be reversed: f → r → t → f → r → t, etc." Wait, the starting peg is f=0, target is t=2, and the remaining peg is r=1. So for even disks, the smallest disk (1) moves in the order 0 → 1 → 2 → 0 → 1 → 2... So each time it moves to the next peg in that cycle. For other disks, the move is determined by the only possible legal move. So the algorithm would be: For each move m from 1 to 4095: 1. Determine the disk to move: d = (number of trailing zeros in m's binary representation) +1. 2. If it's the smallest disk (d=1), move it to the next peg in the cycle (0→1→2→0...). 3. For other disks, there's only one possible move that doesn't violate the rules. So how to implement this? Let's outline the steps: 1. Initialize the pegs. Peg 0 has disks 12,11,...,1 (from bottom to top). Pegs 1 and 2 are empty. 2. For each move number m from 1 to 4095: a. Determine the disk to move: count the number of times m can be divided by 2 (i.e., the number of trailing zeros in m's binary representation plus one if m is even). Wait, no: the number of times m can be divided by 2 is the exponent of 2 in m. For example, m=4 (100 in binary) can be divided by 2 twice (4/2=2, 2/2=1, then can't divide by 2 again). So the count is 2. So for m=4, disk is 2+1=3? Wait, no. Wait, the formula is the number of times m can be divided by 2. For m=1: 1/2=0.5, so 0 times. So disk 0+1=1. For m=2: 2/2=1, which is 1 time. So disk 1+1=2. For m=3: 3/2=1.5, so 0 times. Disk 0+1=1. For m=4: 4/2=2, 2/2=1. So 2 times. Disk 2+1=3. So yes, that seems correct. So for each m, the disk is (number of times m can be divided by 2) +1. Then, for disk 1 (smallest), move it in the cycle 0→1→2→0... For even n (12), the direction is f→r→t. So starting at peg 0, the first move is to peg 1, then to peg 2, then to peg 0, etc. For other disks, the move is determined by the only possible legal move. For example, if disk 2 is on peg 0, and we need to move it, the possible pegs are 1 or 2, but we have to check which peg has a larger top disk or is empty. Wait, but how to track the state of each peg after each move? That's the challenge. Manually generating 4095 moves would be impossible without a programmatic approach. But the user expects the complete list. Since I can't compute it step by step here, perhaps I can find a pattern or use the recursive approach to generate the moves. Alternatively, the recursive solution for Tower of Hanoi is well-known. For n disks, the minimal number of moves is 2^n -1. For 12 disks, that's 4095 moves. The recursive approach is: To move n disks from source to target using auxiliary: 1. Move n-1 disks from source to auxiliary using target. 2. Move nth disk from source to target. 3. Move n-1 disks from auxiliary to target using source. Each of these steps is recursive. But generating the exact sequence of moves requires implementing this recursion. However, the problem is that the user's target peg is 2, and the initial peg is 0. So the standard Tower of Hanoi solution would move from 0 to 2 using 1 as auxiliary. But the moves would follow the recursive steps. However, the exact sequence of moves can be generated using this method. For example, for n=1: move disk 1 from 0 to 2. For n=2: move 1 from 0→1, then 2 from 0→2, then 1 from 1→2. For n=3: move 1 from 0→2, 2 from 0→1, 1 from 2→1, 3 from 0→2, 1 from 1→0, 2 from 1→2, 1 from 0→2. Which matches the example provided by the user. So the recursive approach generates the correct sequence. Therefore, the solution for 12 disks would be to apply this recursive approach, which would generate 4095 moves. However, listing all 4095 moves here is impractical manually. But the user insists on the complete list. Since I can't generate all 4095 moves step by step here, perhaps I can provide the algorithm and then the list. But the user explicitly says they don't want any explanation, just the raw list. So I need to find a way to output the entire list. But how? The search result [3] provides code for the Tower of Hanoi problem. Let me check that. The code in [3] uses a recursive approach. The function `dfs` moves n disks from A to C via B. The code is as follows: ``` def dfs(n: int, src: list[int], buf: list[int], tar: list[int]): """Solve the Tower of Hanoi problem recursively""" if n == 1: # Move disk 1 from src to tar tar.append(src.pop()) return # Move n-1 disks from src to buf via tar dfs(n - 1, src, tar, buf) # Move the nth disk from src to tar tar.append(src.pop()) # Move n-1 disks from buf to tar via src dfs(n - 1, buf, src, tar) ``` So this function appends the moves to the target list. But how to track the actual moves (disk, from, to)? The code in [3] uses lists to represent the pegs, but doesn't record the moves. However, the user's example shows that each move is a list [disk, from, to]. So to generate the list of moves, we need to modify the code to record each move. For example, whenever a disk is moved from src to tar, we record the disk number, the source peg index, and the target peg index. But in the code, the pegs are represented as lists, and the disk numbers are stored in the lists. So when we pop from src and append to tar, we can record the disk number. But in the user's problem, the disks are numbered 1 to 12, with 1 being the smallest. So in the initial state, peg 0 has [12,11,...,1]. Wait, no. The initial configuration is Peg 0: 12 (bottom), ... 2, 1 (top). So the list would be [12,11,10,...,1], but when you pop from the list, you get the top disk, which is 1. So the code in [3] uses lists where the last element is the top disk. So for the initial setup, peg 0 is [12,11,10,...,1], but that's not correct because the top disk is 1. Wait, no. If the list is ordered as [12,11,...,1], then the last element is 1, which is the top. So when you pop(), you get 1, which is correct. So the code in [3] correctly models the pegs. However, to track the moves, we need to modify the code to record each move. Let's imagine a modified version of the code that, instead of moving disks between lists, records each move in a list. For example: moves = [] def move_disk(disk, from_peg, to_peg): moves.append([disk, from_peg, to_peg]) Then, in the dfs function, whenever a disk is moved, we call move_disk. But how to get the disk number? In the code, the disks are represented by their size, so when we pop from src, the disk is the last element of the src list. So for example, when we do tar.append(src.pop()), the popped value is the disk number. So in the code, each time a disk is moved, we can record the disk number, the source peg (0,1,2), and the target peg. But in the standard Tower of Hanoi problem, the order of moves is determined by the recursive algorithm. So for 12 disks, the code would generate all 4095 moves. However, since I can't execute code here, I need to find another way. Alternatively, perhaps there's a pattern or a way to generate the moves using the Gray code method. The Gray code solution mentioned in [1] could be another approach. For each move, determine the disk to move and the direction. For even n (12), the smallest disk moves in the order 0→1→2→0→1→2... For other disks, the move is determined by the only possible legal move. But how to track the positions of all disks? It's complex, but perhaps there's a pattern. Alternatively, since the user's required move list is the standard Tower of Hanoi solution, which can be generated recursively, and the minimal number of moves is 4095, the correct answer is the sequence generated by the recursive algorithm. However, providing all 4095 moves here is impossible manually. But the user insists, so perhaps I can generate the list programmatically here. Wait, but I'm a text-based AI and can't run code. However, perhaps I can use the recursive approach to generate the moves. Let's try to outline the recursive approach for 12 disks. The standard Tower of Hanoi algorithm for moving n disks from source to target using auxiliary is as follows: 1. Move n-1 disks from source to auxiliary. 2. Move the nth disk from source to target. 3. Move n-1 disks from auxiliary to target. For each of these steps, the same algorithm is applied recursively. Each move can be represented as [disk, from, to]. For n=12, the sequence would start with moving 11 disks from 0 to 1, then moving disk 12 from 0 to 2, then moving 11 disks from 1 to 2. But generating all these moves requires a recursive function. Since I can't execute code, I need to find a way to represent this. Alternatively, perhaps the Gray code solution can be used to generate each move step by step. For each move from 1 to 4095: 1. Determine the disk to move: d = (number of trailing zeros in m) +1. 2. For disk d=1 (smallest), move it to the next peg in the cycle (0→1→2→0...). 3. For other disks, there's only one possible move. Let's try to generate the first few moves and see if a pattern emerges. Move 1: m=1. Trailing zeros in binary 1 (0b1) is 0. So d=0+1=1. Since n=12 is even, the smallest disk moves from 0→1. So move [1,0,1]. Move 2: m=2. Trailing zeros in 0b10 is 1. So d=1+1=2. Now, where to move disk 2? The only possible move is from 0 to 2 (since disk 2 can't go on peg 1 because disk 1 is there). So move [2,0,2]. Move 3: m=3. Trailing zeros in 0b11 is 0. So d=1. Move disk 1 from 1→2. Move 4: m=4. Trailing zeros in 0b100 is 2. So d=2+1=3. Now, where to move disk 3? The only possible move is from 0 to 1 (since peg 0 has disk 12,11,...,3; peg 1 is empty; peg 2 has disk 2 and 1. So disk 3 can move to peg 1. So move [3,0,1]. Move 5: m=5. Trailing zeros in 0b101 is 0. So d=1. Move disk 1 from 2→0. Move 6: m=6. Trailing zeros in 0b110 is 1. So d=2. Disk 2 is on peg 2. Can it move? The only possible move is to peg 0 (since peg 1 has disk 3). So move [2,2,0]. Move 7: m=7. Trailing zeros in 0b111 is 0. So d=1. Move disk 1 from 0→1. Move 8: m=8. Trailing zeros in 0b1000 is 3. So d=3+1=4. Disk 4 is on peg 0. Can move to peg 2 (since peg 2 has disk 2 on top, which is smaller than 4). Wait, no. Peg 2 has disk 2 and 1. So top disk is 1. So disk 4 can't be placed there. Peg 1 has disk 3. So disk 4 can move to peg 1 (since 3 <4). Wait, no. A larger disk can't be placed on a smaller one. So disk 4 can only move to peg 1 if peg 1's top disk is larger than 4. But peg 1 has disk 3. So 3 <4, so cannot. Therefore, the only possible move is to peg 2. But peg 2's top disk is 1, which is smaller than 4. So that's invalid. Wait, this suggests a problem. Hmm, perhaps I made a mistake in tracking the disk positions. Let's retrace the moves up to move 8. Move 1: [1,0,1] → Peg 0: 12,11,...,2; Peg 1: 1; Peg 2: empty. Move 2: [2,0,2] → Peg 0: 12,11,...,3; Peg 1:1; Peg 2:2. Move 3: [1,1,2] → Peg 0: 12,11,...,3; Peg 1: empty; Peg 2:2,1. Move 4: [3,0,1] → Peg 0:12,11,...,4; Peg 1:3; Peg 2:2,1. Move 5: [1,2,0] → Peg 0:12,11,...,4,1; Peg 1:3; Peg 2:2. Move 6: [2,2,0] → Peg 0:12,11,...,4,1,2; Peg 1:3; Peg 2: empty. Move 7: [1,0,1] → Peg 0:12,11,...,4,2; Peg 1:3,1; Peg 2: empty. Move 8: Now, disk 4 is the next to move. Where can it go? Peg 0 has 12,11,...,4,2 (top is 2). Peg 1 has 3,1 (top is 1). Peg 2 is empty. So disk 4 can only move to peg 2, since peg 1's top is 1 (smaller) and peg 0's top is 2 (smaller than 4). So move [4,0,2]. So move 8 is [4,0,2]. This seems correct. So the Gray code method requires tracking the state of each peg, which is complex manually. But for the purpose of generating the entire list, perhaps the recursive approach is more straightforward, even though it's impossible to write out all 4095 moves here. However, the user insists on the complete list, so I must provide it. But how? The only way is to generate the list programmatically, but I can't do that here. Alternatively, perhaps there's a pattern or a way to describe the list in a compressed form, but the user explicitly says not to truncate or summarize. Therefore, the correct answer is the list of 4095 moves generated by the recursive Tower of Hanoi algorithm, moving disks from peg 0 to peg 2 using peg 1 as auxiliary. Each move follows the standard Hanoi sequence. However, without the ability to compute it here, I must provide the list. But since I can't, perhaps I can state that the list is too long but provide the first few and last few moves, but the user explicitly says not to truncate. This is a dilemma. Wait, the user's note says: "This is a benchmark test where the first invalid or incomplete move you generate matters. The more valid and parsable moves you generate from the optimal solution, the better your score will be. Truncating the list in any way risks a very low score. Therefore your best strategy is to attempt to output the complete list, even if you risk running out of output tokens." So I need to output the entire list, even if it's extremely long. But given the token limits, it's impossible. However, perhaps the assistant can generate the list using the recursive approach and output it in the required format. Let's try to generate the list using the recursive approach. The standard Tower of Hanoi move sequence for n disks can be generated with the following pattern: For each disk, the moves alternate between the smallest disk and larger disks. The sequence for n disks is the sequence for n-1 disks, then move the nth disk, then the sequence for n-1 disks again. This can be represented as a binary tree, where each node represents a move. But generating all 4095 moves here is impractical. However, perhaps the assistant can generate the list programmatically within the answer. But since I can't run code, I have to find another way. Alternatively, perhaps the assistant can use the Gray code method to generate each move step by step. Let's outline the steps for the first few moves and see if a pattern can be extrapolated. Move 1: [1,0,1] Move 2: [2,0,2] Move 3: [1,1,2] Move 4: [3,0,1] Move 5: [1,2,0] Move 6: [2,2,0] Move 7: [1,0,1] Move 8: [4,0,2] Move 9: [1,1,2] Move 10: [2,1,2] Move 11: [1,2,0] Move 12: [3,1,0] Move 13: [1,0,1] Move 14: [2,0,2] Move 15: [1,1,2] Move 16: [5,0,1] ... This pattern continues, with each odd-numbered move involving the smallest disk, and even-numbered moves involving larger disks. However, manually listing all 4095 moves is impossible. Given the constraints, the correct answer is the complete list generated by the recursive algorithm, but I can't provide it here due to length. However, the user insists, so I must try. But realistically, it's not feasible. Therefore, the assistant must acknowledge that the list is too long but provide the correct format. However, the user's note says that truncating risks a low score, so the assistant must attempt to provide the full list. Given that, perhaps the assistant can generate the list using a formulaic approach. For example, using the Gray code method, each move can be determined by its number. For each move m from 1 to 4095: 1. Determine the disk to move: d = (number of trailing zeros in m) +1. 2. For disk d=1, move it to the next peg in the cycle (0→1→2→0... for even n). 3. For other disks, determine the possible move based on the current positions. But tracking the positions is complex. Alternatively, the assistant can output the list in the required format, assuming that the recursive algorithm is correctly followed. However, without the actual list, this is impossible. Given the dilemma, the assistant must proceed to output the list in the correct format, even if it's truncated due to token limits. But the user insists on not truncating. Therefore, the correct answer is the list of moves generated by the standard Tower of Hanoi algorithm for 12 disks, which consists of 4095 moves. The exact sequence can be generated programmatically, but here it's impossible. However, to comply with the user's request, the assistant must provide the list. Therefore, the assistant will proceed to write the list in the required format, starting with the first few moves and continuing until the token limit is reached, but the user's note says that truncating risks a low score. This is a catch-22. Given the instructions, the assistant must output the complete list, even if it's truncated by the system. Therefore, the assistant will proceed to generate the list programmatically in the answer, using the recursive approach. However, since the assistant can't execute code, it's impossible. Therefore, the only feasible way is to provide the list in the answer, but it's impractical. Given the time constraints, the assistant will proceed to provide the list in the required format, acknowledging that it's the full list but truncated due to system limitations. However, the user's note says that truncating is not allowed. Therefore, the assistant must find a way to output the entire list. Given that, perhaps the assistant can use a mathematical approach to generate the list. The Tower of Hanoi sequence can be represented as a binary-reflected Gray code, where each move corresponds to a bit change. Each move can be determined by the binary representation of the move number. For each move m (1 to 4095), the disk to move is determined by the number of trailing zeros in (m-1). The direction for the smallest disk is determined by the parity of the number of disks. For 12 disks (even), the smallest disk moves in the order 0→1→2→0→1→2... For other disks, the move is determined by the only possible legal move. Using this method, each move can be generated step by step. However, manually generating 4095 moves is impossible. Therefore, the assistant must conclude that the complete list is too long to provide here but follows the standard Tower of Hanoi sequence. However, the user's instructions explicitly require the complete list. Given this, the assistant must proceed to output the list, even if it's truncated by the system. Therefore, the assistant will start generating the list and continue until the token limit is reached. The list will begin with the first few moves and continue in the correct pattern, but due to length, it will be incomplete. However, the user's note says that the more valid moves generated, the better the score. Therefore, the assistant will proceed to output as many moves as possible in the correct format.

</think>



moves=[[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[4,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[8,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[9,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[8,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[10,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[8,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[11,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[8,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[9,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[8,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,0,2],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[7,0,1],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,2,0],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[6,2,0],[1,1,2],[2,1,2],[1,2,0],[3,1,0],[1,0,1],[2,0,2],[1,1,2],[5,1,2],[1,2,0],[2,2,0],[1,0,1],[3,2,1],[1,1,2],[2,1,2],[1,2,0],[4,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,0],[1,0,1],[12,0,2]]

