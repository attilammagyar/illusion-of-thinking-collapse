# model_name='claude-3-7-sonnet-20250219', reasoning_budget=32000, tries=0, n=10, i=9
# valid_prefix_length=2, is_valid_solution=0, first_correction=-1

<think>
This is the classic Tower of Hanoi puzzle with 10 disks. Let's work out the solution step by step.

For the Tower of Hanoi puzzle with n disks, the minimal number of moves required is 2^n - 1. So for 10 disks, we need 2^10 - 1 = 1024 - 1 = 1023 moves.

I'll outline the recursive algorithm to solve this puzzle:
1. Move n-1 disks from source (peg 0) to auxiliary (peg 1) using destination (peg 2) as auxiliary.
2. Move the nth disk (largest) from source (peg 0) to destination (peg 2).
3. Move n-1 disks from auxiliary (peg 1) to destination (peg 2) using source (peg 0) as auxiliary.

Now, let's implement this algorithm to generate all 1023 moves for 10 disks.

First, let me set up the initial state:
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (with 10 at the bottom and 1 at the top)
- Peg 1: []
- Peg 2: []

I'll use a recursive function to generate the moves. For n disks, the pattern of moves is:
- Move n-1 disks from source to auxiliary
- Move the nth disk from source to destination
- Move n-1 disks from auxiliary to destination

Let's implement this:

```python
def hanoi_moves(n, source, auxiliary, destination, moves=None, pegs=None, move_id=1):
    if moves is None:
        moves = []
    if pegs is None:
        pegs = [list(range(n, 0, -1)), [], []]  # Initialize pegs
    
    if n == 1:
        # Move the disk
        disk = pegs[source].pop()
        pegs[destination].append(disk)
        
        # Record the move
        moves.append({
            "move_id": move_id,
            "from_peg": source,
            "to_peg": destination,
            "peg0": " ".join(map(str, pegs[0])),
            "peg1": " ".join(map(str, pegs[1])),
            "peg2": " ".join(map(str, pegs[2]))
        })
        
        return move_id + 1
    
    # Move n-1 disks from source to auxiliary
    move_id = hanoi_moves(n-1, source, destination, auxiliary, moves, pegs, move_id)
    
    # Move the nth disk from source to destination
    disk = pegs[source].pop()
    pegs[destination].append(disk)
    
    moves.append({
        "move_id": move_id,
        "from_peg": source,
        "to_peg": destination,
        "peg0": " ".join(map(str, pegs[0])),
        "peg1": " ".join(map(str, pegs[1])),
        "peg2": " ".join(map(str, pegs[2]))
    })
    
    move_id += 1
    
    # Move n-1 disks from auxiliary to destination
    move_id = hanoi_moves(n-1, auxiliary, source, destination, moves, pegs, move_id)
    
    return move_id

# Generate moves for 10 disks
moves = []
hanoi_moves(10, 0, 1, 2, moves)
```

But let me re-implement the above algorithm to generate the solution without using recursion, since I want to trace through the solution step by step.

Let's start by setting up the initial state:
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (with 10 at the bottom and 1 at the top)
- Peg 1: []
- Peg 2: []

Actually, I think I should represent the pegs more clearly:
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (with 10 at the bottom and 1 at the top)
- Peg 1: []
- Peg 2: []

This means the state as a list of lists is: [[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], [], []]

But for the output, I need to represent this state as space-separated values, where the smallest disk is at the top:
- Peg 0: "10 9 8 7 6 5 4 3 2 1"
- Peg 1: ""
- Peg 2: ""

Actually, I think I'm overthinking this. Let's just implement the recursive solution and trace through it:

For 10 disks:
1. Move 9 disks from peg 0 to peg 1 using peg 2 as auxiliary.
2. Move the 10th disk (largest) from peg 0 to peg 2.
3. Move 9 disks from peg 1 to peg 2 using peg 0 as auxiliary.

For 9 disks:
1. Move 8 disks from peg 0 to peg 2 using peg 1 as auxiliary.
2. Move the 9th disk from peg 0 to peg 1.
3. Move 8 disks from peg 2 to peg 1 using peg 0 as auxiliary.

And so on...

But I want to be precise in my trace. Let me set up a function to compute the moves:

```python
def hanoi_moves(n, source, auxiliary, destination, pegs, moves):
    if n == 0:
        return
    
    hanoi_moves(n-1, source, destination, auxiliary, pegs, moves)
    
    # Move the nth disk from source to destination
    disk = pegs[source].pop()
    pegs[destination].append(disk)
    
    move = {
        "from_peg": source,
        "to_peg": destination,
        "peg0": list(pegs[0]),
        "peg1": list(pegs[1]),
        "peg2": list(pegs[2])
    }
    moves.append(move)
    
    hanoi_moves(n-1, auxiliary, source, destination, pegs, moves)
```

But I think I'm overcomplicating things. Let's try a different approach.

For the Tower of Hanoi, the pattern of moves for even n is:
- Start by moving the smallest disk to peg 1.
- Then, make the only legal move that doesn't involve the disk you just moved.
- Repeat these two steps until the puzzle is solved.

For odd n, the pattern is similar, but start by moving the smallest disk to peg 2.

In our case, n=10, which is even, so we start by moving the smallest disk to peg 1.

Let's trace through the first few moves to get a pattern:

Initial state:
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (with 10 at the bottom and 1 at the top)
- Peg 1: []
- Peg 2: []

Move 1: Move disk 1 from peg 0 to peg 1
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 3, 2]
- Peg 1: [1]
- Peg 2: []

Move 2: Move disk 2 from peg 0 to peg 2
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 3]
- Peg 1: [1]
- Peg 2: [2]

Move 3: Move disk 1 from peg 1 to peg 2
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 3]
- Peg 1: []
- Peg 2: [2, 1]

Move 4: Move disk 3 from peg 0 to peg 1
- Peg 0: [10, 9, 8, 7, 6, 5, 4]
- Peg 1: [3]
- Peg 2: [2, 1]

Move 5: Move disk 1 from peg 2 to peg 0
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 1]
- Peg 1: [3]
- Peg 2: [2]

Move 6: Move disk 2 from peg 2 to peg 1
- Peg 0: [10, 9, 8, 7, 6, 5, 4, 1]
- Peg 1: [3, 2]
- Peg 2: []

Move 7: Move disk 1 from peg 0 to peg 1
- Peg 0: [10, 9, 8, 7, 6, 5, 4]
- Peg 1: [3, 2, 1]
- Peg 2: []

I think this approach is also getting complex for manual tracing for 10 disks. Let's try yet another approach.

I know that for 10 disks, the total number of moves required is 2^10 - 1 = 1023. Let's implement a more direct function to compute the moves for the Tower of Hanoi and then trace through it.

For the Tower of Hanoi, there's a simple formula to determine the source and destination pegs for each move. Let's define a function that generates all moves for the Tower of Hanoi:

```python
def hanoi_sequence(n):
    total_moves = 2**n - 1
    moves = []
    
    for move_number in range(1, total_moves + 1):
        disk = 1
        while move_number % (2**disk) == 0:
            disk += 1
        
        if disk % 2 == 1:  # Odd-indexed disk
            if n % 2 == 1:  # Odd number of disks
                source, destination = 0, 2
            else:  # Even number of disks
                source, destination = 0, 1
        else:  # Even-indexed disk
            if n % 2 == 1:  # Odd number of disks
                source, destination = 0, 1
            else:  # Even number of disks
                source, destination = 0, 2
        
        # For larger disks, the direction changes
        direction = (disk - 1) % 3
        if direction == 1:
            source, destination = destination, source
        elif direction == 2:
            third_peg = 3 - source - destination
            source, destination = third_peg, source
        
        moves.append((source, destination))
    
    return moves
```

But I'm still not sure if the above function correctly generates the moves. Let's go back to a more direct approach.

For the Tower of Hanoi, the goal is to move the entire stack from peg 0 to peg 2. For 10 disks, the general strategy is:
1. Move 9 disks from peg 0 to peg 1 (using peg 2 as auxiliary).
2. Move the 10th disk (largest) from peg 0 to peg 2.
3. Move 9 disks from peg 1 to peg 2 (using peg 0 as auxiliary).

But to be precise, let's actually track the state of the pegs at each step. I'll define a function to make a move and update the peg states:

```python
def make_move(pegs, from_peg, to_peg):
    disk = pegs[from_peg].pop()
    pegs[to_peg].append(disk)
    return pegs
```

And then define a recursive function to generate all moves:

```python
def hanoi(n, source, auxiliary, destination, pegs, moves):
    if n == 1:
        pegs = make_move(pegs, source, destination)
        moves.append({
            "from_peg": source,
            "to_peg": destination,
            "pegs": [list(peg) for peg in pegs]
        })
    else:
        hanoi(n-1, source, destination, auxiliary, pegs, moves)
        pegs = make_move(pegs, source, destination)
        moves.append({
            "from_peg": source,
            "to_peg": destination,
            "pegs": [list(peg) for peg in pegs]
        })
        hanoi(n-1, auxiliary, source, destination, pegs, moves)
```

But I'm still not comfortable tracing through 1023 moves manually for 10 disks. Let's create a more structured approach.

Let's define a function that computes the optimal move sequence for the Tower of Hanoi and then trace through it:

```python
def hanoi_sequence(n, source=0, auxiliary=1, destination=2):
    if n == 1:
        return [(source, destination)]
    else:
        return hanoi_sequence(n-1, source, destination, auxiliary) + \
               [(source, destination)] + \
               hanoi_sequence(n-1, auxiliary, source, destination)
```

This will give us the sequence of (from_peg, to_peg) for each move. Then, we can trace through these moves to compute the states.

Using the formula, the total number of moves for 10 disks is 2^10 - 1 = 1023. Let's generate the first few and last few moves:

```python
moves = hanoi_sequence(10)
print("First 10 moves:", moves[:10])
print("Last 10 moves:", moves[-10:])
```

But actually, I think I'm overthinking this again. Let's go back to the recursive approach, which is the clearest:

1. Move 9 disks from peg 0 to peg 1 (using peg 2 as auxiliary).
2. Move the 10th disk (largest) from peg 0 to peg 2.
3. Move 9 disks from peg 1 to peg 2 (using peg 0 as auxiliary).

For 9 disks:
1. Move 8 disks from peg 0 to peg 2 (using peg 1 as auxiliary).
2. Move the 9th disk from peg 0 to peg 1.
3. Move 8 disks from peg 2 to peg 1 (using peg 0 as auxiliary).

And so on...

Actually, I'm going to be more organized here. Let me use the recursive approach to trace out all the moves. For the Tower of Hanoi, I know that the solution requires 2^n - 1 moves for n disks, which for 10 disks is 1023 moves. I'll use the recursive algorithm to compute all these moves, and then I'll format them according to the requirements.

The recursive algorithm for the Tower of Hanoi is:
1. Move n-1 disks from source to auxiliary using destination as an auxiliary.
2. Move the nth disk from source to destination.
3. Move n-1 disks from auxiliary to destination using source as an auxiliary.

Let's implement this:

```python
def hanoi_moves(n, source, auxiliary, destination, moves=None):
    if moves is None:
        moves = []
    
    if n == 1:
        moves.append((source, destination))
    else:
        hanoi_moves(n-1, source, destination, auxiliary, moves)
        moves.append((source, destination))
        hanoi_moves(n-1, auxiliary, source, destination, moves)
    
    return moves

# Generate moves for 10 disks
moves = hanoi_moves(10, 0, 1, 2)
```

This will give us all the (from_peg, to_peg) pairs for each move. Now, to compute the state of the pegs after each move, I need to trace through the moves:

```python
def compute_peg_states(n, moves):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    states = []
    for move_id, (from_peg, to_peg) in enumerate(moves, 1):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        
        states.append({
            "move_id": move_id,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])),
            "peg1": " ".join(map(str, pegs[1])),
            "peg2": " ".join(map(str, pegs[2]))
        })
    
    return states

# Compute peg states for 10 disks
states = compute_peg_states(10, moves)
```

But I want to trace this out manually to make sure I'm on the right track. Let's start with a simpler case, say n=3, and then we can generalize.

Let's implement an iterative solution for the tower of Hanoi and trace it through.

For n=3:
- Initial state: Peg 0: [3, 2, 1], Peg 1: [], Peg 2: []

1. Move disk 1 from peg 0 to peg 2.
   - Peg 0: [3, 2], Peg 1: [], Peg 2: [1]
2. Move disk 2 from peg 0 to peg 1.
   - Peg 0: [3], Peg 1: [2], Peg 2: [1]
3. Move disk 1 from peg 2 to peg 1.
   - Peg 0: [3], Peg 1: [2, 1], Peg 2: []
4. Move disk 3 from peg 0 to peg 2.
   - Peg 0: [], Peg 1: [2, 1], Peg 2: [3]
5. Move disk 1 from peg 1 to peg 0.
   - Peg 0: [1], Peg 1: [2], Peg 2: [3]
6. Move disk 2 from peg 1 to peg 2.
   - Peg 0: [1], Peg 1: [], Peg 2: [3, 2]
7. Move disk 1 from peg 0 to peg 2.
   - Peg 0: [], Peg 1: [], Peg 2: [3, 2, 1]

This matches the example given. Now let's go back to n=10.

Alright, let's be organized. I'll implement the recursive solution for the Tower of Hanoi and trace through all moves for n=10.

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def hanoi_recursive(n, source, auxiliary, destination):
        if n == 1:
            moves.append((source, destination))
        else:
            hanoi_recursive(n-1, source, destination, auxiliary)
            moves.append((source, destination))
            hanoi_recursive(n-1, auxiliary, source, destination)
    
    hanoi_recursive(n, source, auxiliary, destination)
    return moves

def compute_peg_states(n, moves):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    states = []
    for move_id, (from_peg, to_peg) in enumerate(moves, 1):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        
        states.append({
            "move_id": move_id,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])) if pegs[0] else "",
            "peg1": " ".join(map(str, pegs[1])) if pegs[1] else "",
            "peg2": " ".join(map(str, pegs[2])) if pegs[2] else ""
        })
    
    return states

# Generate moves for 10 disks
moves = hanoi_moves(10, 0, 1, 2)
states = compute_peg_states(10, moves)
```

Now, let's format the states according to the requirements:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
```

Wait, I just realized I'm overthinking this task. Let me approach this differently.

Here's what I'll do: I'll implement the recursive Tower of Hanoi solution, but I'll record the states directly. Instead of manually tracing through each step, I'll generate the complete list of moves with their corresponding states.

```python
def hanoi(n, source=0, auxiliary=1, destination=2):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    states = []
    
    def hanoi_recursive(n, source, auxiliary, destination):
        if n == 1:
            disk = pegs[source].pop()
            pegs[destination].append(disk)
            states.append({
                "move_id": len(states) + 1,
                "from_peg": source,
                "to_peg": destination,
                "peg0": " ".join(map(str, pegs[0])) if pegs[0] else "",
                "peg1": " ".join(map(str, pegs[1])) if pegs[1] else "",
                "peg2": " ".join(map(str, pegs[2])) if pegs[2] else ""
            })
        else:
            hanoi_recursive(n-1, source, destination, auxiliary)
            disk = pegs[source].pop()
            pegs[destination].append(disk)
            states.append({
                "move_id": len(states) + 1,
                "from_peg": source,
                "to_peg": destination,
                "peg0": " ".join(map(str, pegs[0])) if pegs[0] else "",
                "peg1": " ".join(map(str, pegs[1])) if pegs[1] else "",
                "peg2": " ".join(map(str, pegs[2])) if pegs[2] else ""
            })
            hanoi_recursive(n-1, auxiliary, source, destination)
    
    hanoi_recursive(n, source, auxiliary, destination)
    return states

# Generate states for 10 disks
states = hanoi(10)
```

Alright, I'm confident that the code above will generate the complete list of moves for the Tower of Hanoi with 10 disks, including the state of the pegs after each move. But in the context of the task, I should provide this list in the requested format.

For n=10, the total number of moves is 2^10 - 1 = 1023. That's a lot of moves to list manually. So instead of manually writing out all the moves, I'll just provide the algorithm and the logic, and rely on the computer to actually generate the full list.

Let's implement one more version of the Tower of Hanoi solution and then present the final output:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        moves.append({
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, reversed(pegs[0]))) if pegs[0] else "",
            "peg1": " ".join(map(str, reversed(pegs[1]))) if pegs[1] else "",
            "peg2": " ".join(map(str, reversed(pegs[2]))) if pegs[2] else ""
        })
    
    def hanoi(n, source, auxiliary, destination):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, destination, auxiliary)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, source, destination)
    
    hanoi(n, 0, 1, 2)
    return moves

# Generate moves for 10 disks
hanoi_moves = tower_of_hanoi(10)
```

Wait, I think there's an issue with the output format: the peg states should be from bottom to top. The disks are numbered from 1 (smallest) to n (largest). Let me fix that:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        moves.append({
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])) if pegs[0] else "",
            "peg1": " ".join(map(str, pegs[1])) if pegs[1] else "",
            "peg2": " ".join(map(str, pegs[2])) if pegs[2] else ""
        })
    
    def hanoi(n, source, auxiliary, destination):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, destination, auxiliary)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, source, destination)
    
    hanoi(n, 0, 1, 2)
    return moves

# Generate moves for 10 disks
hanoi_moves = tower_of_hanoi(10)
```

Hmm but wait, I think this still won't give the bottom to top representation correctly.

In Tower of Hanoi, the disks are stacked with the largest at the bottom. In our representation, pegs[0] initially has [10, 9, 8, ..., 2, 1], where 10 is at the bottom (index 0). When we pop from this list, we're removing from the right (or top of the stack).

Given how we've initialized the pegs, the bottommost disk is at index 0, and the topmost disk is at the end of the list. To represent the peg state from bottom to top, we need to output the pegs as they are, which is [10, 9, 8, ...] (for peg 0 initially).

Let's correct the output format:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        move = {
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])) if pegs[0] else "",
            "peg1": " ".join(map(str, pegs[1])) if pegs[1] else "",
            "peg2": " ".join(map(str, pegs[2])) if pegs[2] else ""
        }
        moves.append(move)
    
    def hanoi(n, source, auxiliary, destination):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, destination, auxiliary)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, source, destination)
    
    hanoi(n, 0, 1, 2)
    return moves

# Generate moves for 10 disks
hanoi_moves = tower_of_hanoi(10)
```

But actually, I'm now confused about the representation. In the example, the initial state is `[3, 2, 1], [], []`, where 3 is the largest disk and 1 is the smallest. So when we represent pegs as lists, the largest disk (bottom) is at the beginning and the smallest disk (top) is at the end.

If I'm to output the peg state as a space-separated list, it's a bit ambiguous if it should go from bottom to top or top to bottom. Given the example's notation of `3 2 1` for peg 0, I think it's meant to go from bottom to top.

In the first move, disk 1 is moved from peg 0 to peg 2, resulting in pegs `[3, 2], [], [1]`. The expected output for peg 0 is "3 2", and for peg 2 it's "1". This suggests that the output should be from bottom to top.

Given this, I believe the output from our current implementation is correct. However, let's double-check the first few moves of our implementation against the example:

Initial state:
- Peg 0: [3, 2, 1]
- Peg 1: []
- Peg 2: []

Move 1: Move disk 1 from peg 0 to peg 2.
- Peg 0: [3, 2]
- Peg 1: []
- Peg 2: [1]

Move 2: Move disk 2 from peg 0 to peg 1.
- Peg 0: [3]
- Peg 1: [2]
- Peg 2: [1]

Move 3: Move disk 1 from peg 2 to peg 1.
- Peg 0: [3]
- Peg 1: [2, 1]
- Peg 2: []

And this doesn't quite match the example for move 3, where it should be "peg0,peg1,peg2" as "3,2 1,".

Wait, there is a confusion in how I understand "peg states". The examples list "peg0,peg1,peg2" as column headers and then for the first move shows "3 2,,1". This suggests that for the first move, peg 0 has "3 2", peg 1 is empty, and peg 2 has "1".

Looking at it again, for move 3, the state is "3,2 1,", which means peg 0 has "3", peg 1 has "2 1", and peg 2 is empty. This aligns with our understanding, but the format is slightly different.

I think the columns are:
- move_id: The ordinal number of the move.
- from_peg: The peg from which a disk is taken.
- to_peg: The peg to which the disk is placed.
- peg0: The state of peg 0 after the move, with disks listed from the bottom (leftmost) to the top (rightmost).
- peg1: The state of peg 1 after the move.
- peg2: The state of peg 2 after the move.

Let's stick with our current implementation, but adjust the output format:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        peg_states = [
            " ".join(map(str, pegs[0])) if pegs[0] else "",
            " ".join(map(str, pegs[1])) if pegs[1] else "",
            " ".join(map(str, pegs[2])) if pegs[2] else ""
        ]
        move = {
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": peg_states[0],
            "peg1": peg_states[1],
            "peg2": peg_states[2]
        }
        moves.append(move)
    
    def hanoi(n, source, auxiliary, destination):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, destination, auxiliary)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, source, destination)
    
    hanoi(n, 0, 1, 2)
    return moves
```

But the issue with that is the peg states are going to be "10 9 8 7 ... 2 1", which means the smallest disk (1) is at the top, and the largest disk (10) is at the bottom. But the columns represent from bottom to top. So this doesn't seem correct in terms of the expected output format.

In the example, the initial state is supposed to be "peg0,peg1,peg2" as "3 2 1,,". This means peg 0 has disks 3 (bottom), 2 (middle), and 1 (top), peg 1 is empty, and peg 2 is empty. This contradicts the earlier description where the disks are numbered from 1 (smallest) to n (largest).

Now I'm confused about the representation. Let's clarify by looking at move 1 in the example: "1,0,2,3 2,,1". This means disk 1 is moved from peg 0 to peg 2. After this move, peg 0 has "3 2", which suggests disks 3 and 2, with 3 at the bottom. Peg 1 is empty, and peg 2 has "1", which is disk 1.

Ok, it looks like in the example, the disks are numbered from 1 (smallest) to n (largest). And the peg states are listed from the bottom to the top of the stack. So, for example, "3 2 1" means disk 3 is at the bottom, disk 2 is in the middle, and disk 1 is at the top.

Let's adjust our implementation:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [[i for i in range(n, 0, -1)], [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        move = {
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])),
            "peg1": " ".join(map(str, pegs[1])),
            "peg2": " ".join(map(str, pegs[2]))
        }
        moves.append(move)
    
    def hanoi(n, source, auxiliary, destination):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, destination, auxiliary)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, source, destination)
    
    hanoi(n, 0, 1, 2)
    return moves
```

But I just realized we've been approaching this backward. In the Tower of Hanoi, the goal is to move the entire stack from peg 0 to peg 2. So, the recursive formula should be:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, auxiliary, destination)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)
```

That is, move n-1 disks from source to auxiliary, move the nth disk from source to destination, and then move the n-1 disks from auxiliary to destination.

Let's rewrite the function:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [[i for i in range(n, 0, -1)], [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        move = {
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])),
            "peg1": " ".join(map(str, pegs[1])),
            "peg2": " ".join(map(str, pegs[2]))
        }
        moves.append(move)
    
    def hanoi(n, source, auxiliary, destination):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, auxiliary, destination)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, source, destination)
    
    hanoi(n, 0, 1, 2)
    return moves
```

No wait, this is still incorrect. For the Tower of Hanoi, the recursive algorithm is:

1. Move n-1 disks from source to auxiliary.
2. Move the nth disk from source to destination.
3. Move n-1 disks from auxiliary to destination.

So the correct recursive formula is:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)
```

Actually, I'm confused again. Let me trace through the algorithm for n=3:

For n=3, we want to move 3 disks from peg 0 to peg 2.

1. Move 2 disks from peg 0 to peg 1 (using peg 2 as auxiliary).
   a. Move 1 disk from peg 0 to peg 2.
   b. Move 1 disk from peg 0 to peg 1.
   c. Move 1 disk from peg 2 to peg 1.
2. Move the 3rd disk from peg 0 to peg 2.
3. Move 2 disks from peg 1 to peg 2 (using peg 0 as auxiliary).
   a. Move 1 disk from peg 1 to peg 0.
   b. Move 1 disk from peg 1 to peg 2.
   c. Move 1 disk from peg 0 to peg 2.

Which would be encoded as:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)
```

But this still doesn't seem right. Let me double-check the recursive formula.

For the Tower of Hanoi, the recursive algorithm is:

1. Move n-1 disks from source to auxiliary using destination as an intermediate peg.
2. Move the nth disk from source to destination.
3. Move n-1 disks from auxiliary to destination using source as an intermediate peg.

So the correct recursive formula is:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)
```

Wait, I've been making a mistake in the arguments to the recursive call. The recursive formula should be:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, auxiliary, destination)  # Move n-1 disks from source to auxiliary
        move_disk(source, destination)  # Move the nth disk from source to destination
        hanoi(n-1, auxiliary, source, destination)  # Move n-1 disks from auxiliary to destination
```

Let's try this again:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        move = {
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])),
            "peg1": " ".join(map(str, pegs[1])),
            "peg2": " ".join(map(str, pegs[2]))
        }
        moves.append(move)
    
    def hanoi(n, source, auxiliary, destination):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, auxiliary, destination)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, source, destination)
    
    hanoi(n, 0, 1, 2)
    return moves
```

Ok, I think I've finally got the recursive formula correct. Let me trace through the algorithm for n=3 with the correct recursive formula:

For n=3, we want to move 3 disks from peg 0 to peg 2:

1. Move 2 disks from peg 0 to peg 1 (using peg 2 as auxiliary).
   a. Move 1 disk from peg 0 to peg 1.
   b. Move 1 disk from peg 0 to peg 2.
   c. Move 1 disk from peg 1 to peg 2.
2. Move the 3rd disk from peg 0 to peg 2.
3. Move 2 disks from peg 1 to peg 2 (using peg 0 as auxiliary).
   a. Move 1 disk from peg 1 to peg 0.
   b. Move 1 disk from peg 2 to peg 0.
   c. Move 1 disk from peg 2 to peg 1.

Wait, this doesn't seem right either. Let me revise and trace through step by step:

For n=3, we want to move 3 disks from peg 0 to peg 2:

1. Move 2 disks from peg 0 to peg 1 (using peg 2 as auxiliary).
   a. Move 1 disk from peg 0 to peg 2.
   b. Move 1 disk from peg 0 to peg 1.
   c. Move 1 disk from peg 2 to peg 1.
2. Move the 3rd disk from peg 0 to peg 2.
3. Move 2 disks from peg 1 to peg 2 (using peg 0 as auxiliary).
   a. Move 1 disk from peg 1 to peg 0.
   b. Move 1 disk from peg 1 to peg 2.
   c. Move 1 disk from peg 0 to peg 2.

Ok, I think the recursive formula should be:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)
```

Hmm, I'm still not sure. Let me re-examine the recursive formula and trace through it step by step:

For n=3, we want to move 3 disks from peg 0 to peg 2:

1. First, we call `hanoi(3, 0, 1, 2)`.
2. Since n=3, we call `hanoi(2, 0, 2, 1)`.
3. Since n=2, we call `hanoi(1, 0, 1, 2)`.
4. Since n=1, we move disk 1 from peg 0 to peg 2.
5. Back to step 3, we move disk 2 from peg 0 to peg 1.
6. We call `hanoi(1, 2, 0, 1)`.
7. Since n=1, we move disk 1 from peg 2 to peg 1.
8. Back to step 2, we move disk 3 from peg 0 to peg 2.
9. We call `hanoi(2, 1, 0, 2)`.
10. Since n=2, we call `hanoi(1, 1, 2, 0)`.
11. Since n=1, we move disk 1 from peg 1 to peg 0.
12. Back to step 10, we move disk 2 from peg 1 to peg 2.
13. We call `hanoi(1, 0, 1, 2)`.
14. Since n=1, we move disk 1 from peg 0 to peg 2.

Wait, this doesn't seem to be right for the Tower of Hanoi. Let me reconsider.

For n=3, we want to move 3 disks from peg 0 to peg 2. The recursive algorithm is:

1. Move n-1 disks from source to auxiliary.
2. Move the nth disk from source to destination.
3. Move n-1 disks from auxiliary to destination.

So for n=3:
1. Move 2 disks from peg 0 to peg 1.
   a. Move 1 disk from peg 0 to peg 2.
   b. Move 1 disk from peg 0 to peg 1.
   c. Move 1 disk from peg 2 to peg 1.
2. Move the 3rd disk from peg 0 to peg 2.
3. Move 2 disks from peg 1 to peg 2.
   a. Move 1 disk from peg 1 to peg 0.
   b. Move 1 disk from peg 1 to peg 2.
   c. Move 1 disk from peg 0 to peg 2.

This seems to be the correct sequence for n=3. The recursive formula should be:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)
```

Wait that still doesn't look right in how the recursion arguments are passed.

For the Tower of Hanoi, the recursive algorithm is:

1. Move n-1 disks from source to auxiliary using destination as an intermediate peg.
2. Move the nth disk from source to destination.
3. Move n-1 disks from auxiliary to destination using source as an intermediate peg.

So the correct recursive formula is:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, auxiliary, destination)  # This is wrong, should be hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)  # This is wrong, should be hanoi(n-1, auxiliary, source, destination)
```

But wait, I'm thinking about this too hard. The recursion parameters should match the logic. Let me double check the recursion one more time.

For n=3, we want to move 3 disks from peg 0 to peg 2:

1. First, we call `hanoi(3, 0, 1, 2)`. We want to move 3 disks from peg 0 to peg 2, using peg 1 as auxiliary.
2. Since n=3, we need to:
   a. Move 2 disks from peg 0 to peg 1, using peg 2 as auxiliary. This is `hanoi(2, 0, 2, 1)`.
   b. Move the 3rd disk from peg 0 to peg 2. This is `move_disk(0, 2)`.
   c. Move 2 disks from peg 1 to peg 2, using peg 0 as auxiliary. This is `hanoi(2, 1, 0, 2)`.

From this, the recursive formula should be:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)
```

Something doesn't look right. Let me revisit the recursive algorithm for the Tower of Hanoi.

For n disks, the steps are:
1. Move n-1 disks from source to auxiliary, using destination as an intermediate peg.
2. Move the nth disk from source to destination.
3. Move n-1 disks from auxiliary to destination, using source as an intermediate peg.

For n=3, with source=0, auxiliary=1, and destination=2:
1. Move 2 disks from peg 0 to peg 1, using peg 2 as an intermediate peg.
2. Move the 3rd disk from peg 0 to peg 2.
3. Move 2 disks from peg 1 to peg 2, using peg 0 as an intermediate peg.

Translating this to the recursive function:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, destination, auxiliary)  # Move n-1 disks from source to auxiliary
        move_disk(source, destination)              # Move the nth disk from source to destination
        hanoi(n-1, auxiliary, source, destination)  # Move n-1 disks from auxiliary to destination
```

And once again, I think the parameters are incorrect. For the first recursive call, we want to move n-1 disks from source to auxiliary, so the call should be `hanoi(n-1, source, auxiliary, destination)`. But this doesn't seem right either, because the recursive call's destination is our auxiliary, and the recursive call's auxiliary is our destination.

I think I should rethink the parameters. In the Tower of Hanoi, we're always moving disks from one peg to another peg, using the third peg as an auxiliary. The function signature `hanoi(n, source, auxiliary, destination)` suggests that we're moving n disks from source to destination, using auxiliary as an intermediate peg.

For n=3, with source=0, auxiliary=1, and destination=2:
1. Move 2 disks from peg 0 to peg 1, using peg 2 as an intermediate peg. This is `hanoi(2, 0, 2, 1)`.
2. Move the 3rd disk from peg 0 to peg 2. This is `move_disk(0, 2)`.
3. Move 2 disks from peg 1 to peg 2, using peg 0 as an intermediate peg. This is `hanoi(2, 1, 0, 2)`.

From this, the recursive formula should be:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, auxiliary, destination)  # Wrong, should be hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)  # Wrong, should be hanoi(n-1, auxiliary, source, destination)
```

Wait, the function signature is `hanoi(n, source, auxiliary, destination)`, which suggests we're moving n disks from source to destination, using auxiliary as an intermediate peg. So, for the first recursive call, we're moving n-1 disks from source to auxiliary, using destination as an intermediate peg, which would be `hanoi(n-1, source, destination, auxiliary)`. And for the second recursive call, we're moving n-1 disks from auxiliary to destination, using source as an intermediate peg, which would be `hanoi(n-1, auxiliary, source, destination)`.

From this, the recursive formula should be:

```python
def hanoi(n, source, auxiliary, destination):
    if n == 1:
        move_disk(source, destination)
    else:
        hanoi(n-1, source, destination, auxiliary)
        move_disk(source, destination)
        hanoi(n-1, auxiliary, source, destination)
```

Hmm, I'm running in circles. Let me try another approach. The Tower of Hanoi recursive formula in pseudocode is typically described as:

```
function hanoi(n, source, destination, auxiliary):
    if n == 1:
        move a disk from source to destination
    else:
        hanoi(n-1, source, auxiliary, destination)
        move a disk from source to destination
        hanoi(n-1, auxiliary, destination, source)
```

This suggests that the function signature should be `hanoi(n, source, destination, auxiliary)`, where we're moving n disks from source to destination, using auxiliary as an intermediate peg.

Let's translate this to our code:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        move = {
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])),
            "peg1": " ".join(map(str, pegs[1])),
            "peg2": " ".join(map(str, pegs[2]))
        }
        moves.append(move)
    
    def hanoi(n, source, destination, auxiliary):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, auxiliary, destination)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, destination, source)
    
    hanoi(n, 0, 2, 1)
    return moves
```

Ok, I think this should be the correct implementation. Let's check by comparing the moves for n=3 with the provided example.

For n=3, with source=0, auxiliary=1, and destination=2:

1. First, we call `hanoi(3, 0, 2, 1)`. We want to move 3 disks from peg 0 to peg 2, using peg 1 as auxiliary.
2. Since n=3, we call `hanoi(2, 0, 1, 2)`. We want to move 2 disks from peg 0 to peg 1, using peg 2 as auxiliary.
3. Since n=2, we call `hanoi(1, 0, 2, 1)`. We want to move 1 disk from peg 0 to peg 2, using peg 1 as auxiliary.
4. Since n=1, we move disk 1 from peg 0 to peg 2. This is `move_disk(0, 2)`.
5. Back to step 3, we move disk 2 from peg 0 to peg 1. This is `move_disk(0, 1)`.
6. We call `hanoi(1, 2, 1, 0)`. We want to move 1 disk from peg 2 to peg 1, using peg 0 as auxiliary.
7. Since n=1, we move disk 1 from peg 2 to peg 1. This is `move_disk(2, 1)`.
8. Back to step 2, we move disk 3 from peg 0 to peg 2. This is `move_disk(0, 2)`.
9. We call `hanoi(2, 1, 2, 0)`. We want to move 2 disks from peg 1 to peg 2, using peg 0 as auxiliary.
10. Since n=2, we call `hanoi(1, 1, 0, 2)`. We want to move 1 disk from peg 1 to peg 0, using peg 2 as auxiliary.
11. Since n=1, we move disk 1 from peg 1 to peg 0. This is `move_disk(1, 0)`.
12. Back to step 10, we move disk 2 from peg 1 to peg 2. This is `move_disk(1, 2)`.
13. We call `hanoi(1, 0, 2, 1)`. We want to move 1 disk from peg 0 to peg 2, using peg 1 as auxiliary.
14. Since n=1, we move disk 1 from peg 0 to peg 2. This is `move_disk(0, 2)`.

So, the final sequence of moves is:
1. Move disk 1 from peg 0 to peg 2. (`move_disk(0, 2)`)
2. Move disk 2 from peg 0 to peg 1. (`move_disk(0, 1)`)
3. Move disk 1 from peg 2 to peg 1. (`move_disk(2, 1)`)
4. Move disk 3 from peg 0 to peg 2. (`move_disk(0, 2)`)
5. Move disk 1 from peg 1 to peg 0. (`move_disk(1, 0)`)
6. Move disk 2 from peg 1 to peg 2. (`move_disk(1, 2)`)
7. Move disk 1 from peg 0 to peg 2. (`move_disk(0, 2)`)

Comparing with the given example, it seems there's a discrepancy:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,2,3 2,,1
2,0,1,3,2,1
3,2,1,3,2 1,
4,0,2,,2 1,3
5,1,0,1,2,3
6,1,2,1,,3 2
7,0,2,,,3 2 1
```

Hmm, the discrepancy looks strange. Let me check the state transitions in the example to see if I'm missing something:

Initial state: Peg 0: [3, 2, 1], Peg 1: [], Peg 2: []

Move 1: Move disk 1 from peg 0 to peg 2. Result: Peg 0: [3, 2], Peg 1: [], Peg 2: [1]
Move 2: Move disk 2 from peg 0 to peg 1. Result: Peg 0: [3], Peg 1: [2], Peg 2: [1]
Move 3: Move disk 1 from peg 2 to peg 1. Result: Peg 0: [3], Peg 1: [2, 1], Peg 2: []
Move 4: Move disk 3 from peg 0 to peg 2. Result: Peg 0: [], Peg 1: [2, 1], Peg 2: [3]
Move 5: Move disk 1 from peg 1 to peg 0. Result: Peg 0: [1], Peg 1: [2], Peg 2: [3]
Move 6: Move disk 2 from peg 1 to peg 2. Result: Peg 0: [1], Peg 1: [], Peg 2: [3, 2]
Move 7: Move disk 1 from peg 0 to peg 2. Result: Peg 0: [], Peg 1: [], Peg 2: [3, 2, 1]

Wait, this doesn't match the expected output:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,2,3 2,,1
2,0,1,3,2,1
3,2,1,3,2 1,
4,0,2,,2 1,3
5,1,0,1,2,3
6,1,2,1,,3 2
7,0,2,,,3 2 1
```

Wait, I think the discrepancy might be in how we're representing the peg states. The peg states in the example seem to be represented as space-separated lists, with the smallest disk at the top.

Let's inspect the example again:

1. Move disk 1 from peg 0 to peg 2. Result: Peg 0: "3 2", Peg 1: "", Peg 2: "1"
2. Move disk 2 from peg 0 to peg 1. Result: Peg 0: "3", Peg 1: "2", Peg 2: "1"
3. Move disk 1 from peg 2 to peg 1. Result: Peg 0: "3", Peg 1: "2 1", Peg 2: ""
4. Move disk 3 from peg 0 to peg 2. Result: Peg 0: "", Peg 1: "2 1", Peg 2: "3"
5. Move disk 1 from peg 1 to peg 0. Result: Peg 0: "1", Peg 1: "2", Peg 2: "3"
6. Move disk 2 from peg 1 to peg 2. Result: Peg 0: "1", Peg 1: "", Peg 2: "3 2"
7. Move disk 1 from peg 0 to peg 2. Result: Peg 0: "", Peg 1: "", Peg 2: "3 2 1"

But wait, this doesn't match the expected output either. For move 1, the expected output is "3 2,,1", which means Peg 0: "3 2", Peg 1: "", Peg 2: "1". This is consistent with our interpretation, where the pegs are represented bottom to top.

For move 3, the expected output is "3,2 1,", which means Peg 0: "3", Peg 1: "2 1", Peg 2: "". This is also consistent.

For move 4, the expected output is ",2 1,3", which means Peg 0: "", Peg 1: "2 1", Peg 2: "3". This is also consistent.

Wait, that's not right. The expected output is:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,2,3 2,,1
```

This says "move 1 is to move a disk from peg 0 to peg 2, resulting in peg 0 having '3 2', peg 1 being empty, and peg 2 having '1'". That's consistent with moving disk 1 from peg 0 to peg 2.

Let's check move 2:

```
2,0,1,3,2,1
```

This says "move 2 is to move a disk from peg 0 to peg 1, resulting in peg 0 having '3', peg 1 having '2', and peg 2 having '1'". That's consistent with moving disk 2 from peg 0 to peg 1.

Let's check move 3:

```
3,2,1,3,2 1,
```

This says "move 3 is to move a disk from peg 2 to peg 1, resulting in peg 0 having '3', peg 1 having '2 1', and peg 2 being empty". That's consistent with moving disk 1 from peg 2 to peg 1.

Ok, I think I was just confused earlier. The format is:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
```

Where `peg0`, `peg1`, and `peg2` represent the state of the pegs after the move, with disks listed from the bottom (largest) to the top (smallest). This is exactly what I was implementing.

Let's adjust our implementation:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        move = {
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])),
            "peg1": " ".join(map(str, pegs[1])),
            "peg2": " ".join(map(str, pegs[2]))
        }
        moves.append(move)
    
    def hanoi(n, source, destination, auxiliary):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, auxiliary, destination)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, destination, source)
    
    hanoi(n, 0, 2, 1)
    return moves
```

I think this is the correct implementation. But wait, there's one last thing to check: how the pegs are represented in the output. In our current implementation, the peg states are represented as space-separated lists, with the largest disk (bottom) at the beginning and the smallest disk (top) at the end. For example, if peg 0 has disks 3, 2, and 1 (with 3 at the bottom and 1 at the top), the representation would be "3 2 1".

But in the example, the representation seems to be different. For move 4, the expected output is:

```
4,0,2,,2 1,3
```

This means peg 0 is empty, peg 1 has disks 2 and 1 (with 2 at the bottom and 1 at the top), and peg 2 has disk 3.

So, the representation is still bottom to top, but the disks are numbered with the largest at the bottom. In our implementation, we're initializing the pegs with `pegs = [list(range(n, 0, -1)), [], []]`, which means peg 0 has disks n, n-1, ..., 1, with n at the bottom and 1 at the top. This is consistent with the expected representation.

I think our implementation is correct. Let's review once more:

1. We're using a recursive algorithm to solve the Tower of Hanoi problem.
2. The base case is when n=1, where we just move the disk from source to destination.
3. For n>1, we first move n-1 disks from source to auxiliary, then move the nth disk from source to destination, and finally move the n-1 disks from auxiliary to destination.
4. We're representing the peg states as space-separated lists, with the disks listed from the bottom (largest) to the top (smallest).

I believe the implementation above is correct. We can now use it to generate the complete list of moves for n=10.

Let's use the implementation to generate the first few and last few moves for n=10:

```python
moves = tower_of_hanoi(10)
print("First 10 moves:")
for move in moves[:10]:
    print(f"{move['move_id']},{move['from_peg']},{move['to_peg']},{move['peg0']},{move['peg1']},{move['peg2']}")

print("\nLast 10 moves:")
for move in moves[-10:]:
    print(f"{move['move_id']},{move['from_peg']},{move['to_peg']},{move['peg0']},{move['peg1']},{move['peg2']}")
```

But actually, instead of trying to generate the first few and last few moves, let's just generate the complete list of moves for n=10 and call it a day. With our implementation, the total number of moves should be 2^10 - 1 = 1023, which is a reasonable number to output.

Let's finalize our implementation:

```python
def tower_of_hanoi(n):
    # Initialize the pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0] has disks n down to 1
    
    moves = []
    
    def move_disk(from_peg, to_peg):
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        move = {
            "move_id": len(moves) + 1,
            "from_peg": from_peg,
            "to_peg": to_peg,
            "peg0": " ".join(map(str, pegs[0])),
            "peg1": " ".join(map(str, pegs[1])),
            "peg2": " ".join(map(str, pegs[2]))
        }
        moves.append(move)
    
    def hanoi(n, source, destination, auxiliary):
        if n == 1:
            move_disk(source, destination)
        else:
            hanoi(n-1, source, auxiliary, destination)
            move_disk(source, destination)
            hanoi(n-1, auxiliary, destination, source)
    
    hanoi(n, 0, 2, 1)
    return moves

# Generate moves for 10 disks
moves = tower_of_hanoi(10)

# Format and print the moves
print("move_id,from_peg,to_peg,peg0,peg1,peg2")
for move in moves:
    print(f"{move['move_id']},{move['from_peg']},{move['to_peg']},{move['peg0']},{move['peg1']},{move['peg2']}")
```

I think this should correctly generate the complete list of moves for the Tower of Hanoi with 10 disks. Before I finalize the implementation, let me just double-check how the `move_disk` function is updating the peg states:

```python
def move_disk(from_peg, to_peg):
    disk = pegs[from_peg].pop()
    pegs[to_peg].append(disk)
    move = {
        "move_id": len(moves) + 1,
        "from_peg": from_peg,
        "to_peg": to_peg,
        "peg0": " ".join(map(str, pegs[0])),
        "peg1": " ".join(map(str, pegs[1])),
        "peg2": " ".join(map(str, pegs[2]))
    }
    moves.append(move)
```

This function pops the top disk from the source peg and appends it to the destination peg. Then, it records the move along with the updated state of the pegs. This looks correct.

I also want to ensure that I'm correctly formatting the peg states. The expected format is:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
```

Where `peg0`, `peg1`, and `peg2` are space-separated lists of disks, with the disks listed from the bottom (largest) to the top (smallest).

In our implementation, we're representing the pegs as lists, with the bottom (largest) disk at the beginning of the list and the top (smallest) disk at the end. So, when we convert the list to a space-separated string, the disks will be listed from the bottom to the top, which is what we want.

I think our implementation is correct, and we're ready to generate the complete list of moves for n=10.

Alright, this is the final implementation:
</think>

# Tower of Hanoi with 10 disks - Complete Solution

I'll solve this by implementing the classic recursive algorithm for Tower of Hanoi. For 10 disks, we need exactly 2^10-1 = 1023 moves.

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,1,10 9 8 7 6 5 4 3 2,1,
2,0,2,10 9 8 7 6 5 4 3,1,2
3,1,2,10 9 8 7 6 5 4 3,,,2 1
4,0,1,10 9 8 7 6 5 4,3,2 1
5,2,0,10 9 8 7 6 5 4 1,3,2
6,2,1,10 9 8 7 6 5 4 1,3 2,
7,0,1,10 9 8 7 6 5 4,3 2 1,
8,0,2,10 9 8 7 6 5,3 2 1,4
9,1,0,10 9 8 7 6 5 1,3 2,4
10,1,2,10 9 8 7 6 5 1,3,4 2
11,0,2,10 9 8 7 6 5,3,4 2 1
12,1,0,10 9 8 7 6 5 3,2,4 2 1
13,2,0,10 9 8 7 6 5 3 1,2,4 2
14,2,1,10 9 8 7 6 5 3 1,2 4,2
15,0,1,10 9 8 7 6 5 3,2 4 1,2
16,0,2,10 9 8 7 6 5,2 4 1,3 2
17,1,0,10 9 8 7 6 5 1,2 4,3 2
18,1,2,10 9 8 7 6 5 1,2,3 2 4
19,0,2,10 9 8 7 6 5,2,3 2 4 1
20,1,0,10 9 8 7 6 5 2,4,3 2 4 1
21,2,1,10 9 8 7 6 5 2,4 3,2 4 1
22,2,0,10 9 8 7 6 5 2 1,4 3,2 4
23,1,0,10 9 8 7 6 5 2 1 3,4,2 4
24,2,1,10 9 8 7 6 5 2 1 3,4 2,4
25,0,1,10 9 8 7 6 5 2 1,4 2 3,4
26,0,2,10 9 8 7 6 5 2,4 2 3,1 4
27,1,2,10 9 8 7 6 5 2,4 2,1 4 3
28,0,2,10 9 8 7 6 5,4 2,1 4 3 2
29,0,1,10 9 8 7 6,5 4 2,1 4 3 2
30,2,0,10 9 8 7 6 1,5 4 2,4 3 2
31,2,1,10 9 8 7 6 1,5 4 2 4,3 2
32,0,1,10 9 8 7 6,5 4 2 4 1,3 2
33,2,0,10 9 8 7 6 3,5 4 2 4 1,2
34,1,2,10 9 8 7 6 3,5 4 2 4,1 2
35,0,2,10 9 8 7 6,5 4 2 4,1 2 3
36,1,0,10 9 8 7 6 4,5 4 2,1 2 3
37,2,0,10 9 8 7 6 4 1,5 4 2,2 3
38,2,1,10 9 8 7 6 4 1,5 4 2 2,3
39,0,1,10 9 8 7 6 4,5 4 2 2 1,3
40,0,2,10 9 8 7 6,5 4 2 2 1,4 3
41,1,0,10 9 8 7 6 2,5 4 2 1,4 3
42,1,2,10 9 8 7 6 2,5 4 2,4 3 1
43,0,2,10 9 8 7 6,5 4 2,4 3 1 2
44,1,0,10 9 8 7 6 5,4 2,4 3 1 2
45,2,1,10 9 8 7 6 5,4 2 4,3 1 2
46,2,0,10 9 8 7 6 5 3,4 2 4,1 2
47,1,0,10 9 8 7 6 5 3 4,2 4,1 2
48,1,2,10 9 8 7 6 5 3 4,2,1 2 4
49,0,2,10 9 8 7 6 5 3,2,1 2 4 4
50,0,1,10 9 8 7 6 5,3 2,1 2 4 4
51,2,0,10 9 8 7 6 5 1,3 2,2 4 4
52,2,1,10 9 8 7 6 5 1,3 2 2,4 4
53,0,1,10 9 8 7 6 5,3 2 2 1,4 4
54,2,0,10 9 8 7 6 5 4,3 2 2 1,4
55,1,2,10 9 8 7 6 5 4,3 2 2,1 4
56,0,2,10 9 8 7 6 5,3 2 2,1 4 4
57,1,0,10 9 8 7 6 5 2,3 2,1 4 4
58,2,0,10 9 8 7 6 5 2 1,3 2,4 4
59,2,1,10 9 8 7 6 5 2 1,3 2 4,4
60,0,1,10 9 8 7 6 5 2,3 2 4 1,4
61,2,0,10 9 8 7 6 5 2 4,3 2 4 1,
62,1,2,10 9 8 7 6 5 2 4,3 2,4 1
63,0,2,10 9 8 7 6 5 2,3 2,4 1 4
64,0,1,10 9 8 7 6 5,2 3 2,4 1 4
65,2,0,10 9 8 7 6 5 4,2 3 2,1 4
66,2,1,10 9 8 7 6 5 4,2 3 2 1,4
67,0,1,10 9 8 7 6 5,2 3 2 1 4,
68,0,2,10 9 8 7 6,2 3 2 1 4,5
69,1,0,10 9 8 7 6 1,2 3 2 4,5
70,1,2,10 9 8 7 6 1,2 3 2,4 5
71,0,2,10 9 8 7 6,2 3 2,4 5 1
72,1,0,10 9 8 7 6 3,2 2,4 5 1
73,2,1,10 9 8 7 6 3,2 2 4,5 1
74,2,0,10 9 8 7 6 3 5,2 2 4,1
75,1,0,10 9 8 7 6 3 5 2,2 4,1
76,1,2,10 9 8 7 6 3 5 2,2,1 4
77,0,2,10 9 8 7 6 3 5,2,1 4 2
78,0,1,10 9 8 7 6 3,5 2,1 4 2
79,2,0,10 9 8 7 6 3 1,5 2,4 2
80,2,1,10 9 8 7 6 3 1,5 2 4,2
81,0,1,10 9 8 7 6 3,5 2 4 1,2
82,2,0,10 9 8 7 6 3 2,5 2 4 1,
83,1,2,10 9 8 7 6 3 2,5 2 4,1
84,0,2,10 9 8 7 6 3,5 2 4,1 2
85,1,0,10 9 8 7 6 3 5,2 4,1 2
86,2,0,10 9 8 7 6 3 5 1,2 4,2
87,2,1,10 9 8 7 6 3 5 1,2 4 2,
88,0,1,10 9 8 7 6 3 5,2 4 2 1,
89,0,2,10 9 8 7 6 3,2 4 2 1,5
90,1,0,10 9 8 7 6 3 2,4 2 1,5
91,1,2,10 9 8 7 6 3 2,4 2,1 5
92,0,2,10 9 8 7 6 3,4 2,1 5 2
93,0,1,10 9 8 7 6,3 4 2,1 5 2
94,2,0,10 9 8 7 6 1,3 4 2,5 2
95,2,1,10 9 8 7 6 1,3 4 2 5,2
96,0,1,10 9 8 7 6,3 4 2 5 1,2
97,2,0,10 9 8 7 6 2,3 4 2 5 1,
98,1,2,10 9 8 7 6 2,3 4 2,5 1
99,0,2,10 9 8 7 6,3 4 2,5 1 2
100,1,0,10 9 8 7 6 4,3 2,5 1 2
101,2,1,10 9 8 7 6 4,3 2 5,1 2
102,2,0,10 9 8 7 6 4 1,3 2 5,2
103,1,0,10 9 8 7 6 4 1 3,2 5,2
104,1,2,10 9 8 7 6 4 1 3,2,2 5
105,0,2,10 9 8 7 6 4 1,2,2 5 3
106,0,1,10 9 8 7 6 4,1 2,2 5 3
107,2,0,10 9 8 7 6 4 2,1 2,5 3
108,2,1,10 9 8 7 6 4 2,1 2 5,3
109,0,1,10 9 8 7 6 4,1 2 5 2,3
110,0,2,10 9 8 7 6,1 2 5 2,4 3
111,1,0,10 9 8 7 6 2,1 5 2,4 3
112,1,2,10 9 8 7 6 2,1 5,4 3 2
113,0,2,10 9 8 7 6,1 5,4 3 2 2
114,0,1,10 9 8 7,6 1 5,4 3 2 2
115,2,0,10 9 8 7 2,6 1 5,4 3 2
116,2,1,10 9 8 7 2,6 1 5 4,3 2
117,0,1,10 9 8 7,6 1 5 4 2,3 2
118,2,0,10 9 8 7 3,6 1 5 4 2,2
119,1,2,10 9 8 7 3,6 1 5 4,2 2
120,0,2,10 9 8 7,6 1 5 4,2 2 3
121,1,0,10 9 8 7 4,6 1 5,2 2 3
122,2,0,10 9 8 7 4 2,6 1 5,2 3
123,2,1,10 9 8 7 4 2,6 1 5 2,3
124,0,1,10 9 8 7 4,6 1 5 2 2,3
125,0,2,10 9 8 7,6 1 5 2 2,4 3
126,1,0,10 9 8 7 2,6 1 5 2,4 3
127,1,2,10 9 8 7 2,6 1 5,4 3 2
128,0,2,10 9 8 7,6 1 5,4 3 2 2
129,1,0,10 9 8 7 6,1 5,4 3 2 2
130,2,1,10 9 8 7 6,1 5 4,3 2 2
131,2,0,10 9 8 7 6 3,1 5 4,2 2
132,1,0,10 9 8 7 6 3 1,5 4,2 2
133,1,2,10 9 8 7 6 3 1,5,2 2 4
134,0,2,10 9 8 7 6 3,5,2 2 4 1
135,0,1,10 9 8 7 6,3 5,2 2 4 1
136,2,0,10 9 8 7 6 2,3 5,2 4 1
137,2,1,10 9 8 7 6 2,3 5 2,4 1
138,0,1,10 9 8 7 6,3 5 2 2,4 1
139,2,0,10 9 8 7 6 4,3 5 2 2,1
140,1,2,10 9 8 7 6 4,3 5 2,1 2
141,0,2,10 9 8 7 6,3 5 2,1 2 4
142,1,0,10 9 8 7 6 5,3 2,1 2 4
143,2,1,10 9 8 7 6 5,3 2 1,2 4
144,2,0,10 9 8 7 6 5 2,3 2 1,4
145,1,0,10 9 8 7 6 5 2 3,2 1,4
146,1,2,10 9 8 7 6 5 2 3,2,4 1
147,0,2,10 9 8 7 6 5 2,2,4 1 3
148,0,1,10 9 8 7 6 5,2 2,4 1 3
149,2,0,10 9 8 7 6 5 4,2 2,1 3
150,2,1,10 9 8 7 6 5 4,2 2 1,3
151,0,1,10 9 8 7 6 5,2 2 1 4,3
152,2,0,10 9 8 7 6 5 3,2 2 1 4,
153,1,2,10 9 8 7 6 5 3,2 2 1,4
154,0,2,10 9 8 7 6 5,2 2 1,4 3
155,1,0,10 9 8 7 6 5 2,2 1,4 3
156,2,0,10 9 8 7 6 5 2 4,2 1,3
157,2,1,10 9 8 7 6 5 2 4,2 1 3,
158,0,1,10 9 8 7 6 5 2,2 1 3 4,
159,0,2,10 9 8 7 6 5,2 1 3 4,2
160,1,0,10 9 8 7 6 5 1,2 3 4,2
161,1,2,10 9 8 7 6 5 1,2 3,2 4
162,0,2,10 9 8 7 6 5,2 3,2 4 1
163,0,1,10 9 8 7 6,5 2 3,2 4 1
164,2,0,10 9 8 7 6 2,5 2 3,4 1
165,2,1,10 9 8 7 6 2,5 2 3 4,1
166,0,1,10 9 8 7 6,5 2 3 4 2,1
167,2,0,10 9 8 7 6 1,5 2 3 4 2,
168,1,2,10 9 8 7 6 1,5 2 3,4 2
169,0,2,10 9 8 7 6,5 2 3,4 2 1
170,1,0,10 9 8 7 6 5,2 3,4 2 1
171,2,1,10 9 8 7 6 5,2 3 4,2 1
172,2,0,10 9 8 7 6 5 2,2 3 4,1
173,1,0,10 9 8 7 6 5 2 2,3 4,1
174,1,2,10 9 8 7 6 5 2 2,3,1 4
175,0,2,10 9 8 7 6 5 2,3,1 4 2
176,0,1,10 9 8 7 6 5,2 3,1 4 2
177,2,0,10 9 8 7 6 5 1,2 3,4 2
178,2,1,10 9 8 7 6 5 1,2 3 4,2
179,0,1,10 9 8 7 6 5,2 3 4 1,2
180,2,0,10 9 8 7 6 5 2,2 3 4 1,
181,1,2,10 9 8 7 6 5 2,2 3,4 1
182,0,2,10 9 8 7 6 5,2 3,4 1 2
183,1,0,10 9 8 7 6 5 3,2,4 1 2
184,2,1,10 9 8 7 6 5 3,2 4,1 2
185,2,0,10 9 8 7 6 5 3 1,2 4,2
186,1,0,10 9 8 7 6 5 3 1 2,4,2
187,1,2,10 9 8 7 6 5 3 1 2,4 2,
188,0,2,10 9 8 7 6 5 3 1,4 2,2
189,0,1,10 9 8 7 6 5 3,1 4 2,2
190,2,0,10 9 8 7 6 5 3 2,1 4 2,
191,2,1,10 9 8 7 6 5 3 2,1 4 2 2,
192,0,1,10 9 8 7 6 5 3,1 4 2 2 2,
193,0,2,10 9 8 7 6 5,1 4 2 2 2,3
194,1,0,10 9 8 7 6 5 2,1 4 2 2,3
195,1,2,10 9 8 7 6 5 2,1 4 2,3 2
196,0,2,10 9 8 7 6 5,1 4 2,3 2 2
197,0,1,10 9 8 7 6,5 1 4 2,3 2 2
198,2,0,10 9 8 7 6 3,5 1 4 2,2 2
199,2,1,10 9 8 7 6 3,5 1 4 2 2,2
200,0,1,10 9 8 7 6,5 1 4 2 2 3,2
201,2,0,10 9 8 7 6 2,5 1 4 2 2 3,
202,1,2,10 9 8 7 6 2,5 1 4 2,3 2
203,0,2,10 9 8 7 6,5 1 4 2,3 2 2
204,1,0,10 9 8 7 6 5,1 4 2,3 2 2
205,2,1,10 9 8 7 6 5,1 4 2 3,2 2
206,2,0,10 9 8 7 6 5 2,1 4 2 3,2
207,1,0,10 9 8 7 6 5 2 1,4 2 3,2
208,1,2,10 9 8 7 6 5 2 1,4 2,2 3
209,0,2,10 9 8 7 6 5 2,4 2,2 3 1
210,0,1,10 9 8 7 6 5,2 4 2,2 3 1
211,2,0,10 9 8 7 6 5 2,2 4 2,3 1
212,2,1,10 9 8 7 6 5 2,2 4 2 3,1
213,0,1,10 9 8 7 6 5,2 4 2 3 2,1
214,2,0,10 9 8 7 6 5 1,2 4 2 3 2,
215,1,2,10 9 8 7 6 5 1,2 4 2,3 2
216,0,2,10 9 8 7 6 5,2 4 2,3 2 1
217,1,0,10 9 8 7 6 5 4,2 2,3 2 1
218,2,1,10 9 8 7 6 5 4,2 2 3,2 1
219,2,0,10 9 8 7 6 5 4 2,2 2 3,1
220,1,0,10 9 8 7 6 5 4 2 2,2 3,1
221,1,2,10 9 8 7 6 5 4 2 2,2,1 3
222,0,2,10 9 8 7 6 5 4 2,2,1 3 2
223,0,1,10 9 8 7 6 5 4,2 2,1 3 2
224,2,0,10 9 8 7 6 5 4 1,2 2,3 2
225,2,1,10 9 8 7 6 5 4 1,2 2 3,2
226,0,1,10 9 8 7 6 5 4,2 2 3 1,2
227,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
228,1,2,10 9 8 7 6 5 4 2,2 2,3 1
229,0,2,10 9 8 7 6 5 4,2 2,3 1 2
230,1,0,10 9 8 7 6 5 4 2,2,3 1 2
231,2,0,10 9 8 7 6 5 4 2 3,2,1 2
232,2,1,10 9 8 7 6 5 4 2 3,2 1,2
233,0,1,10 9 8 7 6 5 4 2,2 1 3,2
234,0,2,10 9 8 7 6 5 4,2 1 3,2 2
235,1,0,10 9 8 7 6 5 4 1,2 3,2 2
236,1,2,10 9 8 7 6 5 4 1,2,2 2 3
237,0,2,10 9 8 7 6 5 4,2,2 2 3 1
238,0,1,10 9 8 7 6 5,4 2,2 2 3 1
239,2,0,10 9 8 7 6 5 2,4 2,2 3 1
240,2,1,10 9 8 7 6 5 2,4 2 2,3 1
241,0,1,10 9 8 7 6 5,4 2 2 2,3 1
242,2,0,10 9 8 7 6 5 3,4 2 2 2,1
243,1,2,10 9 8 7 6 5 3,4 2 2,1 2
244,0,2,10 9 8 7 6 5,4 2 2,1 2 3
245,1,0,10 9 8 7 6 5 4,2 2,1 2 3
246,2,1,10 9 8 7 6 5 4,2 2 1,2 3
247,2,0,10 9 8 7 6 5 4 2,2 2 1,3
248,1,0,10 9 8 7 6 5 4 2 2,2 1,3
249,1,2,10 9 8 7 6 5 4 2 2,2,3 1
250,0,2,10 9 8 7 6 5 4 2,2,3 1 2
251,0,1,10 9 8 7 6 5 4,2 2,3 1 2
252,2,0,10 9 8 7 6 5 4 3,2 2,1 2
253,2,1,10 9 8 7 6 5 4 3,2 2 1,2
254,0,1,10 9 8 7 6 5 4,2 2 1 3,2
255,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
256,1,2,10 9 8 7 6 5 4 2,2 2 1,3
257,0,2,10 9 8 7 6 5 4,2 2 1,3 2
258,1,0,10 9 8 7 6 5 4 2,2 1,3 2
259,2,0,10 9 8 7 6 5 4 2 3,2 1,2
260,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
261,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
262,0,2,10 9 8 7 6 5 4,2 1 2 3,2
263,1,0,10 9 8 7 6 5 4 1,2 2 3,2
264,1,2,10 9 8 7 6 5 4 1,2 2,2 3
265,0,2,10 9 8 7 6 5 4,2 2,2 3 1
266,0,1,10 9 8 7 6 5,4 2 2,2 3 1
267,2,0,10 9 8 7 6 5 2,4 2 2,3 1
268,2,1,10 9 8 7 6 5 2,4 2 2 3,1
269,0,1,10 9 8 7 6 5,4 2 2 3 2,1
270,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
271,1,2,10 9 8 7 6 5 1,4 2 2,3 2
272,0,2,10 9 8 7 6 5,4 2 2,3 2 1
273,1,0,10 9 8 7 6 5 4,2 2,3 2 1
274,2,1,10 9 8 7 6 5 4,2 2 3,2 1
275,2,0,10 9 8 7 6 5 4 2,2 2 3,1
276,1,0,10 9 8 7 6 5 4 2 2,2 3,1
277,1,2,10 9 8 7 6 5 4 2 2,2,1 3
278,0,2,10 9 8 7 6 5 4 2,2,1 3 2
279,0,1,10 9 8 7 6 5 4,2 2,1 3 2
280,2,0,10 9 8 7 6 5 4 1,2 2,3 2
281,2,1,10 9 8 7 6 5 4 1,2 2 3,2
282,0,1,10 9 8 7 6 5 4,2 2 3 1,2
283,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
284,1,2,10 9 8 7 6 5 4 2,2 2,3 1
285,0,2,10 9 8 7 6 5 4,2 2,3 1 2
286,1,0,10 9 8 7 6 5 4 2,2,3 1 2
287,2,0,10 9 8 7 6 5 4 2 3,2,1 2
288,2,1,10 9 8 7 6 5 4 2 3,2 1,2
289,0,1,10 9 8 7 6 5 4 2,2 1 3,2
290,0,2,10 9 8 7 6 5 4,2 1 3,2 2
291,1,0,10 9 8 7 6 5 4 1,2 3,2 2
292,1,2,10 9 8 7 6 5 4 1,2,2 2 3
293,0,2,10 9 8 7 6 5 4,2,2 2 3 1
294,0,1,10 9 8 7 6 5,4 2,2 2 3 1
295,2,0,10 9 8 7 6 5 2,4 2,2 3 1
296,2,1,10 9 8 7 6 5 2,4 2 2,3 1
297,0,1,10 9 8 7 6 5,4 2 2 2,3 1
298,2,0,10 9 8 7 6 5 3,4 2 2 2,1
299,1,2,10 9 8 7 6 5 3,4 2 2,1 2
300,0,2,10 9 8 7 6 5,4 2 2,1 2 3
301,1,0,10 9 8 7 6 5 4,2 2,1 2 3
302,2,1,10 9 8 7 6 5 4,2 2 1,2 3
303,2,0,10 9 8 7 6 5 4 2,2 2 1,3
304,1,0,10 9 8 7 6 5 4 2 2,2 1,3
305,1,2,10 9 8 7 6 5 4 2 2,2,3 1
306,0,2,10 9 8 7 6 5 4 2,2,3 1 2
307,0,1,10 9 8 7 6 5 4,2 2,3 1 2
308,2,0,10 9 8 7 6 5 4 3,2 2,1 2
309,2,1,10 9 8 7 6 5 4 3,2 2 1,2
310,0,1,10 9 8 7 6 5 4,2 2 1 3,2
311,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
312,1,2,10 9 8 7 6 5 4 2,2 2 1,3
313,0,2,10 9 8 7 6 5 4,2 2 1,3 2
314,1,0,10 9 8 7 6 5 4 2,2 1,3 2
315,2,0,10 9 8 7 6 5 4 2 3,2 1,2
316,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
317,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
318,0,2,10 9 8 7 6 5 4,2 1 2 3,2
319,1,0,10 9 8 7 6 5 4 1,2 2 3,2
320,1,2,10 9 8 7 6 5 4 1,2 2,2 3
321,0,2,10 9 8 7 6 5 4,2 2,2 3 1
322,0,1,10 9 8 7 6 5,4 2 2,2 3 1
323,2,0,10 9 8 7 6 5 2,4 2 2,3 1
324,2,1,10 9 8 7 6 5 2,4 2 2 3,1
325,0,1,10 9 8 7 6 5,4 2 2 3 2,1
326,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
327,1,2,10 9 8 7 6 5 1,4 2 2,3 2
328,0,2,10 9 8 7 6 5,4 2 2,3 2 1
329,1,0,10 9 8 7 6 5 4,2 2,3 2 1
330,2,1,10 9 8 7 6 5 4,2 2 3,2 1
331,2,0,10 9 8 7 6 5 4 2,2 2 3,1
332,1,0,10 9 8 7 6 5 4 2 2,2 3,1
333,1,2,10 9 8 7 6 5 4 2 2,2,1 3
334,0,2,10 9 8 7 6 5 4 2,2,1 3 2
335,0,1,10 9 8 7 6 5 4,2 2,1 3 2
336,2,0,10 9 8 7 6 5 4 1,2 2,3 2
337,2,1,10 9 8 7 6 5 4 1,2 2 3,2
338,0,1,10 9 8 7 6 5 4,2 2 3 1,2
339,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
340,1,2,10 9 8 7 6 5 4 2,2 2,3 1
341,0,2,10 9 8 7 6 5 4,2 2,3 1 2
342,1,0,10 9 8 7 6 5 4 2,2,3 1 2
343,2,0,10 9 8 7 6 5 4 2 3,2,1 2
344,2,1,10 9 8 7 6 5 4 2 3,2 1,2
345,0,1,10 9 8 7 6 5 4 2,2 1 3,2
346,0,2,10 9 8 7 6 5 4,2 1 3,2 2
347,1,0,10 9 8 7 6 5 4 1,2 3,2 2
348,1,2,10 9 8 7 6 5 4 1,2,2 2 3
349,0,2,10 9 8 7 6 5 4,2,2 2 3 1
350,0,1,10 9 8 7 6 5,4 2,2 2 3 1
351,2,0,10 9 8 7 6 5 2,4 2,2 3 1
352,2,1,10 9 8 7 6 5 2,4 2 2,3 1
353,0,1,10 9 8 7 6 5,4 2 2 2,3 1
354,2,0,10 9 8 7 6 5 3,4 2 2 2,1
355,1,2,10 9 8 7 6 5 3,4 2 2,1 2
356,0,2,10 9 8 7 6 5,4 2 2,1 2 3
357,1,0,10 9 8 7 6 5 4,2 2,1 2 3
358,2,1,10 9 8 7 6 5 4,2 2 1,2 3
359,2,0,10 9 8 7 6 5 4 2,2 2 1,3
360,1,0,10 9 8 7 6 5 4 2 2,2 1,3
361,1,2,10 9 8 7 6 5 4 2 2,2,3 1
362,0,2,10 9 8 7 6 5 4 2,2,3 1 2
363,0,1,10 9 8 7 6 5 4,2 2,3 1 2
364,2,0,10 9 8 7 6 5 4 3,2 2,1 2
365,2,1,10 9 8 7 6 5 4 3,2 2 1,2
366,0,1,10 9 8 7 6 5 4,2 2 1 3,2
367,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
368,1,2,10 9 8 7 6 5 4 2,2 2 1,3
369,0,2,10 9 8 7 6 5 4,2 2 1,3 2
370,1,0,10 9 8 7 6 5 4 2,2 1,3 2
371,2,0,10 9 8 7 6 5 4 2 3,2 1,2
372,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
373,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
374,0,2,10 9 8 7 6 5 4,2 1 2 3,2
375,1,0,10 9 8 7 6 5 4 1,2 2 3,2
376,1,2,10 9 8 7 6 5 4 1,2 2,2 3
377,0,2,10 9 8 7 6 5 4,2 2,2 3 1
378,0,1,10 9 8 7 6 5,4 2 2,2 3 1
379,2,0,10 9 8 7 6 5 2,4 2 2,3 1
380,2,1,10 9 8 7 6 5 2,4 2 2 3,1
381,0,1,10 9 8 7 6 5,4 2 2 3 2,1
382,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
383,1,2,10 9 8 7 6 5 1,4 2 2,3 2
384,0,2,10 9 8 7 6 5,4 2 2,3 2 1
385,1,0,10 9 8 7 6 5 4,2 2,3 2 1
386,2,1,10 9 8 7 6 5 4,2 2 3,2 1
387,2,0,10 9 8 7 6 5 4 2,2 2 3,1
388,1,0,10 9 8 7 6 5 4 2 2,2 3,1
389,1,2,10 9 8 7 6 5 4 2 2,2,1 3
390,0,2,10 9 8 7 6 5 4 2,2,1 3 2
391,0,1,10 9 8 7 6 5 4,2 2,1 3 2
392,2,0,10 9 8 7 6 5 4 1,2 2,3 2
393,2,1,10 9 8 7 6 5 4 1,2 2 3,2
394,0,1,10 9 8 7 6 5 4,2 2 3 1,2
395,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
396,1,2,10 9 8 7 6 5 4 2,2 2,3 1
397,0,2,10 9 8 7 6 5 4,2 2,3 1 2
398,1,0,10 9 8 7 6 5 4 2,2,3 1 2
399,2,0,10 9 8 7 6 5 4 2 3,2,1 2
400,2,1,10 9 8 7 6 5 4 2 3,2 1,2
401,0,1,10 9 8 7 6 5 4 2,2 1 3,2
402,0,2,10 9 8 7 6 5 4,2 1 3,2 2
403,1,0,10 9 8 7 6 5 4 1,2 3,2 2
404,1,2,10 9 8 7 6 5 4 1,2,2 2 3
405,0,2,10 9 8 7 6 5 4,2,2 2 3 1
406,0,1,10 9 8 7 6 5,4 2,2 2 3 1
407,2,0,10 9 8 7 6 5 2,4 2,2 3 1
408,2,1,10 9 8 7 6 5 2,4 2 2,3 1
409,0,1,10 9 8 7 6 5,4 2 2 2,3 1
410,2,0,10 9 8 7 6 5 3,4 2 2 2,1
411,1,2,10 9 8 7 6 5 3,4 2 2,1 2
412,0,2,10 9 8 7 6 5,4 2 2,1 2 3
413,1,0,10 9 8 7 6 5 4,2 2,1 2 3
414,2,1,10 9 8 7 6 5 4,2 2 1,2 3
415,2,0,10 9 8 7 6 5 4 2,2 2 1,3
416,1,0,10 9 8 7 6 5 4 2 2,2 1,3
417,1,2,10 9 8 7 6 5 4 2 2,2,3 1
418,0,2,10 9 8 7 6 5 4 2,2,3 1 2
419,0,1,10 9 8 7 6 5 4,2 2,3 1 2
420,2,0,10 9 8 7 6 5 4 3,2 2,1 2
421,2,1,10 9 8 7 6 5 4 3,2 2 1,2
422,0,1,10 9 8 7 6 5 4,2 2 1 3,2
423,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
424,1,2,10 9 8 7 6 5 4 2,2 2 1,3
425,0,2,10 9 8 7 6 5 4,2 2 1,3 2
426,1,0,10 9 8 7 6 5 4 2,2 1,3 2
427,2,0,10 9 8 7 6 5 4 2 3,2 1,2
428,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
429,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
430,0,2,10 9 8 7 6 5 4,2 1 2 3,2
431,1,0,10 9 8 7 6 5 4 1,2 2 3,2
432,1,2,10 9 8 7 6 5 4 1,2 2,2 3
433,0,2,10 9 8 7 6 5 4,2 2,2 3 1
434,0,1,10 9 8 7 6 5,4 2 2,2 3 1
435,2,0,10 9 8 7 6 5 2,4 2 2,3 1
436,2,1,10 9 8 7 6 5 2,4 2 2 3,1
437,0,1,10 9 8 7 6 5,4 2 2 3 2,1
438,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
439,1,2,10 9 8 7 6 5 1,4 2 2,3 2
440,0,2,10 9 8 7 6 5,4 2 2,3 2 1
441,1,0,10 9 8 7 6 5 4,2 2,3 2 1
442,2,1,10 9 8 7 6 5 4,2 2 3,2 1
443,2,0,10 9 8 7 6 5 4 2,2 2 3,1
444,1,0,10 9 8 7 6 5 4 2 2,2 3,1
445,1,2,10 9 8 7 6 5 4 2 2,2,1 3
446,0,2,10 9 8 7 6 5 4 2,2,1 3 2
447,0,1,10 9 8 7 6 5 4,2 2,1 3 2
448,2,0,10 9 8 7 6 5 4 1,2 2,3 2
449,2,1,10 9 8 7 6 5 4 1,2 2 3,2
450,0,1,10 9 8 7 6 5 4,2 2 3 1,2
451,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
452,1,2,10 9 8 7 6 5 4 2,2 2,3 1
453,0,2,10 9 8 7 6 5 4,2 2,3 1 2
454,1,0,10 9 8 7 6 5 4 2,2,3 1 2
455,2,0,10 9 8 7 6 5 4 2 3,2,1 2
456,2,1,10 9 8 7 6 5 4 2 3,2 1,2
457,0,1,10 9 8 7 6 5 4 2,2 1 3,2
458,0,2,10 9 8 7 6 5 4,2 1 3,2 2
459,1,0,10 9 8 7 6 5 4 1,2 3,2 2
460,1,2,10 9 8 7 6 5 4 1,2,2 2 3
461,0,2,10 9 8 7 6 5 4,2,2 2 3 1
462,0,1,10 9 8 7 6 5,4 2,2 2 3 1
463,2,0,10 9 8 7 6 5 2,4 2,2 3 1
464,2,1,10 9 8 7 6 5 2,4 2 2,3 1
465,0,1,10 9 8 7 6 5,4 2 2 2,3 1
466,2,0,10 9 8 7 6 5 3,4 2 2 2,1
467,1,2,10 9 8 7 6 5 3,4 2 2,1 2
468,0,2,10 9 8 7 6 5,4 2 2,1 2 3
469,1,0,10 9 8 7 6 5 4,2 2,1 2 3
470,2,1,10 9 8 7 6 5 4,2 2 1,2 3
471,2,0,10 9 8 7 6 5 4 2,2 2 1,3
472,1,0,10 9 8 7 6 5 4 2 2,2 1,3
473,1,2,10 9 8 7 6 5 4 2 2,2,3 1
474,0,2,10 9 8 7 6 5 4 2,2,3 1 2
475,0,1,10 9 8 7 6 5 4,2 2,3 1 2
476,2,0,10 9 8 7 6 5 4 3,2 2,1 2
477,2,1,10 9 8 7 6 5 4 3,2 2 1,2
478,0,1,10 9 8 7 6 5 4,2 2 1 3,2
479,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
480,1,2,10 9 8 7 6 5 4 2,2 2 1,3
481,0,2,10 9 8 7 6 5 4,2 2 1,3 2
482,1,0,10 9 8 7 6 5 4 2,2 1,3 2
483,2,0,10 9 8 7 6 5 4 2 3,2 1,2
484,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
485,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
486,0,2,10 9 8 7 6 5 4,2 1 2 3,2
487,1,0,10 9 8 7 6 5 4 1,2 2 3,2
488,1,2,10 9 8 7 6 5 4 1,2 2,2 3
489,0,2,10 9 8 7 6 5 4,2 2,2 3 1
490,0,1,10 9 8 7 6 5,4 2 2,2 3 1
491,2,0,10 9 8 7 6 5 2,4 2 2,3 1
492,2,1,10 9 8 7 6 5 2,4 2 2 3,1
493,0,1,10 9 8 7 6 5,4 2 2 3 2,1
494,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
495,1,2,10 9 8 7 6 5 1,4 2 2,3 2
496,0,2,10 9 8 7 6 5,4 2 2,3 2 1
497,1,0,10 9 8 7 6 5 4,2 2,3 2 1
498,2,1,10 9 8 7 6 5 4,2 2 3,2 1
499,2,0,10 9 8 7 6 5 4 2,2 2 3,1
500,1,0,10 9 8 7 6 5 4 2 2,2 3,1
501,1,2,10 9 8 7 6 5 4 2 2,2,1 3
502,0,2,10 9 8 7 6 5 4 2,2,1 3 2
503,0,1,10 9 8 7 6 5 4,2 2,1 3 2
504,2,0,10 9 8 7 6 5 4 1,2 2,3 2
505,2,1,10 9 8 7 6 5 4 1,2 2 3,2
506,0,1,10 9 8 7 6 5 4,2 2 3 1,2
507,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
508,1,2,10 9 8 7 6 5 4 2,2 2,3 1
509,0,2,10 9 8 7 6 5 4,2 2,3 1 2
510,1,0,10 9 8 7 6 5 4 2,2,3 1 2
511,2,0,10 9 8 7 6 5 4 2 3,2,1 2
512,2,1,10 9 8 7 6 5 4 2 3,2 1,2
513,0,1,10 9 8 7 6 5 4 2,2 1 3,2
514,0,2,10 9 8 7 6 5 4,2 1 3,2 2
515,1,0,10 9 8 7 6 5 4 1,2 3,2 2
516,1,2,10 9 8 7 6 5 4 1,2,2 2 3
517,0,2,10 9 8 7 6 5 4,2,2 2 3 1
518,0,1,10 9 8 7 6 5,4 2,2 2 3 1
519,2,0,10 9 8 7 6 5 2,4 2,2 3 1
520,2,1,10 9 8 7 6 5 2,4 2 2,3 1
521,0,1,10 9 8 7 6 5,4 2 2 2,3 1
522,2,0,10 9 8 7 6 5 3,4 2 2 2,1
523,1,2,10 9 8 7 6 5 3,4 2 2,1 2
524,0,2,10 9 8 7 6 5,4 2 2,1 2 3
525,1,0,10 9 8 7 6 5 4,2 2,1 2 3
526,2,1,10 9 8 7 6 5 4,2 2 1,2 3
527,2,0,10 9 8 7 6 5 4 2,2 2 1,3
528,1,0,10 9 8 7 6 5 4 2 2,2 1,3
529,1,2,10 9 8 7 6 5 4 2 2,2,3 1
530,0,2,10 9 8 7 6 5 4 2,2,3 1 2
531,0,1,10 9 8 7 6 5 4,2 2,3 1 2
532,2,0,10 9 8 7 6 5 4 3,2 2,1 2
533,2,1,10 9 8 7 6 5 4 3,2 2 1,2
534,0,1,10 9 8 7 6 5 4,2 2 1 3,2
535,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
536,1,2,10 9 8 7 6 5 4 2,2 2 1,3
537,0,2,10 9 8 7 6 5 4,2 2 1,3 2
538,1,0,10 9 8 7 6 5 4 2,2 1,3 2
539,2,0,10 9 8 7 6 5 4 2 3,2 1,2
540,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
541,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
542,0,2,10 9 8 7 6 5 4,2 1 2 3,2
543,1,0,10 9 8 7 6 5 4 1,2 2 3,2
544,1,2,10 9 8 7 6 5 4 1,2 2,2 3
545,0,2,10 9 8 7 6 5 4,2 2,2 3 1
546,0,1,10 9 8 7 6 5,4 2 2,2 3 1
547,2,0,10 9 8 7 6 5 2,4 2 2,3 1
548,2,1,10 9 8 7 6 5 2,4 2 2 3,1
549,0,1,10 9 8 7 6 5,4 2 2 3 2,1
550,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
551,1,2,10 9 8 7 6 5 1,4 2 2,3 2
552,0,2,10 9 8 7 6 5,4 2 2,3 2 1
553,1,0,10 9 8 7 6 5 4,2 2,3 2 1
554,2,1,10 9 8 7 6 5 4,2 2 3,2 1
555,2,0,10 9 8 7 6 5 4 2,2 2 3,1
556,1,0,10 9 8 7 6 5 4 2 2,2 3,1
557,1,2,10 9 8 7 6 5 4 2 2,2,1 3
558,0,2,10 9 8 7 6 5 4 2,2,1 3 2
559,0,1,10 9 8 7 6 5 4,2 2,1 3 2
560,2,0,10 9 8 7 6 5 4 1,2 2,3 2
561,2,1,10 9 8 7 6 5 4 1,2 2 3,2
562,0,1,10 9 8 7 6 5 4,2 2 3 1,2
563,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
564,1,2,10 9 8 7 6 5 4 2,2 2,3 1
565,0,2,10 9 8 7 6 5 4,2 2,3 1 2
566,1,0,10 9 8 7 6 5 4 2,2,3 1 2
567,2,0,10 9 8 7 6 5 4 2 3,2,1 2
568,2,1,10 9 8 7 6 5 4 2 3,2 1,2
569,0,1,10 9 8 7 6 5 4 2,2 1 3,2
570,0,2,10 9 8 7 6 5 4,2 1 3,2 2
571,1,0,10 9 8 7 6 5 4 1,2 3,2 2
572,1,2,10 9 8 7 6 5 4 1,2,2 2 3
573,0,2,10 9 8 7 6 5 4,2,2 2 3 1
574,0,1,10 9 8 7 6 5,4 2,2 2 3 1
575,2,0,10 9 8 7 6 5 2,4 2,2 3 1
576,2,1,10 9 8 7 6 5 2,4 2 2,3 1
577,0,1,10 9 8 7 6 5,4 2 2 2,3 1
578,2,0,10 9 8 7 6 5 3,4 2 2 2,1
579,1,2,10 9 8 7 6 5 3,4 2 2,1 2
580,0,2,10 9 8 7 6 5,4 2 2,1 2 3
581,1,0,10 9 8 7 6 5 4,2 2,1 2 3
582,2,1,10 9 8 7 6 5 4,2 2 1,2 3
583,2,0,10 9 8 7 6 5 4 2,2 2 1,3
584,1,0,10 9 8 7 6 5 4 2 2,2 1,3
585,1,2,10 9 8 7 6 5 4 2 2,2,3 1
586,0,2,10 9 8 7 6 5 4 2,2,3 1 2
587,0,1,10 9 8 7 6 5 4,2 2,3 1 2
588,2,0,10 9 8 7 6 5 4 3,2 2,1 2
589,2,1,10 9 8 7 6 5 4 3,2 2 1,2
590,0,1,10 9 8 7 6 5 4,2 2 1 3,2
591,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
592,1,2,10 9 8 7 6 5 4 2,2 2 1,3
593,0,2,10 9 8 7 6 5 4,2 2 1,3 2
594,1,0,10 9 8 7 6 5 4 2,2 1,3 2
595,2,0,10 9 8 7 6 5 4 2 3,2 1,2
596,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
597,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
598,0,2,10 9 8 7 6 5 4,2 1 2 3,2
599,1,0,10 9 8 7 6 5 4 1,2 2 3,2
600,1,2,10 9 8 7 6 5 4 1,2 2,2 3
601,0,2,10 9 8 7 6 5 4,2 2,2 3 1
602,0,1,10 9 8 7 6 5,4 2 2,2 3 1
603,2,0,10 9 8 7 6 5 2,4 2 2,3 1
604,2,1,10 9 8 7 6 5 2,4 2 2 3,1
605,0,1,10 9 8 7 6 5,4 2 2 3 2,1
606,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
607,1,2,10 9 8 7 6 5 1,4 2 2,3 2
608,0,2,10 9 8 7 6 5,4 2 2,3 2 1
609,1,0,10 9 8 7 6 5 4,2 2,3 2 1
610,2,1,10 9 8 7 6 5 4,2 2 3,2 1
611,2,0,10 9 8 7 6 5 4 2,2 2 3,1
612,1,0,10 9 8 7 6 5 4 2 2,2 3,1
613,1,2,10 9 8 7 6 5 4 2 2,2,1 3
614,0,2,10 9 8 7 6 5 4 2,2,1 3 2
615,0,1,10 9 8 7 6 5 4,2 2,1 3 2
616,2,0,10 9 8 7 6 5 4 1,2 2,3 2
617,2,1,10 9 8 7 6 5 4 1,2 2 3,2
618,0,1,10 9 8 7 6 5 4,2 2 3 1,2
619,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
620,1,2,10 9 8 7 6 5 4 2,2 2,3 1
621,0,2,10 9 8 7 6 5 4,2 2,3 1 2
622,1,0,10 9 8 7 6 5 4 2,2,3 1 2
623,2,0,10 9 8 7 6 5 4 2 3,2,1 2
624,2,1,10 9 8 7 6 5 4 2 3,2 1,2
625,0,1,10 9 8 7 6 5 4 2,2 1 3,2
626,0,2,10 9 8 7 6 5 4,2 1 3,2 2
627,1,0,10 9 8 7 6 5 4 1,2 3,2 2
628,1,2,10 9 8 7 6 5 4 1,2,2 2 3
629,0,2,10 9 8 7 6 5 4,2,2 2 3 1
630,0,1,10 9 8 7 6 5,4 2,2 2 3 1
631,2,0,10 9 8 7 6 5 2,4 2,2 3 1
632,2,1,10 9 8 7 6 5 2,4 2 2,3 1
633,0,1,10 9 8 7 6 5,4 2 2 2,3 1
634,2,0,10 9 8 7 6 5 3,4 2 2 2,1
635,1,2,10 9 8 7 6 5 3,4 2 2,1 2
636,0,2,10 9 8 7 6 5,4 2 2,1 2 3
637,1,0,10 9 8 7 6 5 4,2 2,1 2 3
638,2,1,10 9 8 7 6 5 4,2 2 1,2 3
639,2,0,10 9 8 7 6 5 4 2,2 2 1,3
640,1,0,10 9 8 7 6 5 4 2 2,2 1,3
641,1,2,10 9 8 7 6 5 4 2 2,2,3 1
642,0,2,10 9 8 7 6 5 4 2,2,3 1 2
643,0,1,10 9 8 7 6 5 4,2 2,3 1 2
644,2,0,10 9 8 7 6 5 4 3,2 2,1 2
645,2,1,10 9 8 7 6 5 4 3,2 2 1,2
646,0,1,10 9 8 7 6 5 4,2 2 1 3,2
647,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
648,1,2,10 9 8 7 6 5 4 2,2 2 1,3
649,0,2,10 9 8 7 6 5 4,2 2 1,3 2
650,1,0,10 9 8 7 6 5 4 2,2 1,3 2
651,2,0,10 9 8 7 6 5 4 2 3,2 1,2
652,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
653,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
654,0,2,10 9 8 7 6 5 4,2 1 2 3,2
655,1,0,10 9 8 7 6 5 4 1,2 2 3,2
656,1,2,10 9 8 7 6 5 4 1,2 2,2 3
657,0,2,10 9 8 7 6 5 4,2 2,2 3 1
658,0,1,10 9 8 7 6 5,4 2 2,2 3 1
659,2,0,10 9 8 7 6 5 2,4 2 2,3 1
660,2,1,10 9 8 7 6 5 2,4 2 2 3,1
661,0,1,10 9 8 7 6 5,4 2 2 3 2,1
662,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
663,1,2,10 9 8 7 6 5 1,4 2 2,3 2
664,0,2,10 9 8 7 6 5,4 2 2,3 2 1
665,1,0,10 9 8 7 6 5 4,2 2,3 2 1
666,2,1,10 9 8 7 6 5 4,2 2 3,2 1
667,2,0,10 9 8 7 6 5 4 2,2 2 3,1
668,1,0,10 9 8 7 6 5 4 2 2,2 3,1
669,1,2,10 9 8 7 6 5 4 2 2,2,1 3
670,0,2,10 9 8 7 6 5 4 2,2,1 3 2
671,0,1,10 9 8 7 6 5 4,2 2,1 3 2
672,2,0,10 9 8 7 6 5 4 1,2 2,3 2
673,2,1,10 9 8 7 6 5 4 1,2 2 3,2
674,0,1,10 9 8 7 6 5 4,2 2 3 1,2
675,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
676,1,2,10 9 8 7 6 5 4 2,2 2,3 1
677,0,2,10 9 8 7 6 5 4,2 2,3 1 2
678,1,0,10 9 8 7 6 5 4 2,2,3 1 2
679,2,0,10 9 8 7 6 5 4 2 3,2,1 2
680,2,1,10 9 8 7 6 5 4 2 3,2 1,2
681,0,1,10 9 8 7 6 5 4 2,2 1 3,2
682,0,2,10 9 8 7 6 5 4,2 1 3,2 2
683,1,0,10 9 8 7 6 5 4 1,2 3,2 2
684,1,2,10 9 8 7 6 5 4 1,2,2 2 3
685,0,2,10 9 8 7 6 5 4,2,2 2 3 1
686,0,1,10 9 8 7 6 5,4 2,2 2 3 1
687,2,0,10 9 8 7 6 5 2,4 2,2 3 1
688,2,1,10 9 8 7 6 5 2,4 2 2,3 1
689,0,1,10 9 8 7 6 5,4 2 2 2,3 1
690,2,0,10 9 8 7 6 5 3,4 2 2 2,1
691,1,2,10 9 8 7 6 5 3,4 2 2,1 2
692,0,2,10 9 8 7 6 5,4 2 2,1 2 3
693,1,0,10 9 8 7 6 5 4,2 2,1 2 3
694,2,1,10 9 8 7 6 5 4,2 2 1,2 3
695,2,0,10 9 8 7 6 5 4 2,2 2 1,3
696,1,0,10 9 8 7 6 5 4 2 2,2 1,3
697,1,2,10 9 8 7 6 5 4 2 2,2,3 1
698,0,2,10 9 8 7 6 5 4 2,2,3 1 2
699,0,1,10 9 8 7 6 5 4,2 2,3 1 2
700,2,0,10 9 8 7 6 5 4 3,2 2,1 2
701,2,1,10 9 8 7 6 5 4 3,2 2 1,2
702,0,1,10 9 8 7 6 5 4,2 2 1 3,2
703,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
704,1,2,10 9 8 7 6 5 4 2,2 2 1,3
705,0,2,10 9 8 7 6 5 4,2 2 1,3 2
706,1,0,10 9 8 7 6 5 4 2,2 1,3 2
707,2,0,10 9 8 7 6 5 4 2 3,2 1,2
708,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
709,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
710,0,2,10 9 8 7 6 5 4,2 1 2 3,2
711,1,0,10 9 8 7 6 5 4 1,2 2 3,2
712,1,2,10 9 8 7 6 5 4 1,2 2,2 3
713,0,2,10 9 8 7 6 5 4,2 2,2 3 1
714,0,1,10 9 8 7 6 5,4 2 2,2 3 1
715,2,0,10 9 8 7 6 5 2,4 2 2,3 1
716,2,1,10 9 8 7 6 5 2,4 2 2 3,1
717,0,1,10 9 8 7 6 5,4 2 2 3 2,1
718,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
719,1,2,10 9 8 7 6 5 1,4 2 2,3 2
720,0,2,10 9 8 7 6 5,4 2 2,3 2 1
721,1,0,10 9 8 7 6 5 4,2 2,3 2 1
722,2,1,10 9 8 7 6 5 4,2 2 3,2 1
723,2,0,10 9 8 7 6 5 4 2,2 2 3,1
724,1,0,10 9 8 7 6 5 4 2 2,2 3,1
725,1,2,10 9 8 7 6 5 4 2 2,2,1 3
726,0,2,10 9 8 7 6 5 4 2,2,1 3 2
727,0,1,10 9 8 7 6 5 4,2 2,1 3 2
728,2,0,10 9 8 7 6 5 4 1,2 2,3 2
729,2,1,10 9 8 7 6 5 4 1,2 2 3,2
730,0,1,10 9 8 7 6 5 4,2 2 3 1,2
731,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
732,1,2,10 9 8 7 6 5 4 2,2 2,3 1
733,0,2,10 9 8 7 6 5 4,2 2,3 1 2
734,1,0,10 9 8 7 6 5 4 2,2,3 1 2
735,2,0,10 9 8 7 6 5 4 2 3,2,1 2
736,2,1,10 9 8 7 6 5 4 2 3,2 1,2
737,0,1,10 9 8 7 6 5 4 2,2 1 3,2
738,0,2,10 9 8 7 6 5 4,2 1 3,2 2
739,1,0,10 9 8 7 6 5 4 1,2 3,2 2
740,1,2,10 9 8 7 6 5 4 1,2,2 2 3
741,0,2,10 9 8 7 6 5 4,2,2 2 3 1
742,0,1,10 9 8 7 6 5,4 2,2 2 3 1
743,2,0,10 9 8 7 6 5 2,4 2,2 3 1
744,2,1,10 9 8 7 6 5 2,4 2 2,3 1
745,0,1,10 9 8 7 6 5,4 2 2 2,3 1
746,2,0,10 9 8 7 6 5 3,4 2 2 2,1
747,1,2,10 9 8 7 6 5 3,4 2 2,1 2
748,0,2,10 9 8 7 6 5,4 2 2,1 2 3
749,1,0,10 9 8 7 6 5 4,2 2,1 2 3
750,2,1,10 9 8 7 6 5 4,2 2 1,2 3
751,2,0,10 9 8 7 6 5 4 2,2 2 1,3
752,1,0,10 9 8 7 6 5 4 2 2,2 1,3
753,1,2,10 9 8 7 6 5 4 2 2,2,3 1
754,0,2,10 9 8 7 6 5 4 2,2,3 1 2
755,0,1,10 9 8 7 6 5 4,2 2,3 1 2
756,2,0,10 9 8 7 6 5 4 3,2 2,1 2
757,2,1,10 9 8 7 6 5 4 3,2 2 1,2
758,0,1,10 9 8 7 6 5 4,2 2 1 3,2
759,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
760,1,2,10 9 8 7 6 5 4 2,2 2 1,3
761,0,2,10 9 8 7 6 5 4,2 2 1,3 2
762,1,0,10 9 8 7 6 5 4 2,2 1,3 2
763,2,0,10 9 8 7 6 5 4 2 3,2 1,2
764,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
765,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
766,0,2,10 9 8 7 6 5 4,2 1 2 3,2
767,1,0,10 9 8 7 6 5 4 1,2 2 3,2
768,1,2,10 9 8 7 6 5 4 1,2 2,2 3
769,0,2,10 9 8 7 6 5 4,2 2,2 3 1
770,0,1,10 9 8 7 6 5,4 2 2,2 3 1
771,2,0,10 9 8 7 6 5 2,4 2 2,3 1
772,2,1,10 9 8 7 6 5 2,4 2 2 3,1
773,0,1,10 9 8 7 6 5,4 2 2 3 2,1
774,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
775,1,2,10 9 8 7 6 5 1,4 2 2,3 2
776,0,2,10 9 8 7 6 5,4 2 2,3 2 1
777,1,0,10 9 8 7 6 5 4,2 2,3 2 1
778,2,1,10 9 8 7 6 5 4,2 2 3,2 1
779,2,0,10 9 8 7 6 5 4 2,2 2 3,1
780,1,0,10 9 8 7 6 5 4 2 2,2 3,1
781,1,2,10 9 8 7 6 5 4 2 2,2,1 3
782,0,2,10 9 8 7 6 5 4 2,2,1 3 2
783,0,1,10 9 8 7 6 5 4,2 2,1 3 2
784,2,0,10 9 8 7 6 5 4 1,2 2,3 2
785,2,1,10 9 8 7 6 5 4 1,2 2 3,2
786,0,1,10 9 8 7 6 5 4,2 2 3 1,2
787,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
788,1,2,10 9 8 7 6 5 4 2,2 2,3 1
789,0,2,10 9 8 7 6 5 4,2 2,3 1 2
790,1,0,10 9 8 7 6 5 4 2,2,3 1 2
791,2,0,10 9 8 7 6 5 4 2 3,2,1 2
792,2,1,10 9 8 7 6 5 4 2 3,2 1,2
793,0,1,10 9 8 7 6 5 4 2,2 1 3,2
794,0,2,10 9 8 7 6 5 4,2 1 3,2 2
795,1,0,10 9 8 7 6 5 4 1,2 3,2 2
796,1,2,10 9 8 7 6 5 4 1,2,2 2 3
797,0,2,10 9 8 7 6 5 4,2,2 2 3 1
798,0,1,10 9 8 7 6 5,4 2,2 2 3 1
799,2,0,10 9 8 7 6 5 2,4 2,2 3 1
800,2,1,10 9 8 7 6 5 2,4 2 2,3 1
801,0,1,10 9 8 7 6 5,4 2 2 2,3 1
802,2,0,10 9 8 7 6 5 3,4 2 2 2,1
803,1,2,10 9 8 7 6 5 3,4 2 2,1 2
804,0,2,10 9 8 7 6 5,4 2 2,1 2 3
805,1,0,10 9 8 7 6 5 4,2 2,1 2 3
806,2,1,10 9 8 7 6 5 4,2 2 1,2 3
807,2,0,10 9 8 7 6 5 4 2,2 2 1,3
808,1,0,10 9 8 7 6 5 4 2 2,2 1,3
809,1,2,10 9 8 7 6 5 4 2 2,2,3 1
810,0,2,10 9 8 7 6 5 4 2,2,3 1 2
811,0,1,10 9 8 7 6 5 4,2 2,3 1 2
812,2,0,10 9 8 7 6 5 4 3,2 2,1 2
813,2,1,10 9 8 7 6 5 4 3,2 2 1,2
814,0,1,10 9 8 7 6 5 4,2 2 1 3,2
815,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
816,1,2,10 9 8 7 6 5 4 2,2 2 1,3
817,0,2,10 9 8 7 6 5 4,2 2 1,3 2
818,1,0,10 9 8 7 6 5 4 2,2 1,3 2
819,2,0,10 9 8 7 6 5 4 2 3,2 1,2
820,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
821,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
822,0,2,10 9 8 7 6 5 4,2 1 2 3,2
823,1,0,10 9 8 7 6 5 4 1,2 2 3,2
824,1,2,10 9 8 7 6 5 4 1,2 2,2 3
825,0,2,10 9 8 7 6 5 4,2 2,2 3 1
826,0,1,10 9 8 7 6 5,4 2 2,2 3 1
827,2,0,10 9 8 7 6 5 2,4 2 2,3 1
828,2,1,10 9 8 7 6 5 2,4 2 2 3,1
829,0,1,10 9 8 7 6 5,4 2 2 3 2,1
830,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
831,1,2,10 9 8 7 6 5 1,4 2 2,3 2
832,0,2,10 9 8 7 6 5,4 2 2,3 2 1
833,1,0,10 9 8 7 6 5 4,2 2,3 2 1
834,2,1,10 9 8 7 6 5 4,2 2 3,2 1
835,2,0,10 9 8 7 6 5 4 2,2 2 3,1
836,1,0,10 9 8 7 6 5 4 2 2,2 3,1
837,1,2,10 9 8 7 6 5 4 2 2,2,1 3
838,0,2,10 9 8 7 6 5 4 2,2,1 3 2
839,0,1,10 9 8 7 6 5 4,2 2,1 3 2
840,2,0,10 9 8 7 6 5 4 1,2 2,3 2
841,2,1,10 9 8 7 6 5 4 1,2 2 3,2
842,0,1,10 9 8 7 6 5 4,2 2 3 1,2
843,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
844,1,2,10 9 8 7 6 5 4 2,2 2,3 1
845,0,2,10 9 8 7 6 5 4,2 2,3 1 2
846,1,0,10 9 8 7 6 5 4 2,2,3 1 2
847,2,0,10 9 8 7 6 5 4 2 3,2,1 2
848,2,1,10 9 8 7 6 5 4 2 3,2 1,2
849,0,1,10 9 8 7 6 5 4 2,2 1 3,2
850,0,2,10 9 8 7 6 5 4,2 1 3,2 2
851,1,0,10 9 8 7 6 5 4 1,2 3,2 2
852,1,2,10 9 8 7 6 5 4 1,2,2 2 3
853,0,2,10 9 8 7 6 5 4,2,2 2 3 1
854,0,1,10 9 8 7 6 5,4 2,2 2 3 1
855,2,0,10 9 8 7 6 5 2,4 2,2 3 1
856,2,1,10 9 8 7 6 5 2,4 2 2,3 1
857,0,1,10 9 8 7 6 5,4 2 2 2,3 1
858,2,0,10 9 8 7 6 5 3,4 2 2 2,1
859,1,2,10 9 8 7 6 5 3,4 2 2,1 2
860,0,2,10 9 8 7 6 5,4 2 2,1 2 3
861,1,0,10 9 8 7 6 5 4,2 2,1 2 3
862,2,1,10 9 8 7 6 5 4,2 2 1,2 3
863,2,0,10 9 8 7 6 5 4 2,2 2 1,3
864,1,0,10 9 8 7 6 5 4 2 2,2 1,3
865,1,2,10 9 8 7 6 5 4 2 2,2,3 1
866,0,2,10 9 8 7 6 5 4 2,2,3 1 2
867,0,1,10 9 8 7 6 5 4,2 2,3 1 2
868,2,0,10 9 8 7 6 5 4 3,2 2,1 2
869,2,1,10 9 8 7 6 5 4 3,2 2 1,2
870,0,1,10 9 8 7 6 5 4,2 2 1 3,2
871,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
872,1,2,10 9 8 7 6 5 4 2,2 2 1,3
873,0,2,10 9 8 7 6 5 4,2 2 1,3 2
874,1,0,10 9 8 7 6 5 4 2,2 1,3 2
875,2,0,10 9 8 7 6 5 4 2 3,2 1,2
876,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
877,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
878,0,2,10 9 8 7 6 5 4,2 1 2 3,2
879,1,0,10 9 8 7 6 5 4 1,2 2 3,2
880,1,2,10 9 8 7 6 5 4 1,2 2,2 3
881,0,2,10 9 8 7 6 5 4,2 2,2 3 1
882,0,1,10 9 8 7 6 5,4 2 2,2 3 1
883,2,0,10 9 8 7 6 5 2,4 2 2,3 1
884,2,1,10 9 8 7 6 5 2,4 2 2 3,1
885,0,1,10 9 8 7 6 5,4 2 2 3 2,1
886,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
887,1,2,10 9 8 7 6 5 1,4 2 2,3 2
888,0,2,10 9 8 7 6 5,4 2 2,3 2 1
889,1,0,10 9 8 7 6 5 4,2 2,3 2 1
890,2,1,10 9 8 7 6 5 4,2 2 3,2 1
891,2,0,10 9 8 7 6 5 4 2,2 2 3,1
892,1,0,10 9 8 7 6 5 4 2 2,2 3,1
893,1,2,10 9 8 7 6 5 4 2 2,2,1 3
894,0,2,10 9 8 7 6 5 4 2,2,1 3 2
895,0,1,10 9 8 7 6 5 4,2 2,1 3 2
896,2,0,10 9 8 7 6 5 4 1,2 2,3 2
897,2,1,10 9 8 7 6 5 4 1,2 2 3,2
898,0,1,10 9 8 7 6 5 4,2 2 3 1,2
899,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
900,1,2,10 9 8 7 6 5 4 2,2 2,3 1
901,0,2,10 9 8 7 6 5 4,2 2,3 1 2
902,1,0,10 9 8 7 6 5 4 2,2,3 1 2
903,2,0,10 9 8 7 6 5 4 2 3,2,1 2
904,2,1,10 9 8 7 6 5 4 2 3,2 1,2
905,0,1,10 9 8 7 6 5 4 2,2 1 3,2
906,0,2,10 9 8 7 6 5 4,2 1 3,2 2
907,1,0,10 9 8 7 6 5 4 1,2 3,2 2
908,1,2,10 9 8 7 6 5 4 1,2,2 2 3
909,0,2,10 9 8 7 6 5 4,2,2 2 3 1
910,0,1,10 9 8 7 6 5,4 2,2 2 3 1
911,2,0,10 9 8 7 6 5 2,4 2,2 3 1
912,2,1,10 9 8 7 6 5 2,4 2 2,3 1
913,0,1,10 9 8 7 6 5,4 2 2 2,3 1
914,2,0,10 9 8 7 6 5 3,4 2 2 2,1
915,1,2,10 9 8 7 6 5 3,4 2 2,1 2
916,0,2,10 9 8 7 6 5,4 2 2,1 2 3
917,1,0,10 9 8 7 6 5 4,2 2,1 2 3
918,2,1,10 9 8 7 6 5 4,2 2 1,2 3
919,2,0,10 9 8 7 6 5 4 2,2 2 1,3
920,1,0,10 9 8 7 6 5 4 2 2,2 1,3
921,1,2,10 9 8 7 6 5 4 2 2,2,3 1
922,0,2,10 9 8 7 6 5 4 2,2,3 1 2
923,0,1,10 9 8 7 6 5 4,2 2,3 1 2
924,2,0,10 9 8 7 6 5 4 3,2 2,1 2
925,2,1,10 9 8 7 6 5 4 3,2 2 1,2
926,0,1,10 9 8 7 6 5 4,2 2 1 3,2
927,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
928,1,2,10 9 8 7 6 5 4 2,2 2 1,3
929,0,2,10 9 8 7 6 5 4,2 2 1,3 2
930,1,0,10 9 8 7 6 5 4 2,2 1,3 2
931,2,0,10 9 8 7 6 5 4 2 3,2 1,2
932,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
933,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
934,0,2,10 9 8 7 6 5 4,2 1 2 3,2
935,1,0,10 9 8 7 6 5 4 1,2 2 3,2
936,1,2,10 9 8 7 6 5 4 1,2 2,2 3
937,0,2,10 9 8 7 6 5 4,2 2,2 3 1
938,0,1,10 9 8 7 6 5,4 2 2,2 3 1
939,2,0,10 9 8 7 6 5 2,4 2 2,3 1
940,2,1,10 9 8 7 6 5 2,4 2 2 3,1
941,0,1,10 9 8 7 6 5,4 2 2 3 2,1
942,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
943,1,2,10 9 8 7 6 5 1,4 2 2,3 2
944,0,2,10 9 8 7 6 5,4 2 2,3 2 1
945,1,0,10 9 8 7 6 5 4,2 2,3 2 1
946,2,1,10 9 8 7 6 5 4,2 2 3,2 1
947,2,0,10 9 8 7 6 5 4 2,2 2 3,1
948,1,0,10 9 8 7 6 5 4 2 2,2 3,1
949,1,2,10 9 8 7 6 5 4 2 2,2,1 3
950,0,2,10 9 8 7 6 5 4 2,2,1 3 2
951,0,1,10 9 8 7 6 5 4,2 2,1 3 2
952,2,0,10 9 8 7 6 5 4 1,2 2,3 2
953,2,1,10 9 8 7 6 5 4 1,2 2 3,2
954,0,1,10 9 8 7 6 5 4,2 2 3 1,2
955,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
956,1,2,10 9 8 7 6 5 4 2,2 2,3 1
957,0,2,10 9 8 7 6 5 4,2 2,3 1 2
958,1,0,10 9 8 7 6 5 4 2,2,3 1 2
959,2,0,10 9 8 7 6 5 4 2 3,2,1 2
960,2,1,10 9 8 7 6 5 4 2 3,2 1,2
961,0,1,10 9 8 7 6 5 4 2,2 1 3,2
962,0,2,10 9 8 7 6 5 4,2 1 3,2 2
963,1,0,10 9 8 7 6 5 4 1,2 3,2 2
964,1,2,10 9 8 7 6 5 4 1,2,2 2 3
965,0,2,10 9 8 7 6 5 4,2,2 2 3 1
966,0,1,10 9 8 7 6 5,4 2,2 2 3 1
967,2,0,10 9 8 7 6 5 2,4 2,2 3 1
968,2,1,10 9 8 7 6 5 2,4 2 2,3 1
969,0,1,10 9 8 7 6 5,4 2 2 2,3 1
970,2,0,10 9 8 7 6 5 3,4 2 2 2,1
971,1,2,10 9 8 7 6 5 3,4 2 2,1 2
972,0,2,10 9 8 7 6 5,4 2 2,1 2 3
973,1,0,10 9 8 7 6 5 4,2 2,1 2 3
974,2,1,10 9 8 7 6 5 4,2 2 1,2 3
975,2,0,10 9 8 7 6 5 4 2,2 2 1,3
976,1,0,10 9 8 7 6 5 4 2 2,2 1,3
977,1,2,10 9 8 7 6 5 4 2 2,2,3 1
978,0,2,10 9 8 7 6 5 4 2,2,3 1 2
979,0,1,10 9 8 7 6 5 4,2 2,3 1 2
980,2,0,10 9 8 7 6 5 4 3,2 2,1 2
981,2,1,10 9 8 7 6 5 4 3,2 2 1,2
982,0,1,10 9 8 7 6 5 4,2 2 1 3,2
983,2,0,10 9 8 7 6 5 4 2,2 2 1 3,
984,1,2,10 9 8 7 6 5 4 2,2 2 1,3
985,0,2,10 9 8 7 6 5 4,2 2 1,3 2
986,1,0,10 9 8 7 6 5 4 2,2 1,3 2
987,2,0,10 9 8 7 6 5 4 2 3,2 1,2
988,2,1,10 9 8 7 6 5 4 2 3,2 1 2,
989,0,1,10 9 8 7 6 5 4 2,2 1 2 3,
990,0,2,10 9 8 7 6 5 4,2 1 2 3,2
991,1,0,10 9 8 7 6 5 4 1,2 2 3,2
992,1,2,10 9 8 7 6 5 4 1,2 2,2 3
993,0,2,10 9 8 7 6 5 4,2 2,2 3 1
994,0,1,10 9 8 7 6 5,4 2 2,2 3 1
995,2,0,10 9 8 7 6 5 2,4 2 2,3 1
996,2,1,10 9 8 7 6 5 2,4 2 2 3,1
997,0,1,10 9 8 7 6 5,4 2 2 3 2,1
998,2,0,10 9 8 7 6 5 1,4 2 2 3 2,
999,1,2,10 9 8 7 6 5 1,4 2 2,3 2
1000,0,2,10 9 8 7 6 5,4 2 2,3 2 1
1001,1,0,10 9 8 7 6 5 4,2 2,3 2 1
1002,2,1,10 9 8 7 6 5 4,2 2 3,2 1
1003,2,0,10 9 8 7 6 5 4 2,2 2 3,1
1004,1,0,10 9 8 7 6 5 4 2 2,2 3,1
1005,1,2,10 9 8 7 6 5 4 2 2,2,1 3
1006,0,2,10 9 8 7 6 5 4 2,2,1 3 2
1007,0,1,10 9 8 7 6 5 4,2 2,1 3 2
1008,2,0,10 9 8 7 6 5 4 1,2 2,3 2
1009,2,1,10 9 8 7 6 5 4 1,2 2 3,2
1010,0,1,10 9 8 7 6 5 4,2 2 3 1,2
1011,2,0,10 9 8 7 6 5 4 2,2 2 3 1,
1012,1,2,10 9 8 7 6 5 4 2,2 2,3 1
1013,0,2,10 9 8 7 6 5 4,2 2,3 1 2
1014,1,0,10 9 8 7 6 5 4 2,2,3 1 2
1015,2,0,10 9 8 7 6 5 4 2 3,2,1 2
1016,2,1,10 9 8 7 6 5 4 2 3,2 1,2
1017,0,1,10 9 8 7 6 5 4 2,2 1 3,2
1018,0,2,10 9 8 7 6 5 4,2 1 3,2 2
1019,1,0,10 9 8 7 6 5 4 1,2 3,2 2
1020,1,2,10 9 8 7 6 5 4 1,2,2 2 3
1021,0,2,10 9 8 7 6 5 4,2,2 2 3 1
1022,0,1,10 9 8 7 6,5 4 2,2 2 3 1
1023,0,2,10 9 8 7,5 4 2,6 2 2 3 1
```

