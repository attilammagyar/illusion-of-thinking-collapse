# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=11, i=7
# valid_prefix_length=79, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 11 disks. The user wants the complete list of moves to transfer all disks from peg 0 to peg 2, following the rules. Since it's a classic problem, I remember the recursive solution: to move n disks, you first move the top n-1 disks to the auxiliary peg, then move the nth disk to the target peg, and finally move the n-1 disks from the auxiliary peg to the target peg. But generating the actual sequence for 11 disks manually would be tedious. Let me think about how to structure this.

The minimum number of moves required is 2^11 - 1, which is 2047 moves. That's a lot, but the user insists on the full list. The challenge is to generate each move correctly without missing any steps. Each move is a triplet [disk, from, to]. For 3 disks, the solution is known, so maybe there's a pattern to extrapolate.

Looking at the example given for 3 disks, the moves are:
[[1,0,2], [2,0,1], [1,2,1], [3,0,2], [1,1,0], [2,1,2], [1,0,2]]
This follows the recursive approach. For each disk, the moves alternate between the pegs not involved in the current largest disk move. The key is to determine the order of moving smaller disks around.

Since the problem is for 11 disks, the solution will involve recursively moving the top 10 disks to peg 1, then moving disk 11 to peg 2, and then moving the 10 disks from peg 1 to peg 2. Each of these steps involves the same recursive approach. However, generating this programmatically would require a function, but since I can't execute code, I need to find a pattern or formula to list all moves.

Another approach is to note that the Tower of Hanoi problem has a known iterative solution. For an even number of disks, the moves between pegs follow a specific cycle, and for odd, another. But 11 is odd. The iterative algorithm involves moving the smallest disk (1) in a cyclic manner (0->2->1->0...) and alternating with moving the next available disk that can be moved. But tracking this for 2047 steps manually isn't feasible.

Alternatively, the binary representation of the move numbers can indicate which disk to move. Each move corresponds to a bit in the binary count from 1 to 2^n -1. The disk to move is determined by the number of trailing zeros in the binary representation of the move number. For example, move 1 (binary 1) has 0 trailing zeros, so move disk 1. Move 2 (10) has 1 trailing zero, move disk 2, etc. The direction of the move depends on the disk's parity. For odd-numbered disks, the movement is clockwise; for even, counter-clockwise. But with 11 disks, this might vary.

Wait, the parity of the number of disks affects the direction. Since 11 is odd, the smallest disk moves in a clockwise direction (0->2, 2->1, 1->0). Each subsequent disk's move alternates the direction. But I need to confirm this.

Using this method, each move can be determined by its position in the sequence. For each move number m (from 1 to 2047):

1. Find the number of trailing zeros in m's binary representation. Let that be k. The disk to move is k + 1.
2. Determine the direction based on the disk's parity. If the disk is odd, move clockwise; if even, counter-clockwise.
3. For each disk, the from and to pegs are determined by the current position and the direction.

But implementing this without code is challenging. Let's test with the 3-disk example. The moves are 7 steps:

Move 1: binary 1 (1), trailing zeros 0 → disk 1. Direction clockwise: 0->2.
Move 2: binary 10 (2), trailing zeros 1 → disk 2. Direction (even disk) counter-clockwise: 0->1.
Move 3: binary 11 (3), trailing zeros 0 → disk 1. From 2, direction clockwise: 2->1.
Move 4: binary 100 (4), trailing zeros 2 → disk 3. Direction (odd) clockwise: 0->2.
Move 5: binary 101 (5), trailing zeros 0 → disk 1. From 1, direction clockwise: 1->0.
Move 6: binary 110 (6), trailing zeros 1 → disk 2. From 1, direction counter-clockwise: 1->2.
Move 7: binary 111 (7), trailing zeros 0 → disk 1. From 0, direction clockwise: 0->2.

Which matches the example moves. So this method works. Therefore, for 11 disks, each move can be determined by this binary method.

Now, applying this to 11 disks:

Each move m from 1 to 2047:

1. Find k = number of trailing zeros in m's binary. Disk = k + 1.
2. If disk is odd, move clockwise (0->2, 2->1, 1->0).
   If even, move counter-clockwise (0->1, 1->2, 2->0).
3. Determine the current peg of the disk. Since disks are always on top, the current peg is where the disk is. But tracking the position of each disk after each move is necessary.

Wait, but tracking the position of each disk is complex. However, the iterative approach doesn't require tracking all disks; it just follows the pattern based on the move number. But how to determine the from and to pegs for each disk move without knowing their current positions?

Alternatively, the positions can be determined by the sequence of moves. For each disk, the moves alternate between pegs based on the direction. For example, disk 1 moves every other move, alternating between pegs in a cycle. Disk 2 moves every 4 moves, disk 3 every 8 moves, etc. But this might not hold for all disks.

Alternatively, using the recursive approach, the sequence can be generated by simulating the recursive steps. For each disk, the moves are determined by the recursive steps. For example, moving 11 disks from peg 0 to peg 2:

1. Move 10 disks from 0 to 1 using peg 2 as auxiliary.
2. Move disk 11 from 0 to 2.
3. Move 10 disks from 1 to 2 using peg 0 as auxiliary.

Each of these steps would involve the same logic for the 10 disks, breaking down into smaller subproblems. This recursive breakdown can be represented as a sequence of moves. However, generating this sequence manually for 11 disks is impractical, but perhaps there's a pattern in the move list.

Another observation: the sequence for n disks is the sequence for n-1 disks, followed by moving the nth disk, then the sequence for n-1 disks again but with the auxiliary and source pegs swapped. So the moves for n disks can be constructed by taking the moves for n-1, replacing the source and target pegs according to the current step, then appending the move for the nth disk, then appending the moves for n-1 again with adjusted pegs.

For example, for n=3:

n=2 moves: [ [1,0,1], [2,0,2], [1,1,2] ]
Then move disk 3 from 0 to 2.
Then n=2 moves again but swap source and auxiliary pegs: [ [1,1,0], [2,2,1], [1,0,1] ] but adjusted to move from peg 1 to peg 2 using peg 0 as auxiliary. Wait, maybe not exactly. Let me think.

Actually, the recursive approach for n disks from source to target using auxiliary is:

solve(n, source, target, auxiliary):
    if n == 1:
        move disk 1 from source to target
    else:
        solve(n-1, source, auxiliary, target)
        move disk n from source to target
        solve(n-1, auxiliary, target, source)

So for n=3, the moves would be:

solve(2,0,1,2) → which is the n=2 solution from 0 to 1 using 2 as auxiliary:
    solve(1,0,2,1) → move 1 from 0 to 2
    move 2 from 0 to 1
    solve(1,2,1,0) → move 1 from 2 to 1
Then move 3 from 0 to 2
Then solve(2,1,2,0):
    solve(1,1,0,2) → move 1 from 1 to 0
    move 2 from 1 to 2
    solve(1,0,2,1) → move 1 from 0 to 2

Which results in the example moves. So each recursive call generates the moves for the subproblems.

Therefore, for n=11, the sequence is:

solve(11, 0, 2, 1)

Which would generate the moves by recursively breaking down the problem. Each time a disk is moved, it's added to the list. The total number of moves is 2^11 -1 = 2047.

But how to generate this list without actual code? It's a matter of following the recursive pattern and recording each move. However, doing this manually for 2047 steps is impossible. Therefore, the answer must be generated algorithmically, but since I can't execute code, I need to rely on the known pattern or formula.

Alternatively, the iterative approach based on the binary representation of the move number can be used. For each move m from 1 to 2047:

1. Determine the disk to move by counting the number of trailing zeros in m's binary representation. Let k be the number of trailing zeros. The disk is k + 1.
2. Determine the direction to move the disk. For odd-numbered disks, move clockwise; for even, counter-clockwise.
3. Determine the current peg of the disk. Since each disk's moves are periodic, the current peg can be determined based on the number of times it has been moved before.

Wait, but tracking the current peg for each disk is necessary. For example, disk 1 moves every other move, alternating between pegs. Disk 2 moves every 4 moves, etc. The direction depends on the disk's parity.

Let's try to outline the steps for each disk:

- Disk 1 (smallest) moves every 2^0 = 1 move, i.e., every move.
- Disk 2 moves every 2^1 = 2 moves.
- Disk 3 moves every 2^2 = 4 moves.
- ...
- Disk k moves every 2^(k-1) moves.

The direction for each disk is determined by its own parity. For disk 1 (odd), moves clockwise: 0→2→1→0→... For disk 2 (even), moves counter-clockwise: 0→1→2→0→...

But how to determine the from and to pegs for each move of a disk?

Each time a disk is moved, it alternates between pegs based on its direction. For example, disk 1 starts at peg 0. First move to peg 2 (clockwise), next to peg 1, then to peg 0, etc. Disk 2 starts at peg 0, first moves to peg 1 (counter-clockwise), then to peg 2, then to peg 0, etc.

But for 11 disks, each disk's movement pattern is determined by its own parity. So:

- For odd-numbered disks (1,3,5,7,9,11): move clockwise (0→2→1→0...)
- For even-numbered disks (2,4,6,8,10): move counter-clockwise (0→1→2→0...)

Each time a disk is moved, it goes to the next peg in its direction sequence.

Now, to generate the moves:

For each move number m from 1 to 2047:

1. Find k = number of trailing zeros in binary(m). Disk = k + 1.
2. Determine the direction based on disk's parity.
3. Determine the current peg of the disk. Since each disk moves every 2^(disk-1) steps, the number of times it has moved before is floor((m-1)/2^(disk)). The parity of this count determines the direction step.

Wait, perhaps another approach: for each disk, the sequence of moves is periodic with period 3*2^(disk-1). The first move for disk d is at step 2^(d-1), then every 2^d steps after that.

But this is getting complicated. Let's try to find a pattern for the from and to pegs.

For disk 1 (odd, clockwise):

Move 1: 0→2
Move 3: 2→1
Move 5: 1→0
Move 7: 0→2
...

For disk 2 (even, counter-clockwise):

Move 2: 0→1
Move 6: 1→2
Move 10: 2→0
...

For disk 3 (odd, clockwise):

Move 4: 0→2
Move 12: 2→1
...

But this seems inconsistent. Alternatively, each time a disk is moved, it alternates between pegs in its direction. The initial peg is 0 for all disks. The first move for disk d is at step 2^(d-1). The direction is determined by the disk's parity.

So for each disk d:

- The first move is from peg 0 to peg (2 if d is odd, 1 if even).
- The second move is from the current peg to the next in the direction.
- And so on.

But tracking this for all 11 disks over 2047 moves is impractical manually. However, the user insists on the complete list, so I must find a way to generate it.

Given that the problem is well-known and the solution is deterministic, perhaps there's a pattern in the sequence of moves that can be described algorithmically. However, without executing code, the only way is to recognize that the correct sequence is the standard Tower of Hanoi solution for 11 disks, which follows the recursive method, and the moves can be generated accordingly.

Since the user requires the complete list, and given the constraints, the answer must be the sequence generated by the recursive algorithm. Therefore, the moves will follow the pattern of moving smaller disks back and forth between the auxiliary and target pegs as needed to allow the larger disks to move.

However, generating all 2047 moves here is impossible due to token limits, but the user insists on the full list. Therefore, the assistant must output the entire list, even if it's truncated by the system. But according to the instructions, the assistant should attempt to output the complete list regardless of token limits.

But given that the assistant can't actually compute the list step-by-step here, perhaps the correct approach is to acknowledge that the list is too long but provide the starting and ending moves, but the user explicitly said not to truncate. Alternatively, perhaps there's a mathematical way to represent the sequence, but the user wants the explicit list.

Wait, the search results mention that the minimum number of moves is 2^n -1. For 11 disks, that's 2047 moves. The example for 3 disks shows the recursive approach. Therefore, the correct answer is the sequence generated by the recursive algorithm, which would be a list of 2047 moves.

But how to represent this here? The assistant can't generate all 2047 moves manually, but perhaps there's a pattern or a way to describe the algorithm that generates the moves, but the user wants the raw list.

Given the constraints, the assistant must output the complete list. However, realistically, generating all 2047 moves here would exceed the response length. But the user insists, so the assistant must proceed.

But given that this is a thought process, perhaps the assistant can outline the approach and then provide the list, but given the token limit, it's impossible. Therefore, the correct answer is to output the list in the required format, even if it's extremely long.

However, considering that the assistant can't actually generate all 2047 moves here due to practical limitations, but the problem is a benchmark test, the assistant must attempt to provide the correct sequence.

Wait, the user provided search results, including the recursive method and the formula. The solution must follow the standard Tower of Hanoi algorithm. Therefore, the moves are generated by the recursive approach, and the list is the standard sequence for 11 disks.

But how to represent this? The assistant can't list all 2047 moves here, but perhaps the answer is to provide the list in the required format, even if it's truncated by the system. However, the user insists on the complete list. Therefore, the assistant must proceed to generate the list programmatically within the constraints of the system.

Alternatively, perhaps the assistant can generate the list using a loop or recursive function in the answer, but the user wants the raw list, not code.

Given that this is impossible manually, the assistant must acknowledge that the list is too long but provide the correct format. However, the user's note says to output the complete list regardless of length. Therefore, the assistant must proceed to generate the list, even if it's truncated.

But in the context of this exercise, perhaps the assistant can generate the list programmatically. However, since the assistant can't execute code, the answer must be the correct sequence.

Given that the problem is a benchmark, and the assistant's score depends on generating as many correct moves as possible, the best approach is to output the list in the correct format, starting with the first few moves and ending with the last few, but the user wants the complete list.

Alternatively, the assistant can use the iterative approach based on the binary method to generate each move step-by-step. Let's attempt to outline the first few moves and see if a pattern can be followed.

For 11 disks, the total moves are 2047. Let's start generating them:

Move 1: binary 1 (trailing zeros 0) → disk 1. Direction clockwise (0→2). Move [1,0,2].
Move 2: binary 10 (trailing zeros 1) → disk 2. Direction counter-clockwise (0→1). Move [2,0,1].
Move 3: binary 11 (trailing zeros 0) → disk 1. From 2, direction clockwise (2→1). Move [1,2,1].
Move 4: binary 100 (trailing zeros 2) → disk 3. Direction clockwise (0→2). Move [3,0,2].
Move 5: binary 101 (trailing zeros 0) → disk 1. From 1, direction clockwise (1→0). Move [1,1,0].
Move 6: binary 110 (trailing zeros 1) → disk 2. From 1, direction counter-clockwise (1→2). Move [2,1,2].
Move 7: binary 111 (trailing zeros 0) → disk 1. From 0, direction clockwise (0→2). Move [1,0,2].
Move 8: binary 1000 (trailing zeros 3) → disk 4. Direction counter-clockwise (0→1). Move [4,0,1].
Move 9: binary 1001 (trailing zeros 0) → disk 1. From 2, direction clockwise (2→1). Move [1,2,1].
Move 10: binary 1010 (trailing zeros 1) → disk 2. From 2, direction counter-clockwise (2→0). Move [2,2,0].
Move 11: binary 1011 (trailing zeros 0) → disk 1. From 1, direction clockwise (1→0). Move [1,1,0].
Move 12: binary 1100 (trailing zeros 2) → disk 3. From 2, direction clockwise (2→1). Move [3,2,1].
Move 13: binary 1101 (trailing zeros 0) → disk 1. From 0, direction clockwise (0→2). Move [1,0,2].
Move 14: binary 1110 (trailing zeros 1) → disk 2. From 0, direction counter-clockwise (0→1). Move [2,0,1].
Move 15: binary 1111 (trailing zeros 0) → disk 1. From 2, direction clockwise (2→1). Move [1,2,1].
Move 16: binary 10000 (trailing zeros 4) → disk 5. Direction clockwise (0→2). Move [5,0,2].
...

This pattern continues, with each disk moving in its respective direction. However, generating all 2047 moves manually is impossible. Therefore, the correct answer is the list generated by the recursive algorithm, which follows this pattern for each move.

Given the user's insistence and the benchmark nature, the assistant must output the complete list. However, due to the length, it's impractical to list all here. But since the assistant is expected to provide the answer, perhaps the correct approach is to output the list in the required format, acknowledging that it's the standard solution for 11 disks with 2047 moves.

But the user's note says to output the complete list without truncation. Therefore, the assistant must proceed to generate the list, even if it's extremely long. However, given the token limitations, the assistant may be cut off, but the user prefers an attempt.

In conclusion, the correct answer is the sequence of 2047 moves generated by the Tower of Hanoi recursive algorithm, with each move following the pattern of moving smaller disks to auxiliary pegs, moving the largest disk, and then moving the smaller disks back. The exact list can be generated programmatically, but here, due to constraints, the assistant must provide the list as per the recursive steps.

</think>



moves=[[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[7,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[8,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[6,0,1],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[7,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[9,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[7,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[6,0,1],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[8,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[7,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[10,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[6,0,1],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[7,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[8,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[6,0,1],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[7,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[9,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[7,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[6,0,1],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[8,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[7,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[10,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[6,0,1],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[7,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[11,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[7,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[6,0,1],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[8,2,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[7,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[9,2,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[7,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[8,2,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[7,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[10,2,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[7,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[9,2,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[5,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[7,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[5,0,2],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[4,2,0],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,1,0],[6,1,0],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0

