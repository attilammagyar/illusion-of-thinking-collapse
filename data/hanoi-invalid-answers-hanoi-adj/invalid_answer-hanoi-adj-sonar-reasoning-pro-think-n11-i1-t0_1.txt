# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=11, i=1
# valid_prefix_length=15, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 11 disks. The user wants the complete list of moves to transfer all disks from peg 0 to peg 2, following the standard rules. Since it's 11 disks, which is an odd number, I remember from the search results that the smallest disk (disk 1) moves in a specific cycle. For an odd number of disks, the smallest disk cycles through pegs in the order 0 → 2 → 1 → 0, and so on. 

The optimal solution requires 2^11 - 1 moves, which is 2047 steps. That's a lot, but the user insists on the full list. The Gray code method mentioned in the sources might help here. Each move corresponds to a bit change in the Gray code sequence, indicating which disk to move. The disk to move is determined by the number of times the move number can be divided by 2. 

Wait, the formula from the search result says the ordinal of the disk to move during move m is the number of times m can be divided by 2. So for each move number (starting from 1), we divide by 2 until it's odd, and the count gives the disk number (starting from 0). But since our disks are numbered 1 to 11, maybe we need to adjust by adding 1. Hmm, need to be careful here.

Also, the direction to move the smallest disk depends on whether the total number of disks is even or odd. Since 11 is odd, the smallest disk moves in the order 0 → 2 → 1 → 0, etc. For other disks, there's only one valid move each time. 

Let me outline the steps. For each move from 1 to 2047:
1. Determine which disk to move by finding the number of trailing zeros in the binary representation of the move number. That gives the disk number (starting from 0, so add 1 to get the disk ID).
2. For the smallest disk (disk 1), follow the cycle 0 → 2 → 1 → 0...
3. For other disks, there's only one possible peg to move to, based on the current positions.

But generating all 2047 moves manually is impractical. However, there's a recursive pattern. The standard solution for n disks involves moving n-1 disks to the auxiliary peg, then moving the nth disk to the target, then moving the n-1 disks onto the target. But since the user wants the explicit list, I need to generate it programmatically.

Alternatively, using the iterative approach based on the Gray code method. Each move corresponds to a binary-reflected Gray code increment, where only one bit changes each time. The position of the changed bit indicates which disk to move. For each move, the disk to move is the position of the rightmost 1 in the binary representation of the move number. Wait, maybe that's another way to look at it.

Wait, the search result [1] mentions that in the Gray code solution, the bit changed each move corresponds to the disk to move. The least significant bit is the smallest disk. So for each move m (starting from 1), convert m to binary, find the rightmost 1's position, which gives the disk number (starting from 0 for the smallest). Then, for the direction, since there are 11 disks (odd), the smallest disk moves 0→2→1→0..., and other disks have only one possible move.

But how to determine the direction for each disk. For even-numbered disks (assuming disk 1 is the smallest), maybe the direction alternates differently. Wait, perhaps the parity of the disk number affects the direction. Alternatively, the standard iterative algorithm for Tower of Hanoi alternates moving the smallest disk and then the only other possible move.

Alternatively, the iterative approach steps are:
1. Move the smallest disk to the next peg in the cycle (0→2→1→0... for odd disks).
2. Make the only valid move that doesn't involve the smallest disk.

Repeating these two steps until all disks are moved. This would generate the correct sequence.

But to generate the exact list, I need to simulate each move. Let's try to outline the first few moves for 3 disks and see if it matches the example given.

For 3 disks (n=3, odd), the moves are:
1. Move disk 1 from 0 to 2
2. Move disk 2 from 0 to 1
3. Move disk 1 from 2 to 1
4. Move disk 3 from 0 to 2
5. Move disk 1 from 1 to 0
6. Move disk 2 from 1 to 2
7. Move disk 1 from 0 to 2

Which matches the example provided. So the pattern is that after every move of a non-smallest disk, the smallest disk moves in its cycle. 

Applying this to 11 disks, the process would be similar but much longer. Each move alternates between moving the smallest disk and the next possible disk. However, generating all 2047 moves manually is not feasible here. But since the user requires the complete list, I need to find a way to generate it algorithmically.

Alternatively, using the recursive approach, the sequence can be generated by recursively moving n-1 disks, then the nth disk, then n-1 again. For 11 disks, this would involve a lot of steps, but perhaps there's a pattern to the moves.

Wait, the recursive solution for moving n disks from source to target using auxiliary is:
- Move n-1 disks from source to auxiliary using target.
- Move disk n from source to target.
- Move n-1 disks from auxiliary to target using source.

Each of these steps would involve recursive calls. The total number of moves is 2^n -1. For 11 disks, 2047 moves.

But to generate the exact list, I need to simulate this recursion. However, without writing code, it's challenging to list all moves. But perhaps there's a pattern in the moves that can be described.

Alternatively, using the binary representation method. Each move corresponds to a binary digit, and the disk to move is determined by the number of trailing zeros in the move number's binary representation. For example, move 1 in binary is 1, which has 0 trailing zeros, so disk 1 (since trailing zeros count gives the disk number, starting from 0, so disk 0 would be the smallest? Wait, the search result [1] says "the ordinal of the disk to be moved during move m is the number of times m can be divided by 2." So for move m, divide m by 2 until it's odd, the number of divisions is the disk number (starting from 0). For example, move 1: 1 divided by 2 once gives 0.5, so 0 divisions, disk 0 (smallest). Move 2: 2/2=1 (one division), so disk 1. Move 3: 3 is odd, 0 divisions, disk 0. Move 4: 4/2=2, /2=1, two divisions, disk 2. So disk number is (number of times m can be divided by 2).

But the disks are numbered from 1 to 11, so disk 0 would correspond to disk 1 in the problem. Wait, the problem states disks are numbered 1 (smallest) to 11 (largest). So the disk to move is (number of divisions) + 1. For example, in the example with 3 disks, move 1: 1 divided by 2 zero times, so disk 0 (but in the problem, disk 1). So perhaps the disk ID is (number of divisions) + 1. That makes sense.

So for each move m (starting at 1), the disk to move is (trailing zeros in binary m) + 1. Then, the direction for the smallest disk (disk 1) is determined by the parity of the number of disks. Since 11 is odd, the cycle is 0→2→1→0→2→1...

For other disks, the direction depends on the disk's size parity. Wait, perhaps for even-numbered disks (like disk 2, 4, etc.), the movement direction is different. Alternatively, after moving a larger disk, the next move for the smaller disks is determined by the remaining pegs.

Alternatively, the direction for non-smallest disks is determined by the only valid move available, which is to the peg that is neither the source nor the target of the previous large disk move.

This is getting complicated. Let's try to outline the algorithm steps:

1. For each move from 1 to 2047:
   a. Determine the disk to move: count the number of trailing zeros in the binary representation of m. That gives k. Disk to move is k + 1.
   b. For disk 1 (smallest), move it in the cycle 0→2→1→0...
   c. For other disks, determine the possible pegs to move to. Since a larger disk can't be on a smaller one, the disk can only move to the peg that is not the source and where the top disk is larger than the current disk.

But how to track the current positions of all disks? That's the challenge. Without tracking, it's impossible to generate the moves. However, the Gray code method might abstract this by using the parity of the disk number to determine direction.

Wait, the search result [1] mentions that for the smallest disk, the direction cycles based on the number of disks. For odd n, the cycle is f→t→r→f..., where f is the source (0), t is the target (2), and r is the auxiliary (1). So for each move of the smallest disk, it alternates between pegs in that order.

For other disks, there's only one valid move. For example, after moving the smallest disk, the next move must involve the next available disk, which can only move to one peg.

But to generate the exact sequence, perhaps the iterative approach is as follows:

- Initialize the pegs: all disks on peg 0.
- For each move from 1 to 2^11 -1:
   - Determine the disk to move using the trailing zero count method.
   - If it's the smallest disk (disk 1), move it to the next peg in the cycle (0→2→1→0...).
   - Else, determine the other two pegs and move the disk to the peg where it can be placed on top of a larger disk.

But tracking the positions of all disks is necessary. Since I can't track all 11 disks' positions manually, I need a systematic way.

Alternatively, using the recursive approach, the moves can be generated by the following pattern:

For moving n disks from source to target using auxiliary:
- If n == 1, move disk 1 from source to target.
- Else:
   - Move n-1 disks from source to auxiliary using target.
   - Move disk n from source to target.
   - Move n-1 disks from auxiliary to target using source.

This recursive approach will generate the correct sequence. For 11 disks, this would involve a lot of recursive steps, but the pattern is consistent.

Let's try to see the pattern for n=3 as in the example:

Moves for n=3 from peg 0 to peg 2:
1. Move 1 from 0 to 2
2. Move 2 from 0 to 1
3. Move 1 from 2 to 1
4. Move 3 from 0 to 2
5. Move 1 from 1 to 0
6. Move 2 from 1 to 2
7. Move 1 from 0 to 2

Which matches the example. The recursive approach works. So for n=11, the sequence would follow the same pattern but with many more steps.

However, generating all 2047 moves manually is impossible here. But the user insists on the complete list. Since the problem is a benchmark, the assistant must output the full list. But how?

Perhaps the assistant can generate the list programmatically using the recursive approach and then output it. However, without executing code, the assistant must rely on known patterns or formulas.

Alternatively, the assistant can recognize that the optimal solution for 11 disks requires 2047 moves, and the sequence follows the standard Tower of Hanoi recursive solution. The exact moves can be generated by following the recursive steps, but enumerating them all here is impractical. However, the user insists, so the assistant must proceed.

Given the constraints, the assistant will generate the list of moves using the standard recursive algorithm, ensuring that each move is correctly ordered. The moves will alternate between moving the smallest disk and the next available disk, following the Tower of Hanoi rules.

The final answer will be a list of 2047 moves, each specifying the disk number, source peg, and target peg. The list starts with moving disk 1 from peg 0 to peg 2, then disk 2 from peg 0 to peg 1, and so on, following the recursive pattern.

</think>



moves=[[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[8,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[9,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[8,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[10,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[8,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[9,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[8,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,0,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[11,0,2],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1

