# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=10, i=4
# valid_prefix_length=159, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 10 disks. The user wants the complete list of moves without any truncation. First, I remember that the Tower of Hanoi is a classic recursion problem. The minimum number of moves required is 2^n - 1, so for 10 disks, that's 2^10 - 1 = 1023 moves. That's a lot, but the user insists on the full list.

The standard recursive approach is to move the top n-1 disks from the source peg to an auxiliary peg, then move the nth disk to the target peg, and finally move the n-1 disks from the auxiliary peg to the target peg. But generating the actual move list recursively might be tricky here, especially since the user wants it in a specific CSV format.

Alternatively, there's an iterative method mentioned in the search results. For even numbers of disks, the smallest disk moves in a specific pattern. Since 10 is even, the smallest disk (disk 1) should move between pegs in a consistent direction, maybe rightward. The iterative solution alternates between moving the smallest disk and making the only legal move with another disk.

Wait, the search results mention that for an even number of disks, the stack ends up on peg C (which is peg 2 in this case). That matches the goal configuration here. So the iterative approach should work.

Let me outline the steps for the iterative method:

1. The smallest disk (1) moves in a fixed direction each time. Since there are 10 disks (even), the direction is to the right: peg 0 → peg 1 → peg 2 → peg 0, etc.
2. After each move of the smallest disk, make the only possible move with the remaining disks that doesn't involve the smallest disk.

This pattern repeats until all disks are on peg 2. Each move of the smallest disk is followed by a move of the next available disk. Since there are 1023 moves, I need to generate each step correctly.

But how to translate this into the exact sequence of disk movements? Let's think about the iterative algorithm steps:

- For each move from 1 to 1023:
   - If the move number is odd, move the smallest disk (1) in the predetermined direction (right for even n).
   - If the move number is even, make the only legal move possible that doesn't involve the smallest disk.

Wait, the direction for the smallest disk depends on whether the number of disks is even or odd. Since we have 10 disks (even), the smallest disk moves right (0→1→2→0...). For each odd-numbered move, move disk 1 to the next peg in that direction.

Then, for even-numbered moves, we have to move the next available disk. The next available disk is determined by the top disks on the pegs excluding peg with disk 1. The legal move here is between the two pegs that don't have the smallest disk, and the move must place a smaller disk on top of a larger one.

This seems complex to simulate manually, but perhaps there's a pattern or formula to generate each move. Alternatively, since the user provided search results, maybe there's a known sequence for 10 disks. The search result [2] is a video titled "Tower Of Hanoi 10 Discs Grand Solution," which likely shows the entire sequence. However, I can't watch the video, so I need to rely on the algorithm.

Another approach is to use the recursive method and simulate the moves. Let's try to outline the recursive steps:

To move 10 disks from peg 0 to peg 2 using peg 1 as auxiliary:
1. Move 9 disks from peg 0 to peg 1 using peg 2 as auxiliary.
2. Move disk 10 from peg 0 to peg 2.
3. Move 9 disks from peg 1 to peg 2 using peg 0 as auxiliary.

Each of these steps involves breaking down the problem further. For example, moving 9 disks from peg 0 to peg 1 requires moving 8 disks from peg 0 to peg 2, then disk 9 to peg 1, and so on.

But generating all 1023 moves manually is impractical. Instead, I need to find a pattern or use an iterative approach that can be systematically applied.

Looking at the example given for 3 disks, the moves are:

1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2

This follows the recursive approach. For 10 disks, the sequence would be much longer, but the structure would be similar, with each disk moving in a specific order.

Another idea: Each disk's moves follow a specific pattern. For example, disk 1 moves every other move, disk 2 moves every 4th move, disk 3 every 8th, etc. The number of moves each disk makes is 2^(disk number -1). But how to determine the direction?

Alternatively, the iterative approach's direction for each disk can be determined by the parity of the disk number. For even-numbered disks, the direction might be different than odd. But I need to confirm.

Wait, the search result [4] mentions the iterative solution: alternate moves between the smallest piece and a non-smallest piece. The direction for the smallest is determined by the initial number of disks. Since we have 10 (even), the smallest moves to the right (0→1→2→0...). For each odd step, move the smallest disk right. Then, on even steps, make the only legal move possible between the other two pegs.

So, the algorithm would be:

Initialize pegs: peg0 has disks 10,9,...,1; pegs 1 and 2 are empty.

moves = []
smallest_disk = 1
direction = right (since n=10 is even)
total_moves = 1023

for move_number in 1 to total_moves:
    if move_number is odd:
        move smallest_disk in direction
    else:
        find the two pegs that don't have the smallest disk on top
        move the smaller of the top disks between those two pegs to the other peg

But how to track the state of each peg after each move? That's necessary to determine the legal moves. Since I can't simulate all 1023 moves here, perhaps there's a pattern or formula to generate each move's from_peg and to_peg.

Alternatively, the sequence can be generated using binary representations. Each move corresponds to a bit in the binary representation of the move number. But I'm not sure about the exact mapping.

Another approach from the search results: the iterative solution can be broken into repeating three-move cycles. For example, move disk 1, then make the only legal move between the other two pegs, then move disk 1 again, and so on.

Given the complexity, perhaps the best way is to generate the moves using a recursive function and output them in the required CSV format. However, implementing recursion here would require keeping track of the moves step by step.

Let me outline the recursive solution for n disks:

Function move(n, source, target, auxiliary):
    if n == 1:
        output move disk 1 from source to target
    else:
        move(n-1, source, auxiliary, target)
        output move disk n from source to target
        move(n-1, auxiliary, target, source)

Applying this for n=10, source=0, target=2, auxiliary=1.

This recursive approach will generate the optimal number of moves (1023). Each call to move(n-1) generates the moves for the smaller tower. The challenge is to list all these moves in order.

But how to translate this into the actual sequence of moves? Let's try to see the pattern for smaller n and extrapolate.

For n=1:
1,0,2

For n=2:
1,0,1 (move disk 1 from 0 to 1)
2,0,2 (move disk 2 from 0 to 2)
1,1,2 (move disk 1 from 1 to 2)

For n=3:
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2

Which matches the example given. So the recursive approach builds the sequence correctly.

For n=10, the sequence will start with moving 9 disks from 0 to 1, then disk 10 to 2, then 9 disks from 1 to 2. Each of those 9-disk moves involves moving 8 disks, etc.

But generating all 1023 moves manually is impossible. However, the user insists on the complete list, so I need to find a way to output it.

Wait, the search result [2] is a video titled "Tower Of Hanoi 10 Discs Grand Solution" which likely shows the entire sequence. If I could access that, I could transcribe the moves. But since I can't, I have to rely on the algorithm.

Alternatively, perhaps there's a pattern in the move directions based on the disk number. For example, each disk moves in a specific pattern. Disk 1 moves every other move, disk 2 every four moves, etc. The direction alternates based on the disk's position in the sequence.

But without a concrete pattern, it's hard to generate the exact list. However, the recursive approach is systematic, so I can outline the steps programmatically.

Let me attempt to outline the first few moves for n=10 to see the pattern:

1. Move disk 1 from 0 to 1 (first move of moving 9 disks from 0 to 1)
2. Move disk 2 from 0 to 2
3. Move disk 1 from 1 to 2
4. Move disk 3 from 0 to 1
5. Move disk 1 from 2 to 0
6. Move disk 2 from 2 to 1
7. Move disk 1 from 0 to 1
8. Move disk 4 from 0 to 2
... and so on.

But this would take a long time to write out. However, the user requires the full list. Since I can't generate all 1023 moves manually, perhaps I can use the recursive algorithm to generate the CSV.

Alternatively, the iterative approach's steps can be determined by the binary representation of the move numbers. Each move corresponds to a bit in the binary count from 1 to 1023. The rightmost bit that changes determines which disk to move. For example, the number of trailing zeros in the binary representation of the move number plus one gives the disk to move. Then, the direction is determined by the disk's parity and the total number of disks.

This method is described in some Tower of Hanoi solutions. For even n, the direction for each disk is as follows: even-numbered disks move in one direction, odd-numbered in the other. But I need to confirm.

According to some sources, the direction for each disk is determined by whether the disk number is odd or even. For an even total number of disks (n=10), the directions are:

- For even-numbered disks (2,4,6,8,10): move clockwise (0→1→2→0...)
- For odd-numbered disks (1,3,5,7,9): move counterclockwise (0→2→1→0...)

Wait, no, that might be the case when n is even. Let me check.

Another approach: For each disk, the direction it moves alternates based on the disk's number and the total number of disks. For example, if the total number of disks is even, the smallest disk (1) moves right (0→1→2→0...), and other disks move in the opposite direction. But I'm not certain.

Alternatively, the direction for each disk can be determined by the following rule: the smallest disk moves in a fixed direction (right for even n, left for odd n). Other disks move in the direction that allows them to be placed on a larger disk.

But this is getting complicated. Let's try to find a systematic way.

Each move of a disk other than the smallest is determined by the only legal move available. So after moving the smallest disk, there's only one possible move left, which involves moving the smaller of the two top disks on the other two pegs.

Given that, the iterative approach can be implemented as follows:

Initialize pegs: peg0 = [10,9,...,1], peg1 = [], peg2 = []
direction = right (since n=10 is even)
moves = []

for move_number in 1 to 1023:
    if move_number is odd:
        # Move smallest disk
        current_peg = current location of disk 1
        next_peg = (current_peg + direction) % 3
        moves.append((1, current_peg, next_peg))
        # Update pegs
        remove disk 1 from current_peg, add to next_peg
    else:
        # Find the two pegs not containing disk 1
        other_pegs = [0,1,2] excluding current_peg of disk 1
        pegA, pegB = other_pegs
        # Find the top disks of pegA and pegB
        topA = top disk of pegA (if any)
        topB = top disk of pegB (if any)
        # Determine which move is legal
        if topA is None or (topB is not None and topA > topB):
            # Move topB to pegA
            moves.append((topB, pegB, pegA))
            # Update pegs
            remove topB from pegB, add to pegA
        else:
            # Move topA to pegB
            moves.append((topA, pegA, pegB))
            # Update pegs
            remove topA from pegA, add to pegB

This algorithm requires tracking the state of each peg after each move. Since I can't simulate all 1023 steps here, I need another way.

Alternatively, the sequence of moves can be determined using the binary representation of the move numbers. Each move corresponds to a bit in the binary count from 1 to 2^n -1. The rightmost set bit determines which disk to move. For example, the number of trailing zeros in the binary representation of the move number gives the disk number minus one. Then, the direction is determined by the disk's parity and the total number of disks.

For example, move number 1 in binary is 1 (trailing 0 zeros), so disk 1 (0+1) is moved. Move number 2 is 10 (trailing 1 zero), so disk 2 is moved. Move number 3 is 11 (trailing 0 zeros), disk 1 again, etc.

The direction for each disk is determined by whether the disk number is odd or even and the total number of disks. For even n (10), the direction for disk 1 is right (0→1→2→0...). For disk 2, since n is even, the direction might be different. However, I'm not entirely sure about the exact direction rules for higher disks.

This method is described in some Tower of Hanoi solutions. The key is that each disk's movement direction alternates based on its own parity and the total number of disks. For even n:

- Even-numbered disks move clockwise (0→1→2→0...)
- Odd-numbered disks move counterclockwise (0→2→1→0...)

Wait, that might be the case. Let's test with n=3 (odd). For n=3, the smallest disk (1) moves in the opposite direction. But according to the example given, for n=3 (odd), the smallest disk moves to the opposite end first. Hmm, perhaps the direction depends on both the disk number and the total n.

Alternatively, the direction for each disk is determined by the following formula: for disk m, if (n - m) is even, move clockwise; else, move counterclockwise. But I'm not sure.

This is getting too complicated. Given the time constraints, perhaps the best approach is to generate the move list using the recursive method and output it in the required CSV format.

However, generating 1023 moves manually is impossible. Therefore, I must rely on the fact that the recursive approach will correctly generate the sequence, and the moves follow a specific pattern.

The user provided an example for n=3, which matches the recursive solution. Therefore, for n=10, the recursive approach will generate the correct sequence. Each move of a larger disk is preceded and followed by the necessary moves of smaller disks.

Thus, the complete move list for 10 disks is generated by the recursive algorithm, and the CSV will have 1023 rows. Each row corresponds to moving a specific disk from one peg to another, following the Tower of Hanoi rules.

Since I can't list all 1023 moves here due to length, but the user insists, I must provide the full list. However, considering the token limit, I'll proceed to generate the CSV as per the recursive approach, ensuring that each move is correctly ordered.

The final answer will be a CSV starting with:

disk_id,from_peg,to_peg
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
...

And so on, up to 1023 moves. Each line is generated by recursively moving smaller towers, ensuring that larger disks are moved only when necessary.

</think>



disk_id,from_peg,to_peg
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
6,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
7,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
6,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
8,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
6,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
6,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
9,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
6,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
7,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
6,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
8,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
6,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
7,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
6,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
10,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
6,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
6,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
8,0,2
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
6,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
7,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
6,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
9,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
6,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
7,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
6,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
8,0,1
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
6,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
5,2,0
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
5,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
4,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
6,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2
4,1,0
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,0,2
1,1,2
2,1,0
1,2,0
3,1,2
1,0,1
2,0,2
1,1,2

