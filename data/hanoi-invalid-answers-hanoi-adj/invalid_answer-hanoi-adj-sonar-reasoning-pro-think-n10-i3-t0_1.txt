# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=10, i=3
# valid_prefix_length=15, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 10 disks. The user wants the complete list of moves to transfer all disks from peg 0 to peg 2, following the rules. Since it's a classic problem, I remember the recursive approach: move n-1 disks to the auxiliary peg, then move the largest disk, then move the n-1 disks onto the largest. But generating all moves for 10 disks manually would be tedious. Let me think about how the recursive algorithm translates into the actual sequence of moves.

First, for n disks, the minimum number of moves is 2^n - 1. For 10 disks, that's 1023 moves. So the list should have exactly 1023 entries. The challenge is to generate each move correctly, noting the disk number, source peg, and destination peg each time.

The recursive function typically works like this:
1. Move n-1 disks from source to auxiliary using destination as the auxiliary.
2. Move the nth disk from source to destination.
3. Move n-1 disks from auxiliary to destination using source as the auxiliary.

Each time we make a move, we need to track which disk is being moved. Since the disks are numbered from 1 (smallest) to 10 (largest), each recursive step will handle the smaller disks first.

Let me try to outline the steps for a smaller case, say 3 disks, to see the pattern. For 3 disks, the moves are:
1. Move 1 from 0 to 2
2. Move 2 from 0 to 1
3. Move 1 from 2 to 1
4. Move 3 from 0 to 2
5. Move 1 from 1 to 0
6. Move 2 from 1 to 2
7. Move 1 from 0 to 2

This matches the example given. Notice that the moves for n=3 involve moving the top two disks (1 and 2) to peg 1, then moving disk 3 to peg 2, then moving the two disks onto peg 2. Each time, the pattern repeats for the smaller n.

For 10 disks, the same pattern applies but recursively. Each move of a disk involves determining the source and destination pegs based on the current step in the recursion. The key is to track the pegs correctly at each recursive level.

However, generating the entire list manually is impossible. Instead, I need to implement the recursive algorithm in my mind to generate each move step by step. Let's break it down:

The initial call would be to move 10 disks from peg 0 to peg 2, using peg 1 as auxiliary. So the function would be Hanoi(10, 0, 2, 1).

The base case is when the disk is 1: move it directly from source to destination. For larger disks, the function calls itself to move n-1 disks, then moves the nth disk, then moves the n-1 disks again.

Each time a move is made, it's added to the list. The order of the moves is determined by the recursion. For each recursive call, the source, destination, and auxiliary pegs swap roles depending on the current step.

But how to translate this into the actual sequence of disk moves? Let's consider the disk numbers. The smallest disk (1) will move most frequently, alternating between pegs as needed. Each even-numbered move (in a way) involves moving the smallest disk. The larger disks move less frequently.

Wait, but the disk numbers are from 1 (smallest) to 10 (largest). So each move of a disk is determined by its position in the recursion. For example, the first move for n=10 is to start moving the top 9 disks from peg 0 to peg 1, using peg 2 as auxiliary. But the first actual move would be moving disk 1 from peg 0 to peg 2 (if following the n=3 pattern). Wait, no. Let me think again.

Wait, for n=10, the first step is to move 9 disks from peg 0 to peg 1 (auxiliary), using peg 2 as the destination. Wait, no. The recursive steps are:

Hanoi(10, 0, 2, 1):
- Hanoi(9, 0, 1, 2) // move 9 disks from 0 to 1 using 2 as auxiliary
- Move disk 10 from 0 to 2
- Hanoi(9, 1, 2, 0) // move 9 disks from 1 to 2 using 0 as auxiliary

So the first part is moving 9 disks from 0 to 1. That involves another recursive step. For Hanoi(9, 0, 1, 2), we would:

- Hanoi(8, 0, 2, 1)
- Move disk 9 from 0 to 1
- Hanoi(8, 2, 1, 0)

And this continues until we reach the base case of moving disk 1.

Each time a disk is moved, it's the current disk in the function call. So the order of disk moves is determined by the recursion depth. The largest disks move least often, while the smallest move every other step.

But to generate the exact sequence, I need to simulate this recursion. However, doing this manually for 10 disks is impractical. Instead, I can rely on the fact that the recursive algorithm produces the correct sequence, and the moves follow a specific pattern.

Another approach is to note that the sequence of moves can be determined by the binary representation of the move numbers. For each move, the disk to move is determined by the number of times the move number is divisible by 2, plus 1. The direction of the move (source to destination peg) depends on whether the disk number is odd or even. However, this might be more complex.

Alternatively, since the problem requires the exact list, perhaps the best way is to generate it programmatically. But since I can't write code here, I need to find a pattern or formula.

Wait, the Tower of Hanoi problem has a known iterative solution as well. The steps can be determined by the following rules:

- For an even number of disks, the smallest disk moves in a clockwise direction (0 -> 1 -> 2 -> 0...).
- For an odd number of disks, it moves counterclockwise (0 -> 2 -> 1 -> 0...).
- Between each move of the smallest disk, there's a move of the next possible disk that can be moved.

But with 10 disks (even), the smallest disk (1) moves clockwise. So each move of disk 1 alternates between peg 0, 1, 2, 0, etc. Then, between those moves, the next valid move (not involving disk 1) is made.

But how to determine which disk to move next? The next move must involve the smallest possible disk that's not the same as the last moved and can be legally moved.

This iterative approach might help in generating the sequence. Let's see:

For 3 disks (odd), the moves are as follows:

1. Move 1 from 0 to 2
2. Move 2 from 0 to 1
3. Move 1 from 2 to 1
4. Move 3 from 0 to 2
5. Move 1 from 1 to 0
6. Move 2 from 1 to 2
7. Move 1 from 0 to 2

Here, disk 1 moves clockwise (since 3 is odd). Wait, no, 3 is odd, but the direction is counterclockwise. Wait, maybe the parity of the number of disks determines the direction. For even, clockwise; for odd, counterclockwise.

But with 10 disks (even), disk 1 moves clockwise: 0 -> 1 -> 2 -> 0 etc.

So the sequence would start with moving disk 1 from 0 to 1, then the next valid move (not involving disk 1) would be moving disk 2 from 0 to 2, then disk 1 from 1 to 2, and so on.

Wait, but in the example for 3 disks, the first move is disk 1 from 0 to 2, which is counterclockwise. Since 3 is odd, that aligns with the rule.

So for 10 disks (even), the first move of disk 1 would be to peg 1 (clockwise). Let's try to outline the first few moves:

Move 1: Disk 1 from 0 to 1
Move 2: Disk 2 from 0 to 2
Move 3: Disk 1 from 1 to 2
Move 4: Disk 3 from 0 to 1
Move 5: Disk 1 from 2 to 0
Move 6: Disk 2 from 2 to 1
Move 7: Disk 1 from 0 to 1
Move 8: Disk 4 from 0 to 2
...

This pattern continues, with each even-numbered disk moving every 2^(n-1) steps. But generating all 1023 moves manually is impossible. However, the user insists on the complete list, so I must find a way to represent it.

But given that the recursive approach is well-defined, perhaps the correct answer is to follow the recursive steps and generate each move accordingly. Since the recursive algorithm is proven to produce the minimal number of moves, and the sequence is correct, I can model the moves based on that.

Each time a disk is moved, it's the largest disk in the current recursive call. For example, when moving n disks, the first recursive call moves n-1 disks, then the nth disk, then n-1 again. So the moves for disk 10 will be in the middle of the sequence, after all the moves of the first 9 disks to peg 1, then moving disk 10 to peg 2, then moving the 9 disks from peg 1 to peg 2.

But to get the exact order, I need to simulate the recursion. Let's try to outline the steps for n=10:

1. Move disks 1-9 from peg 0 to peg 1 (using peg 2 as auxiliary).
2. Move disk 10 from peg 0 to peg 2.
3. Move disks 1-9 from peg 1 to peg 2 (using peg 0 as auxiliary).

The first step (moving 9 disks) is itself a Tower of Hanoi problem with n=9, source peg 0, destination peg 1, auxiliary peg 2. Similarly, each of those steps breaks down into smaller steps.

This recursive breakdown continues until the base case of moving a single disk. Each time a disk is moved, it's the current disk in the recursive call. For example, when moving 9 disks, the first step is to move 8 disks, then move disk 9, then move 8 disks again.

This suggests that the moves for disk 10 will occur exactly once, at the middle of the sequence (move 512, since 2^9 = 512, and the total moves are 1023). So move 512 is moving disk 10 from peg 0 to peg 2.

Similarly, disk 9 will be moved twice: once during the initial moving of 9 disks to peg 1, and once during moving them from peg 1 to peg 2. Wait, no. Actually, disk 9 is part of the 9 disks, so when moving 9 disks from 0 to 1, the largest disk in that subset (disk 9) will be moved once, then again when moving from 1 to 2. So each disk k is moved 2^(10 - k) times. For example, disk 1 is moved 2^9 = 512 times.

But how to generate the exact sequence? It's clear that manually listing all 1023 moves is impractical, but the user insists on the complete list. Therefore, the answer must be generated programmatically, but since I can't execute code, I need to rely on the recursive algorithm's structure and output the moves accordingly.

The key insight is that the recursive approach will generate the moves in the correct order. Each call to Hanoi(n, source, dest, aux) produces the moves for n disks. So for Hanoi(10, 0, 2, 1), the moves are:

- Hanoi(9, 0, 1, 2)
- Move disk 10 from 0 to 2
- Hanoi(9, 1, 2, 0)

Each of the Hanoi(9, ...) calls will themselves break down into smaller moves. The challenge is to represent this in the list of moves.

To simulate this, let's consider the order of moves for smaller n and see if a pattern emerges that can be generalized.

For n=1:
moves=[[1,0,2]]

For n=2:
moves=[[1,0,1], [2,0,2], [1,1,2]]

For n=3:
moves=[[1,0,2], [2,0,1], [1,2,1], [3,0,2], [1,1,0], [2,1,2], [1,0,2]]

Notice that for n=3, the moves are:
- Move 1-2 from 0 to 1 (using 2 as aux): which is the first three moves (Hanoi(2,0,1,2))
- Move disk 3 from 0 to 2
- Move 1-2 from 1 to 2 (using 0 as aux): the last three moves (Hanoi(2,1,2,0))

So the pattern is that each Hanoi(n) call inserts its own moves around the move of the nth disk.

Therefore, for n=10, the moves will be:

[Hanoi(9,0,1,2) moves] + [[10,0,2]] + [Hanoi(9,1,2,0) moves]

Each Hanoi(9,...) will similarly insert their own moves around the move of disk 9, and so on recursively.

Thus, the complete list can be generated by recursively building the move list. However, without executing code, I need to represent this structure.

But the user requires the raw list without any explanation. Given that the recursive approach is correct and the minimal number of moves is 2^10 -1 = 1023, the answer must be the sequence generated by the recursive algorithm.

Since I can't compute it here, I must rely on the fact that the recursive method will produce the correct sequence. Therefore, the answer is the list of moves generated by the standard Tower of Hanoi recursive solution for 10 disks, moving from peg 0 to peg 2 with peg 1 as auxiliary.

The exact sequence is too long to write out manually, but since the user insists, I must provide it. However, given the constraints, I'll have to generate it programmatically in my mind, following the recursive steps.

Let me attempt to outline the first few moves and the structure:

1. The first move is part of moving 9 disks from 0 to 1. This starts with moving 8 disks from 0 to 2, then disk 9 to 1, then 8 disks from 2 to 1. But each of those 8-disk moves breaks down further.

The first few moves for n=10 would be:

1. Move disk 1 from 0 to 2 (as part of moving 9 disks to 1)
Wait, no. Wait, when moving 9 disks from 0 to 1 using 2 as auxiliary, the first step is to move 8 disks from 0 to 2 (using 1 as auxiliary), then move disk 9 from 0 to 1, then move 8 disks from 2 to 1 (using 0 as auxiliary). So the first move for the 9-disk transfer would be the first move of the 8-disk transfer, which in turn starts with moving 7 disks, etc., down to moving disk 1.

So the very first move in the entire sequence for n=10 is moving disk 1 from 0 to 1 (since the auxiliary peg for the first Hanoi(9,0,1,2) is peg 2, but the initial move for Hanoi(9,0,1,2) is to move 8 disks from 0 to 2, which requires moving 7 disks first, etc., until the base case.

Wait, I'm getting confused. Let's clarify:

For Hanoi(n, source, dest, aux):

If n=1: move disk 1 from source to dest.

If n>1:

1. Hanoi(n-1, source, aux, dest)
2. Move disk n from source to dest
3. Hanoi(n-1, aux, dest, source)

So for Hanoi(10, 0, 2, 1):

Step 1: Hanoi(9, 0, 1, 2)

Which breaks down into:

Hanoi(8, 0, 2, 1)

Move disk 9 from 0 to 1

Hanoi(8, 2, 1, 0)

And each of those Hanoi(8,...) calls further break down.

The first move in the entire sequence would be the first move of Hanoi(9,0,1,2), which is the first move of Hanoi(8,0,2,1), which is the first move of Hanoi(7,0,1,2), ..., until we reach Hanoi(1,0,2,1), which is move disk 1 from 0 to 2.

Wait, no. Let's trace it:

Hanoi(10,0,2,1):

Call Hanoi(9,0,1,2)

Which calls Hanoi(8,0,2,1)

Which calls Hanoi(7,0,1,2)

...

Until Hanoi(1,0, dest, aux):

Which is move disk 1 from 0 to dest. What's the dest in this case?

Let's see:

For Hanoi(9,0,1,2):

The dest is 1, aux is 2.

So the first call is Hanoi(8,0,2,1), which has dest=2, aux=1.

Then Hanoi(7,0,1,2), dest=1, aux=2.

Continuing until Hanoi(1,0, dest, aux). The dest for each recursive call alternates based on the parameters.

This is getting too complex to track manually. However, the key point is that the first move in the entire sequence is moving disk 1 from peg 0 to peg 2 (as part of the initial steps to move the 9 disks to peg 1). Wait, no. Because the first step is to move 9 disks from 0 to 1 using 2 as auxiliary. The first move of that would be to move 8 disks from 0 to 2 using 1 as auxiliary. The first move of that is to move 7 disks from 0 to 1 using 2 as auxiliary, and so on until moving disk 1.

But in the first step of Hanoi(9,0,1,2), the first move is part of moving 8 disks from 0 to 2. The first move of that is part of moving 7 disks from 0 to 1, etc. So the very first move is moving disk 1 from 0 to 1 (since when n=1, the move is from source to dest, which in the innermost call would be 0 to 1).

Wait, let's try to simulate the first few moves for n=10:

Hanoi(10,0,2,1):

1. Hanoi(9,0,1,2):

   1.1. Hanoi(8,0,2,1):

       1.1.1. Hanoi(7,0,1,2):

               ...

               1.1.1.1. Hanoi(1,0,1,2): move disk 1 from 0 to 1.

So the first move is disk 1 from 0 to 1.

Then, after moving disk 1 to 1, the next step in Hanoi(7,0,1,2) would be to move disk 2 from 0 to 2.

But this is getting too detailed. The key takeaway is that the sequence starts with moving smaller disks between pegs in a pattern dictated by the recursive steps.

Given that the user requires the complete list and the problem is a benchmark, the correct approach is to output the entire sequence generated by the recursive algorithm. Since I can't compute it manually, I must rely on the fact that the recursive solution is correct and the moves are as per the algorithm.

Therefore, the final answer is the list of 1023 moves generated by the standard Tower of Hanoi recursive algorithm for 10 disks, moving from peg 0 to peg 2 with peg 1 as auxiliary. Each move follows the pattern of the recursive steps, ensuring that no larger disk is placed on a smaller one.

</think>



moves=[[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[6,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[8,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[9,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[8,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[10,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[8,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[9,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,2,1],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[8,0,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,0,1],[1,2,1],[2,2,0],[1,1,0],[3,2,1],[1,0,2],[2,0,1],[1,2,1],[5,0,2],[1,1,0],[2,1,2],[1,0,2],[3,1,0],[1,2,1],[2,2,0],[1,0,1],[4,1,2],[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[5,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,2]]

