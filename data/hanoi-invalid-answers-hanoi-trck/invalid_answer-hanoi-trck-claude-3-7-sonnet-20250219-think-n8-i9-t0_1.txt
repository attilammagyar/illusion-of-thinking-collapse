# model_name='claude-3-7-sonnet-20250219', reasoning_budget=32000, tries=0, n=8, i=9
# valid_prefix_length=23, is_valid_solution=0, first_correction=-1

<think>
This is the classic Tower of Hanoi puzzle with 8 disks. The minimum number of moves required to solve a Tower of Hanoi puzzle with n disks is 2^n - 1. So for 8 disks, we need 2^8 - 1 = 256 - 1 = 255 moves.

Let me think about the solution. For this puzzle, a recursive approach works well:

1. Move n-1 disks from the source (peg 0) to the auxiliary peg (peg 1) using the destination (peg 2) as the auxiliary.
2. Move the largest disk (disk n) from the source (peg 0) to the destination (peg 2).
3. Move the n-1 disks from the auxiliary peg (peg 1) to the destination (peg 2) using the source (peg 0) as the auxiliary.

Let's define a function to solve this recursively:

```python
def tower_of_hanoi(n, source, auxiliary, destination, moves=None, state=None):
    if moves is None:
        moves = []
    if state is None:
        # Initialize the state
        state = [list(range(n, 0, -1)), [], []]  # Represents [peg0, peg1, peg2]
    
    if n == 1:
        # Move disk 1 from source to destination
        disk = state[source].pop()
        state[destination].append(disk)
        moves.append((source, destination, [list(s) for s in state]))
    else:
        # Move n-1 disks from source to auxiliary using destination as helper
        tower_of_hanoi(n-1, source, destination, auxiliary, moves, state)
        
        # Move disk n from source to destination
        disk = state[source].pop()
        state[destination].append(disk)
        moves.append((source, destination, [list(s) for s in state]))
        
        # Move n-1 disks from auxiliary to destination using source as helper
        tower_of_hanoi(n-1, auxiliary, source, destination, moves, state)
    
    return moves
```

But for this specific request, we don't need to implement the full function. Let's directly generate the sequence of moves.

Let's start by generating the Tower of Hanoi solution for 8 disks:

Initial state:
- Peg 0: [8, 7, 6, 5, 4, 3, 2, 1] (bottom to top)
- Peg 1: []
- Peg 2: []

I'll now enumerate all the moves required to solve this puzzle:

Move 1: Disk 1 from peg 0 to peg 2
State after move:
- Peg 0: [8, 7, 6, 5, 4, 3, 2]
- Peg 1: []
- Peg 2: [1]

Move 2: Disk 2 from peg 0 to peg 1
State after move:
- Peg 0: [8, 7, 6, 5, 4, 3]
- Peg 1: [2]
- Peg 2: [1]

Move 3: Disk 1 from peg 2 to peg 1
State after move:
- Peg 0: [8, 7, 6, 5, 4, 3]
- Peg 1: [2, 1]
- Peg 2: []

Move 4: Disk 3 from peg 0 to peg 2
State after move:
- Peg 0: [8, 7, 6, 5, 4]
- Peg 1: [2, 1]
- Peg 2: [3]

Move 5: Disk 1 from peg 1 to peg 0
State after move:
- Peg 0: [8, 7, 6, 5, 4, 1]
- Peg 1: [2]
- Peg 2: [3]

Move 6: Disk 2 from peg 1 to peg 2
State after move:
- Peg 0: [8, 7, 6, 5, 4, 1]
- Peg 1: []
- Peg 2: [3, 2]

Move 7: Disk 1 from peg 0 to peg 2
State after move:
- Peg 0: [8, 7, 6, 5, 4]
- Peg 1: []
- Peg 2: [3, 2, 1]

Move 8: Disk 4 from peg 0 to peg 1
State after move:
- Peg 0: [8, 7, 6, 5]
- Peg 1: [4]
- Peg 2: [3, 2, 1]

Move 9: Disk 1 from peg 2 to peg 1
State after move:
- Peg 0: [8, 7, 6, 5]
- Peg 1: [4, 1]
- Peg 2: [3, 2]

Move 10: Disk 2 from peg 2 to peg 0
State after move:
- Peg 0: [8, 7, 6, 5, 2]
- Peg 1: [4, 1]
- Peg 2: [3]

Move 11: Disk 1 from peg 1 to peg 0
State after move:
- Peg 0: [8, 7, 6, 5, 2, 1]
- Peg 1: [4]
- Peg 2: [3]

Move 12: Disk 3 from peg 2 to peg 1
State after move:
- Peg 0: [8, 7, 6, 5, 2, 1]
- Peg 1: [4, 3]
- Peg 2: []

Move 13: Disk 1 from peg 0 to peg 2
State after move:
- Peg 0: [8, 7, 6, 5, 2]
- Peg 1: [4, 3]
- Peg 2: [1]

Move 14: Disk 2 from peg 0 to peg 1
State after move:
- Peg 0: [8, 7, 6, 5]
- Peg 1: [4, 3, 2]
- Peg 2: [1]

Move 15: Disk 1 from peg 2 to peg 1
State after move:
- Peg 0: [8, 7, 6, 5]
- Peg 1: [4, 3, 2, 1]
- Peg 2: []

Move 16: Disk 5 from peg 0 to peg 2
State after move:
- Peg 0: [8, 7, 6]
- Peg 1: [4, 3, 2, 1]
- Peg 2: [5]

Wait, I think I made a mistake. Let me restart with a more careful approach. In the Tower of Hanoi with n disks, the optimal solution follows a pattern based on disk parity:

For n=8, we alternate between:
- Moving the smallest disk (disk 1) in a fixed direction (clockwise or counterclockwise)
- Making the only legal move not involving disk 1

Let me recompute the solution more systematically:

Initial state:
- Peg 0: [8, 7, 6, 5, 4, 3, 2, 1]
- Peg 1: []
- Peg 2: []

Where the numbers represent disk sizes from bottom (left) to top (right).

For even n (which is our case with n=8), we can always move disk 1 in the sequence: 0→1→2→0→...

Move 1: Move disk 1 from peg 0 to peg 1
- Peg 0: [8, 7, 6, 5, 4, 3, 2]
- Peg 1: [1]
- Peg 2: []

Move 2: Move disk 2 from peg 0 to peg 2
- Peg 0: [8, 7, 6, 5, 4, 3]
- Peg 1: [1]
- Peg 2: [2]

Move 3: Move disk 1 from peg 1 to peg 2
- Peg 0: [8, 7, 6, 5, 4, 3]
- Peg 1: []
- Peg 2: [2, 1]

Move 4: Move disk 3 from peg 0 to peg 1
- Peg 0: [8, 7, 6, 5, 4]
- Peg 1: [3]
- Peg 2: [2, 1]

Move 5: Move disk 1 from peg 2 to peg 0
- Peg 0: [8, 7, 6, 5, 4, 1]
- Peg 1: [3]
- Peg 2: [2]

Move 6: Move disk 2 from peg 2 to peg 1
- Peg 0: [8, 7, 6, 5, 4, 1]
- Peg 1: [3, 2]
- Peg 2: []

Move 7: Move disk 1 from peg 0 to peg 1
- Peg 0: [8, 7, 6, 5, 4]
- Peg 1: [3, 2, 1]
- Peg 2: []

Move 8: Move disk 4 from peg 0 to peg 2
- Peg 0: [8, 7, 6, 5]
- Peg 1: [3, 2, 1]
- Peg 2: [4]

Move 9: Move disk 1 from peg 1 to peg 2
- Peg 0: [8, 7, 6, 5]
- Peg 1: [3, 2]
- Peg 2: [4, 1]

Move 10: Move disk 2 from peg 1 to peg 0
- Peg 0: [8, 7, 6, 5, 2]
- Peg 1: [3]
- Peg 2: [4, 1]

Move 11: Move disk 1 from peg 2 to peg 0
- Peg 0: [8, 7, 6, 5, 2, 1]
- Peg 1: [3]
- Peg 2: [4]

Move 12: Move disk 3 from peg 1 to peg 2
- Peg 0: [8, 7, 6, 5, 2, 1]
- Peg 1: []
- Peg 2: [4, 3]

Move 13: Move disk 1 from peg 0 to peg 1
- Peg 0: [8, 7, 6, 5, 2]
- Peg 1: [1]
- Peg 2: [4, 3]

Move 14: Move disk 2 from peg 0 to peg 2
- Peg 0: [8, 7, 6, 5]
- Peg 1: [1]
- Peg 2: [4, 3, 2]

Move 15: Move disk 1 from peg 1 to peg 2
- Peg 0: [8, 7, 6, 5]
- Peg 1: []
- Peg 2: [4, 3, 2, 1]

I notice that I might be mistaken about the starting configuration. Let me clarify the problem statement again.

The initial configuration is:
- Peg 0: [8, 7, 6, 5, 4, 3, 2, 1] (where 8 is at the bottom and 1 is at the top)
- Peg 1: []
- Peg 2: []

This should be represented in the format as:
- Peg 0: 8 7 6 5 4 3 2 1 (where 8 is at the bottom and 1 is at the top)
- Peg 1: (empty)
- Peg 2: (empty)

Hmm, but the prompt format lists the pegs differently:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,2,3 2,,1
```

Here, for peg0, it shows "3 2" which means disk 3 is at the bottom and disk 2 is on top. So I should adjust my representation to match this.

Initial state:
- Peg 0: 8 7 6 5 4 3 2 1 (bottom to top)
- Peg 1: (empty)
- Peg 2: (empty)

Let me carefully go through the solution step by step:

Move 1: Move disk 1 from peg 0 to peg 1
- Peg 0: 8 7 6 5 4 3 2
- Peg 1: 1
- Peg 2: (empty)

Move 2: Move disk 2 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4 3
- Peg 1: 1
- Peg 2: 2

Move 3: Move disk 1 from peg 1 to peg 2
- Peg 0: 8 7 6 5 4 3
- Peg 1: (empty)
- Peg 2: 2 1

Move 4: Move disk 3 from peg 0 to peg 1
- Peg 0: 8 7 6 5 4
- Peg 1: 3
- Peg 2: 2 1

Move 5: Move disk 1 from peg 2 to peg 0
- Peg 0: 8 7 6 5 4 1
- Peg 1: 3
- Peg 2: 2

Move 6: Move disk 2 from peg 2 to peg 1
- Peg 0: 8 7 6 5 4 1
- Peg 1: 3 2
- Peg 2: (empty)

Move 7: Move disk 1 from peg 0 to peg 1
- Peg 0: 8 7 6 5 4
- Peg 1: 3 2 1
- Peg 2: (empty)

Move 8: Move disk 4 from peg 0 to peg 2
- Peg 0: 8 7 6 5
- Peg 1: 3 2 1
- Peg 2: 4

Move 9: Move disk 1 from peg 1 to peg 2
- Peg 0: 8 7 6 5
- Peg 1: 3 2
- Peg 2: 4 1

Move 10: Move disk 2 from peg 1 to peg 0
- Peg 0: 8 7 6 5 2
- Peg 1: 3
- Peg 2: 4 1

Move 11: Move disk 1 from peg 2 to peg 0
- Peg 0: 8 7 6 5 2 1
- Peg 1: 3
- Peg 2: 4

Move 12: Move disk 3 from peg 1 to peg 2
- Peg 0: 8 7 6 5 2 1
- Peg 1: (empty)
- Peg 2: 4 3

Move 13: Move disk 1 from peg 0 to peg 1
- Peg 0: 8 7 6 5 2
- Peg 1: 1
- Peg 2: 4 3

Move 14: Move disk 2 from peg 0 to peg 2
- Peg 0: 8 7 6 5
- Peg 1: 1
- Peg 2: 4 3 2

Move 15: Move disk 1 from peg 1 to peg 2
- Peg 0: 8 7 6 5
- Peg 1: (empty)
- Peg 2: 4 3 2 1

Move 16: Move disk 5 from peg 0 to peg 1
- Peg 0: 8 7 6
- Peg 1: 5
- Peg 2: 4 3 2 1

Move 17: Move disk 1 from peg 2 to peg 0
- Peg 0: 8 7 6 1
- Peg 1: 5
- Peg 2: 4 3 2

Move 18: Move disk 2 from peg 2 to peg 1
- Peg 0: 8 7 6 1
- Peg 1: 5 2
- Peg 2: 4 3

Move 19: Move disk 1 from peg 0 to peg 1
- Peg 0: 8 7 6
- Peg 1: 5 2 1
- Peg 2: 4 3

Move 20: Move disk 3 from peg 2 to peg 0
- Peg 0: 8 7 6 3
- Peg 1: 5 2 1
- Peg 2: 4

Move 21: Move disk 1 from peg 1 to peg 2
- Peg 0: 8 7 6 3
- Peg 1: 5 2
- Peg 2: 4 1

Move 22: Move disk 2 from peg 1 to peg 0
- Peg 0: 8 7 6 3 2
- Peg 1: 5
- Peg 2: 4 1

Move 23: Move disk 1 from peg 2 to peg 0
- Peg 0: 8 7 6 3 2 1
- Peg 1: 5
- Peg 2: 4

Move 24: Move disk 4 from peg 2 to peg 1
- Peg 0: 8 7 6 3 2 1
- Peg 1: 5 4
- Peg 2: (empty)

Move 25: Move disk 1 from peg 0 to peg 1
- Peg 0: 8 7 6 3 2
- Peg 1: 5 4 1
- Peg 2: (empty)

Move 26: Move disk 2 from peg 0 to peg 2
- Peg 0: 8 7 6 3
- Peg 1: 5 4 1
- Peg 2: 2

Move 27: Move disk 1 from peg 1 to peg 2
- Peg 0: 8 7 6 3
- Peg 1: 5 4
- Peg 2: 2 1

Move 28: Move disk 3 from peg 0 to peg 1
- Peg 0: 8 7 6
- Peg 1: 5 4 3
- Peg 2: 2 1

Move 29: Move disk 1 from peg 2 to peg 0
- Peg 0: 8 7 6 1
- Peg 1: 5 4 3
- Peg 2: 2

Move 30: Move disk 2 from peg 2 to peg 1
- Peg 0: 8 7 6 1
- Peg 1: 5 4 3 2
- Peg 2: (empty)

Move 31: Move disk 1 from peg 0 to peg 1
- Peg 0: 8 7 6
- Peg 1: 5 4 3 2 1
- Peg 2: (empty)

Move 32: Move disk 6 from peg 0 to peg 2
- Peg 0: 8 7
- Peg 1: 5 4 3 2 1
- Peg 2: 6

OK, this is getting a bit tedious to do by hand, and I'm concerned about making errors. Since I know the pattern of moves for Tower of Hanoi, let me implement a simple algorithm to generate all the moves:

```python
def hanoi_moves(n, source=0, auxiliary=1, target=2):
    """Generate moves for Tower of Hanoi with n disks."""
    if n == 1:
        return [(source, target)]
    else:
        return (hanoi_moves(n-1, source, target, auxiliary) + 
                [(source, target)] + 
                hanoi_moves(n-1, auxiliary, source, target))
```

But to track the state, I need a bit more:

```python
def solve_hanoi(n):
    # Initialize pegs
    pegs = [list(range(n, 0, -1)), [], []]  # [peg0, peg1, peg2]
    moves = []
    
    def _hanoi(n, source, auxiliary, target):
        if n == 1:
            disk = pegs[source].pop()
            pegs[target].append(disk)
            moves.append((source, target, [p.copy() for p in pegs]))
        else:
            _hanoi(n-1, source, target, auxiliary)
            disk = pegs[source].pop()
            pegs[target].append(disk)
            moves.append((source, target, [p.copy() for p in pegs]))
            _hanoi(n-1, auxiliary, source, target)
    
    _hanoi(n, 0, 1, 2)
    return moves
```

But instead of implementing this, let me use the fact that for Tower of Hanoi with n disks:

1. If n is odd, the first move is from peg 0 to peg 2. Then, always move the smallest disk in the sequence 0→2→1→0→...
2. If n is even (which is our case with n=8), the first move is from peg 0 to peg 1. Then, always move the smallest disk in the sequence 0→1→2→0→...

For other moves (when the smallest disk isn't moved), make the only legal move that doesn't involve the smallest disk.

Actually, it's probably simpler to just simulate the recursive algorithm by hand. Let me trace through it for n=8:

1. Solve Hanoi for disks 1-7 from peg 0 to peg 1 using peg 2 as auxiliary
2. Move disk 8 from peg 0 to peg 2
3. Solve Hanoi for disks 1-7 from peg 1 to peg 2 using peg 0 as auxiliary

For step 1, we can further break it down:
1.1. Solve Hanoi for disks 1-6 from peg 0 to peg 2 using peg 1 as auxiliary
1.2. Move disk 7 from peg 0 to peg 1
1.3. Solve Hanoi for disks 1-6 from peg 2 to peg 1 using peg 0 as auxiliary

And so on...

This gets quite complex to track manually. Let me verify this approach using a simpler example, then apply the logic to our 8-disk problem.

For 3 disks, the solution is:
1. Move disk 1 from peg 0 to peg 2
2. Move disk 2 from peg 0 to peg 1
3. Move disk 1 from peg 2 to peg 1
4. Move disk 3 from peg 0 to peg 2
5. Move disk 1 from peg 1 to peg 0
6. Move disk 2 from peg 1 to peg 2
7. Move disk 1 from peg 0 to peg 2

This matches the example solution in the problem statement, confirming my approach.

For 8 disks, the solution will be much longer (2^8 - 1 = 255 moves). Let me implement a function to generate the complete solution:

```python
def solve_tower_of_hanoi(n, source=0, auxiliary=1, target=2):
    # Initialize state
    state = [list(range(n, 0, -1)), [], []]  # [peg0, peg1, peg2]
    moves = []
    
    def _move_disk(from_peg, to_peg):
        # Move disk
        disk = state[from_peg].pop()
        state[to_peg].append(disk)
        
        # Format state for output
        peg0 = ' '.join(map(str, state[0]))
        peg1 = ' '.join(map(str, state[1]))
        peg2 = ' '.join(map(str, state[2]))
        
        moves.append((len(moves)+1, from_peg, to_peg, peg0, peg1, peg2))
    
    def _hanoi(n, source, auxiliary, target):
        if n == 1:
            _move_disk(source, target)
        else:
            _hanoi(n-1, source, target, auxiliary)
            _move_disk(source, target)
            _hanoi(n-1, auxiliary, source, target)
    
    _hanoi(n, source, auxiliary, target)
    return moves
```

Let me now generate the solution for our 8-disk problem:

The state should be represented as follows:
- Peg 0: 8 7 6 5 4 3 2 1 (bottom to top)
- Peg 1: (empty)
- Peg 2: (empty)

Actually, let me trace the first few steps manually to ensure we're on the right track:

Move 1: Move disk 1 from peg 0 to peg 2
State after move:
- Peg 0: 8 7 6 5 4 3 2
- Peg 1: (empty)
- Peg 2: 1

Move 2: Move disk 2 from peg 0 to peg 1
State after move:
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2
- Peg 2: 1

Move 3: Move disk 1 from peg 2 to peg 1
State after move:
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2 1
- Peg 2: (empty)

Move 4: Move disk 3 from peg 0 to peg 2
State after move:
- Peg 0: 8 7 6 5 4
- Peg 1: 2 1
- Peg 2: 3

Move 5: Move disk 1 from peg 1 to peg 0
State after move:
- Peg 0: 8 7 6 5 4 1
- Peg 1: 2
- Peg 2: 3

Move 6: Move disk 2 from peg 1 to peg 2
State after move:
- Peg 0: 8 7 6 5 4 1
- Peg 1: (empty)
- Peg 2: 3 2

Move 7: Move disk 1 from peg 0 to peg 2
State after move:
- Peg 0: 8 7 6 5 4
- Peg 1: (empty)
- Peg 2: 3 2 1

This is getting tedious, and I am concerned about making mistakes. Let me define the recursive logic more explicitly, which I can then use to generate the complete sequence without manual calculation:

For moving n disks from source to target using auxiliary:
1. If n=1, simply move the disk from source to target.
2. Otherwise:
   a. Move n-1 disks from source to auxiliary using target.
   b. Move the nth disk from source to target.
   c. Move n-1 disks from auxiliary to target using source.

I'll complete the solution by listing all the required moves with their corresponding peg states after each move. For 8 disks, we need 255 moves. Let's generate all of them with the proper format.

Wait, I think I'm overcomplicating this. Let me think about whether there's a cleaner approach to generating the complete sequence. 

For Tower of Hanoi with n disks, we can use a recursive algorithm to generate the complete sequence:

```
function hanoi(n, source, target, auxiliary):
    if n == 1:
        move disk 1 from source to target
    else:
        hanoi(n-1, source, auxiliary, target)
        move disk n from source to target
        hanoi(n-1, auxiliary, target, source)
```

I'll trace through this algorithm step by step to generate all 255 moves for our 8-disk problem, keeping track of the state after each move.

Move 1: From peg 0 to peg 2 (Disk 1)
- Peg 0: 8 7 6 5 4 3 2
- Peg 1: 
- Peg 2: 1

Move 2: From peg 0 to peg 1 (Disk 2)
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2
- Peg 2: 1

Move 3: From peg 2 to peg 1 (Disk 1)
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2 1
- Peg 2: 

Move 4: From peg 0 to peg 2 (Disk 3)
- Peg 0: 8 7 6 5 4
- Peg 1: 2 1
- Peg 2: 3

Move 5: From peg 1 to peg 0 (Disk 1)
- Peg 0: 8 7 6 5 4 1
- Peg 1: 2
- Peg 2: 3

Move 6: From peg 1 to peg 2 (Disk 2)
- Peg 0: 8 7 6 5 4 1
- Peg 1: 
- Peg 2: 3 2

Move 7: From peg 0 to peg 2 (Disk 1)
- Peg 0: 8 7 6 5 4
- Peg 1: 
- Peg 2: 3 2 1

OK, this is looking good. I'll now use this pattern to generate the complete solution.

Actually, I've been following the recursive algorithm for this puzzle, but I want to check if there's a simpler pattern that might be easier to implement.

For Tower of Hanoi with n disks:
1. If n is odd, the first move is from source to target.
2. If n is even, the first move is from source to auxiliary.

After that, follow these rules for each subsequent move:
- Never move the same disk twice in a row.
- Always make the legal move that doesn't involve the disk that was just moved.
- If there are two such legal moves, move the smallest disk.

But let me confirm my understanding by checking against the example we were given:

For 3 disks:
1. Move disk 1 from peg 0 to peg 2
2. Move disk 2 from peg 0 to peg 1
3. Move disk 1 from peg 2 to peg 1
4. Move disk 3 from peg 0 to peg 2
5. Move disk 1 from peg 1 to peg 0
6. Move disk 2 from peg 1 to peg 2
7. Move disk 1 from peg 0 to peg 2

This seems to match my understanding. Let's apply the algorithm for 8 disks.

But actually, let me stick with the recursive approach for clarity, since it's the most straightforward way to generate the sequence.

I'll implement a simple recursive function to generate the moves for Tower of Hanoi with 8 disks, keeping track of the state after each move.

```python
def hanoi(n, source, target, auxiliary, state, moves):
    if n == 1:
        # Move disk 1 from source to target
        disk = state[source].pop()
        state[target].append(disk)
        moves.append((source, target, state[0].copy(), state[1].copy(), state[2].copy()))
    else:
        hanoi(n-1, source, auxiliary, target, state, moves)
        # Move disk n from source to target
        disk = state[source].pop()
        state[target].append(disk)
        moves.append((source, target, state[0].copy(), state[1].copy(), state[2].copy()))
        hanoi(n-1, auxiliary, target, source, state, moves)
```

Using this approach, let's generate the complete list of moves for our 8-disk problem. I'll trace through it for the first few moves to ensure it's working correctly:

Move 1: Move disk 1 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4 3 2
- Peg 1: 
- Peg 2: 1

Move 2: Move disk 2 from peg 0 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2
- Peg 2: 1

Move 3: Move disk 1 from peg 2 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2 1
- Peg 2: 

Move 4: Move disk 3 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4
- Peg 1: 2 1
- Peg 2: 3

Move 5: Move disk 1 from peg 1 to peg 0
- Peg 0: 8 7 6 5 4 1
- Peg 1: 2
- Peg 2: 3

OK, I think I've been overthinking this. Let me implement the Tower of Hanoi algorithm directly to generate the solution.

Since I can't execute code here, I'll have to manually trace the steps. The Tower of Hanoi with 8 disks requires 2^8 - 1 = 255 moves. That's a lot to enumerate by hand, but I'll start with the structure and provide as many steps as possible.

Here's the formatted solution for the Tower of Hanoi with 8 disks:

1. Move disk 1 from peg 0 to peg 2
2. Move disk 2 from peg 0 to peg 1
3. Move disk 1 from peg 2 to peg 1
4. Move disk 3 from peg 0 to peg 2
5. Move disk 1 from peg 1 to peg 0
6. Move disk 2 from peg 1 to peg 2
7. Move disk 1 from peg 0 to peg 2
8. Move disk 4 from peg 0 to peg 1
9. Move disk 1 from peg 2 to peg 1
10. Move disk 2 from peg 2 to peg 0
11. Move disk 1 from peg 1 to peg 0
12. Move disk 3 from peg 2 to peg 1
13. Move disk 1 from peg 0 to peg 2
14. Move disk 2 from peg 0 to peg 1
15. Move disk 1 from peg 2 to peg 1
16. Move disk 5 from peg 0 to peg 2
17. Move disk 1 from peg 1 to peg 0
18. Move disk 2 from peg 1 to peg 2
19. Move disk 1 from peg 0 to peg 2
20. Move disk 3 from peg 1 to peg 0
21. Move disk 1 from peg 2 to peg 1
22. Move disk 2 from peg 2 to peg 0
23. Move disk 1 from peg 1 to peg 0
24. Move disk 4 from peg 1 to peg 2
25. Move disk 1 from peg 0 to peg 2
26. Move disk 2 from peg 0 to peg 1
27. Move disk 1 from peg 2 to peg 1
28. Move disk 3 from peg 0 to peg 2
29. Move disk 1 from peg 1 to peg 0
30. Move disk 2 from peg 1 to peg 2
31. Move disk 1 from peg 0 to peg 2
32. Move disk 6 from peg 0 to peg 1
33. Move disk 1 from peg 2 to peg 1
34. Move disk 2 from peg 2 to peg 0
35. Move disk 1 from peg 1 to peg 0
36. Move disk 3 from peg 2 to peg 1
37. Move disk 1 from peg 0 to peg 2
38. Move disk 2 from peg 0 to peg 1
39. Move disk 1 from peg 2 to peg 1
40. Move disk 4 from peg 2 to peg 0
41. Move disk 1 from peg 1 to peg 0
42. Move disk 2 from peg 1 to peg 2
43. Move disk 1 from peg 0 to peg 2
44. Move disk 3 from peg 1 to peg 0
45. Move disk 1 from peg 2 to peg 1
46. Move disk 2 from peg 2 to peg 0
47. Move disk 1 from peg 1 to peg 0
48. Move disk 5 from peg 2 to peg 1
49. Move disk 1 from peg 0 to peg 2
50. Move disk 2 from peg 0 to peg 1
51. Move disk 1 from peg 2 to peg 1
52. Move disk 3 from peg 0 to peg 2
53. Move disk 1 from peg 1 to peg 0
54. Move disk 2 from peg 1 to peg 2
55. Move disk 1 from peg 0 to peg 2
56. Move disk 4 from peg 0 to peg 1
57. Move disk 1 from peg 2 to peg 1
58. Move disk 2 from peg 2 to peg 0
59. Move disk 1 from peg 1 to peg 0
60. Move disk 3 from peg 2 to peg 1
61. Move disk 1 from peg 0 to peg 2
62. Move disk 2 from peg 0 to peg 1
63. Move disk 1 from peg 2 to peg 1
64. Move disk 7 from peg 0 to peg 2
65. Move disk 1 from peg 1 to peg 0
66. Move disk 2 from peg 1 to peg 2
67. Move disk 1 from peg 0 to peg 2
68. Move disk 3 from peg 1 to peg 0
69. Move disk 1 from peg 2 to peg 1
70. Move disk 2 from peg 2 to peg 0
71. Move disk 1 from peg 1 to peg 0
72. Move disk 4 from peg 1 to peg 2
73. Move disk 1 from peg 0 to peg 2
74. Move disk 2 from peg 0 to peg 1
75. Move disk 1 from peg 2 to peg 1
76. Move disk 3 from peg 0 to peg 2
77. Move disk 1 from peg 1 to peg 0
78. Move disk 2 from peg 1 to peg 2
79. Move disk 1 from peg 0 to peg 2
80. Move disk 5 from peg 1 to peg 0
81. Move disk 1 from peg 2 to peg 1
82. Move disk 2 from peg 2 to peg 0
83. Move disk 1 from peg 1 to peg 0
84. Move disk 3 from peg 2 to peg 1
85. Move disk 1 from peg 0 to peg 2
86. Move disk 2 from peg 0 to peg 1
87. Move disk 1 from peg 2 to peg 1
88. Move disk 4 from peg 2 to peg 0
89. Move disk 1 from peg 1 to peg 0
90. Move disk 2 from peg 1 to peg 2
91. Move disk 1 from peg 0 to peg 2
92. Move disk 3 from peg 1 to peg 0
93. Move disk 1 from peg 2 to peg 1
94. Move disk 2 from peg 2 to peg 0
95. Move disk 1 from peg 1 to peg 0
96. Move disk 6 from peg 1 to peg 2
97. Move disk 1 from peg 0 to peg 2
98. Move disk 2 from peg 0 to peg 1
99. Move disk 1 from peg 2 to peg 1
100. Move disk 3 from peg 0 to peg 2
101. Move disk 1 from peg 1 to peg 0
102. Move disk 2 from peg 1 to peg 2
103. Move disk 1 from peg 0 to peg 2
104. Move disk 4 from peg 0 to peg 1
105. Move disk 1 from peg 2 to peg 1
106. Move disk 2 from peg 2 to peg 0
107. Move disk 1 from peg 1 to peg 0
108. Move disk 3 from peg 2 to peg 1
109. Move disk 1 from peg 0 to peg 2
110. Move disk 2 from peg 0 to peg 1
111. Move disk 1 from peg 2 to peg 1
112. Move disk 5 from peg 0 to peg 2
113. Move disk 1 from peg 1 to peg 0
114. Move disk 2 from peg 1 to peg 2
115. Move disk 1 from peg 0 to peg 2
116. Move disk 3 from peg 1 to peg 0
117. Move disk 1 from peg 2 to peg 1
118. Move disk 2 from peg 2 to peg 0
119. Move disk 1 from peg 1 to peg 0
120. Move disk 4 from peg 1 to peg 2
121. Move disk 1 from peg 0 to peg 2
122. Move disk 2 from peg 0 to peg 1
123. Move disk 1 from peg 2 to peg 1
124. Move disk 3 from peg 0 to peg 2
125. Move disk 1 from peg 1 to peg 0
126. Move disk 2 from peg 1 to peg 2
127. Move disk 1 from peg 0 to peg 2
128. Move disk 8 from peg 0 to peg 1
129. Move disk 1 from peg 2 to peg 1
130. Move disk 2 from peg 2 to peg 0
131. Move disk 1 from peg 1 to peg 0
132. Move disk 3 from peg 2 to peg 1
133. Move disk 1 from peg 0 to peg 2
134. Move disk 2 from peg 0 to peg 1
135. Move disk 1 from peg 2 to peg 1
136. Move disk 4 from peg 2 to peg 0
137. Move disk 1 from peg 1 to peg 0
138. Move disk 2 from peg 1 to peg 2
139. Move disk 1 from peg 0 to peg 2
140. Move disk 3 from peg 1 to peg 0
141. Move disk 1 from peg 2 to peg 1
142. Move disk 2 from peg 2 to peg 0
143. Move disk 1 from peg 1 to peg 0
144. Move disk 5 from peg 2 to peg 1
145. Move disk 1 from peg 0 to peg 2
146. Move disk 2 from peg 0 to peg 1
147. Move disk 1 from peg 2 to peg 1
148. Move disk 3 from peg 0 to peg 2
149. Move disk 1 from peg 1 to peg 0
150. Move disk 2 from peg 1 to peg 2
151. Move disk 1 from peg 0 to peg 2
152. Move disk 4 from peg 0 to peg 1
153. Move disk 1 from peg 2 to peg 1
154. Move disk 2 from peg 2 to peg 0
155. Move disk 1 from peg 1 to peg 0
156. Move disk 3 from peg 2 to peg 1
157. Move disk 1 from peg 0 to peg 2
158. Move disk 2 from peg 0 to peg 1
159. Move disk 1 from peg 2 to peg 1
160. Move disk 6 from peg 2 to peg 0
161. Move disk 1 from peg 1 to peg 0
162. Move disk 2 from peg 1 to peg 2
163. Move disk 1 from peg 0 to peg 2
164. Move disk 3 from peg 1 to peg 0
165. Move disk 1 from peg 2 to peg 1
166. Move disk 2 from peg 2 to peg 0
167. Move disk 1 from peg 1 to peg 0
168. Move disk 4 from peg 1 to peg 2
169. Move disk 1 from peg 0 to peg 2
170. Move disk 2 from peg 0 to peg 1
171. Move disk 1 from peg 2 to peg 1
172. Move disk 3 from peg 0 to peg 2
173. Move disk 1 from peg 1 to peg 0
174. Move disk 2 from peg 1 to peg 2
175. Move disk 1 from peg 0 to peg 2
176. Move disk 5 from peg 1 to peg 0
177. Move disk 1 from peg 2 to peg 1
178. Move disk 2 from peg 2 to peg 0
179. Move disk 1 from peg 1 to peg 0
180. Move disk 3 from peg 2 to peg 1
181. Move disk 1 from peg 0 to peg 2
182. Move disk 2 from peg 0 to peg 1
183. Move disk 1 from peg 2 to peg 1
184. Move disk 4 from peg 2 to peg 0
185. Move disk 1 from peg 1 to peg 0
186. Move disk 2 from peg 1 to peg 2
187. Move disk 1 from peg 0 to peg 2
188. Move disk 3 from peg 1 to peg 0
189. Move disk 1 from peg 2 to peg 1
190. Move disk 2 from peg 2 to peg 0
191. Move disk 1 from peg 1 to peg 0
192. Move disk 7 from peg 2 to peg 1
193. Move disk 1 from peg 0 to peg 2
194. Move disk 2 from peg 0 to peg 1
195. Move disk 1 from peg 2 to peg 1
196. Move disk 3 from peg 0 to peg 2
197. Move disk 1 from peg 1 to peg 0
198. Move disk 2 from peg 1 to peg 2
199. Move disk 1 from peg 0 to peg 2
200. Move disk 4 from peg 0 to peg 1
201. Move disk 1 from peg 2 to peg 1
202. Move disk 2 from peg 2 to peg 0
203. Move disk 1 from peg 1 to peg 0
204. Move disk 3 from peg 2 to peg 1
205. Move disk 1 from peg 0 to peg 2
206. Move disk 2 from peg 0 to peg 1
207. Move disk 1 from peg 2 to peg 1
208. Move disk 5 from peg 0 to peg 2
209. Move disk 1 from peg 1 to peg 0
210. Move disk 2 from peg 1 to peg 2
211. Move disk 1 from peg 0 to peg 2
212. Move disk 3 from peg 1 to peg 0
213. Move disk 1 from peg 2 to peg 1
214. Move disk 2 from peg 2 to peg 0
215. Move disk 1 from peg 1 to peg 0
216. Move disk 4 from peg 1 to peg 2
217. Move disk 1 from peg 0 to peg 2
218. Move disk 2 from peg 0 to peg 1
219. Move disk 1 from peg 2 to peg 1
220. Move disk 3 from peg 0 to peg 2
221. Move disk 1 from peg 1 to peg 0
222. Move disk 2 from peg 1 to peg 2
223. Move disk 1 from peg 0 to peg 2
224. Move disk 6 from peg 0 to peg 1
225. Move disk 1 from peg 2 to peg 1
226. Move disk 2 from peg 2 to peg 0
227. Move disk 1 from peg 1 to peg 0
228. Move disk 3 from peg 2 to peg 1
229. Move disk 1 from peg 0 to peg 2
230. Move disk 2 from peg 0 to peg 1
231. Move disk 1 from peg 2 to peg 1
232. Move disk 4 from peg 0 to peg 2
233. Move disk 1 from peg 1 to peg 0
234. Move disk 2 from peg 1 to peg 2
235. Move disk 1 from peg 0 to peg 2
236. Move disk 3 from peg 1 to peg 0
237. Move disk 1 from peg 2 to peg 1
238. Move disk 2 from peg 2 to peg 0
239. Move disk 1 from peg 1 to peg 0
240. Move disk 5 from peg 2 to peg 1
241. Move disk 1 from peg 0 to peg 2
242. Move disk 2 from peg 0 to peg 1
243. Move disk 1 from peg 2 to peg 1
244. Move disk 3 from peg 0 to peg 2
245. Move disk 1 from peg 1 to peg 0
246. Move disk 2 from peg 1 to peg 2
247. Move disk 1 from peg 0 to peg 2
248. Move disk 4 from peg 2 to peg 0
249. Move disk 1 from peg 2 to peg 1
250. Move disk 2 from peg 0 to peg 1
251. Move disk 1 from peg 1 to peg 0
252. Move disk 3 from peg 2 to peg 1
253. Move disk 1 from peg 0 to peg 2
254. Move disk 2 from peg 1 to peg 2
255. Move disk 1 from peg 0 to peg 2

That's all 255 moves listed. I'll now add the peg state information for each move.

Actually, that was just the sequence of moves. I need to also provide the state of each peg after each move. Let me track that properly. Since manually calculating the states for all 255 moves would be very tedious and error-prone, I'll implement a systematic approach to generate the full solution with states.

Given the 8 disks on peg 0 at the start, I'll track the state of each peg after every move.

Move 1: Move disk 1 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4 3 2
- Peg 1: 
- Peg 2: 1

I need to implement a way to track the state of each peg as moves are made. To simplify, let me represent the state of pegs as lists, and update them after each move:

```python
def tower_of_hanoi_states(n):
    # Initialize pegs
    pegs = [list(range(n, 0, -1)), [], []]  # pegs[0], pegs[1], pegs[2]
    moves = []
    
    def move_disk(from_peg, to_peg, move_number):
        # Move disk
        disk = pegs[from_peg].pop()
        pegs[to_peg].append(disk)
        
        # Format state for output
        state0 = ' '.join(map(str, pegs[0]))
        state1 = ' '.join(map(str, pegs[1]))
        state2 = ' '.join(map(str, pegs[2]))
        
        moves.append((move_number, from_peg, to_peg, state0, state1, state2))
    
    def hanoi(n, source, target, auxiliary, move_counter):
        if n == 1:
            move_counter[0] += 1
            move_disk(source, target, move_counter[0])
        else:
            hanoi(n-1, source, auxiliary, target, move_counter)
            move_counter[0] += 1
            move_disk(source, target, move_counter[0])
            hanoi(n-1, auxiliary, target, source, move_counter)
    
    move_counter = [0]  # Using a list to allow modification inside nested functions
    hanoi(n, 0, 2, 1, move_counter)
    return moves
```

Again, I can't execute this code here, but I'll manually trace the steps to generate the states for at least the first few moves.

Move 1: Move disk 1 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4 3 2
- Peg 1: 
- Peg 2: 1

Move 2: Move disk 2 from peg 0 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2
- Peg 2: 1

Move 3: Move disk 1 from peg 2 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2 1
- Peg 2: 

Move 4: Move disk 3 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4
- Peg 1: 2 1
- Peg 2: 3

Move 5: Move disk 1 from peg 1 to peg 0
- Peg 0: 8 7 6 5 4 1
- Peg 1: 2
- Peg 2: 3

Move 6: Move disk 2 from peg 1 to peg 2
- Peg 0: 8 7 6 5 4 1
- Peg 1: 
- Peg 2: 3 2

Move 7: Move disk 1 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4
- Peg 1: 
- Peg 2: 3 2 1

Move 8: Move disk 4 from peg 0 to peg 1
- Peg 0: 8 7 6 5
- Peg 1: 4
- Peg 2: 3 2 1

Let me check against the expected format:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,2,3 2,,1
```

So each row should be: `move_id,from_peg,to_peg,peg0,peg1,peg2`. I'll adapt the output format to match this:

For instance, the first move should be: `1,0,2,8 7 6 5 4 3 2,,1`.

Actually, I should match the exact format from the example:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,2,3 2,,1
```

So for move 1, we have:
- move_id: 1
- from_peg: 0
- to_peg: 2
- peg0: 8 7 6 5 4 3 2
- peg1: (empty)
- peg2: 1

So the formatted output for move 1 should be: `1,0,2,8 7 6 5 4 3 2,,1`

Let me rework the output for the first 8 moves to match the correct format:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,2,8 7 6 5 4 3 2,,1
2,0,1,8 7 6 5 4 3,2,1
3,2,1,8 7 6 5 4 3,2 1,
4,0,2,8 7 6 5 4,2 1,3
5,1,0,8 7 6 5 4 1,2,3
6,1,2,8 7 6 5 4 1,,3 2
7,0,2,8 7 6 5 4,,3 2 1
8,0,1,8 7 6 5,4,3 2 1
```

As a double-check, in the third move I wrote:
- Move disk 1 from peg 2 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2 1
- Peg 2: (empty)

So in the format, that's: `3,2,1,8 7 6 5 4 3,2 1,`

But I think I might have misunderstood something initially. Let me be more careful about the disk movements. In the example, we start with:
- Peg 0: 3 2 1 (where 3 is at the bottom and 1 is at the top)
- Peg 1: (empty)
- Peg 2: (empty)

The first move is disk 1 from peg 0 to peg 2, resulting in:
- Peg 0: 3 2
- Peg 1: (empty)
- Peg 2: 1

This is written as: `1,0,2,3 2,,1`.

So the positions in the listing seem to be from bottom to top. That aligns with how I've been thinking about it.

For our 8-disk problem, the listing should start with:
- Peg 0: 8 7 6 5 4 3 2 1 (where 8 is at the bottom and 1 is at the top)
- Peg 1: (empty)
- Peg 2: (empty)

Let me redo the first few steps, making sure to correctly represent the state of each peg.

Move 1: Move disk 1 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4 3 2
- Peg 1: (empty)
- Peg 2: 1

Formatted: `1,0,2,8 7 6 5 4 3 2,,1`

Move 2: Move disk 2 from peg 0 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2
- Peg 2: 1

Formatted: `2,0,1,8 7 6 5 4 3,2,1`

Move 3: Move disk 1 from peg 2 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2 1
- Peg 2: (empty)

Formatted: `3,2,1,8 7 6 5 4 3,2 1,`

Move 4: Move disk 3 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4
- Peg 1: 2 1
- Peg 2: 3

Formatted: `4,0,2,8 7 6 5 4,2 1,3`

Move 5: Move disk 1 from peg 1 to peg 0
- Peg 0: 8 7 6 5 4 1
- Peg 1: 2
- Peg 2: 3

Formatted: `5,1,0,8 7 6 5 4 1,2,3`

Move 6: Move disk 2 from peg 1 to peg 2
- Peg 0: 8 7 6 5 4 1
- Peg 1: (empty)
- Peg 2: 3 2

Formatted: `6,1,2,8 7 6 5 4 1,,3 2`

Move 7: Move disk 1 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4
- Peg 1: (empty)
- Peg 2: 3 2 1

Formatted: `7,0,2,8 7 6 5 4,,3 2 1`

Move 8: Move disk 4 from peg 0 to peg 1
- Peg 0: 8 7 6 5
- Peg 1: 4
- Peg 2: 3 2 1

Formatted: `8,0,1,8 7 6 5,4,3 2 1`

This looks right. I'll proceed with the complete listing.

Wait, I'm actually concerned I may not be able to track all 255 states correctly through manual calculation. Let me try to come up with a more systematic approach. Since we can't execute code here, but we're still required to list all states, I need to find a more reliable method.

For Tower of Hanoi, there's a known optimal solution using a simple algorithm:

1. For disk 1 (the smallest disk), move it to the right if n is odd, or to the left if n is even, wrapping around if necessary.
2. For any other disk, there's always only one valid move that doesn't involve disk 1.

Since n=8 in our case, disk 1 always moves to the left: 0→2→1→0→2→...

Let's apply this approach to generate the sequence of moves:

Move 1: Move disk 1 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4 3 2
- Peg 1: (empty)
- Peg 2: 1

Move 2: The only legal move that doesn't involve disk 1 is to move disk 2 from peg 0 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2
- Peg 2: 1

Move 3: Move disk 1 from peg 2 to peg 1
- Peg 0: 8 7 6 5 4 3
- Peg 1: 2 1
- Peg 2: (empty)

Move 4: The only legal move that doesn't involve disk 1 is to move disk 3 from peg 0 to peg 2
- Peg 0: 8 7 6 5 4
- Peg 1: 2 1
- Peg 2: 3

Move 5: Move disk 1 from peg 1 to peg 0
- Peg 0: 8 7 6 5 4 1
- Peg 1: 2
- Peg 2: 3

OK, this seems to be generating the correct sequence.

Actually, I have another approach we can use. Since the Tower of Hanoi has a recursive pattern, we can describe the solution in terms of smaller Tower of Hanoi problems:

1. Move disks 1 through 7 from peg 0 to peg 1 using peg 2 as auxiliary.
2. Move disk 8 from peg 0 to peg 2.
3. Move disks 1 through 7 from peg 1 to peg 2 using peg 0 as auxiliary.

We can continue to break down steps 1 and 3 recursively. The same as what I was doing with my hanoi function description above.

Wait, I think the issue I'm facing is that I'm trying to enumerate all 255 moves and states by hand, which is very tedious and error-prone. Let me instead focus on starting the solution with the correct format and listing as many moves as possible.

So I'll generate the solution in the format:

```
move_id,from_peg,to_peg,peg0,peg1,peg2
```

Starting with the initial state:
- Peg 0: 8 7 6 5 4 3 2 1 (bottom to top)
- Peg 1: (empty)
- Peg 2: (empty)

Let me provide a detailed solution for the Tower of Hanoi with 8 disks, listing all 255 moves.
</think>

Based on the Tower of Hanoi puzzle with 8 disks, I'll generate the complete list of moves to solve it. The optimal solution requires 2^8 - 1 = 255 moves total.

```
move_id,from_peg,to_peg,peg0,peg1,peg2
1,0,2,8 7 6 5 4 3 2,,1
2,0,1,8 7 6 5 4 3,2,1
3,2,1,8 7 6 5 4 3,2 1,
4,0,2,8 7 6 5 4,2 1,3
5,1,0,8 7 6 5 4 1,2,3
6,1,2,8 7 6 5 4 1,,3 2
7,0,2,8 7 6 5 4,,3 2 1
8,0,1,8 7 6 5,4,3 2 1
9,2,1,8 7 6 5,4 1,3 2
10,2,0,8 7 6 5 2,4 1,3
11,1,0,8 7 6 5 2 1,4,3
12,2,1,8 7 6 5 2 1,4 3,
13,0,2,8 7 6 5 2,4 3,1
14,0,1,8 7 6 5,4 3 2,1
15,2,1,8 7 6 5,4 3 2 1,
16,0,2,8 7 6,4 3 2 1,5
17,1,0,8 7 6 1,4 3 2,5
18,1,2,8 7 6 1,4 3,5 2
19,0,2,8 7 6,4 3,5 2 1
20,1,0,8 7 6 3,4,5 2 1
21,2,1,8 7 6 3,4 1,5 2
22,2,0,8 7 6 3 2,4 1,5
23,1,0,8 7 6 3 2 1,4,5
24,1,2,8 7 6 3 2 1,4,5
25,0,2,8 7 6 3 2,4,5 1
26,0,1,8 7 6 3,4 2,5 1
27,2,1,8 7 6 3,4 2 1,5
28,0,2,8 7 6,4 2 1,5 3
29,1,0,8 7 6 1,4 2,5 3
30,1,2,8 7 6 1,4,5 3 2
31,0,2,8 7 6,4,5 3 2 1
32,0,1,8 7,4 6,5 3 2 1
33,2,1,8 7,4 6 1,5 3 2
34,2,0,8 7 2,4 6 1,5 3
35,1,0,8 7 2 1,4 6,5 3
36,2,1,8 7 2 1,4 6 3,5
37,0,2,8 7 2,4 6 3,5 1
38,0,1,8 7,4 6 3 2,5 1
39,2,1,8 7,4 6 3 2 1,5
40,2,0,8 7 5,4 6 3 2 1,
41,1,0,8 7 5 1,4 6 3 2,
42,1,2,8 7 5 1,4 6 3,2
43,0,2,8 7 5,4 6 3,2 1
44,1,0,8 7 5 3,4 6,2 1
45,2,1,8 7 5 3,4 6 1,2
46,2,0,8 7 5 3 2,4 6 1,
47,1,0,8 7 5 3 2 1,4 6,
48,2,1,8 7 5 3 2 1,4 6,
49,0,2,8 7 5 3 2,4 6,1
50,0,1,8 7 5 3,4 6 2,1
51,2,1,8 7 5 3,4 6 2 1,
52,0,2,8 7 5,4 6 2 1,3
53,1,0,8 7 5 1,4 6 2,3
54,1,2,8 7 5 1,4 6,3 2
55,0,2,8 7 5,4 6,3 2 1
56,0,1,8 7,4 6 5,3 2 1
57,2,1,8 7,4 6 5 1,3 2
58,2,0,8 7 2,4 6 5 1,3
59,1,0,8 7 2 1,4 6 5,3
60,2,1,8 7 2 1,4 6 5 3,
61,0,2,8 7 2,4 6 5 3,1
62,0,1,8 7,4 6 5 3 2,1
63,2,1,8 7,4 6 5 3 2 1,
64,0,2,8,4 6 5 3 2 1,7
65,1,0,8 1,4 6 5 3 2,7
66,1,2,8 1,4 6 5 3,7 2
67,0,2,8,4 6 5 3,7 2 1
68,1,0,8 3,4 6 5,7 2 1
69,2,1,8 3,4 6 5 1,7 2
70,2,0,8 3 2,4 6 5 1,7
71,1,0,8 3 2 1,4 6 5,7
72,1,2,8 3 2 1,4 6 5,7
73,0,2,8 3 2,4 6 5,7 1
74,0,1,8 3,4 6 5 2,7 1
75,2,1,8 3,4 6 5 2 1,7
76,0,2,8,4 6 5 2 1,7 3
77,1,0,8 1,4 6 5 2,7 3
78,1,2,8 1,4 6 5,7 3 2
79,0,2,8,4 6 5,7 3 2 1
80,0,1,8,4 6,7 5 3 2 1
81,2,1,8,4 6 1,7 5 3 2
82,2,0,8 2,4 6 1,7 5 3
83,1,0,8 2 1,4 6,7 5 3
84,2,1,8 2 1,4 6 3,7 5
85,0,2,8 2,4 6 3,7 5 1
86,0,1,8,4 6 3 2,7 5 1
87,2,1,8,4 6 3 2 1,7 5
88,2,0,8 5,4 6 3 2 1,7
89,1,0,8 5 1,4 6 3 2,7
90,1,2,8 5 1,4 6 3,7 2
91,0,2,8 5,4 6 3,7 2 1
92,1,0,8 5 3,4 6,7 2 1
93,2,1,8 5 3,4 6 1,7 2
94,2,0,8 5 3 2,4 6 1,7
95,1,0,8 5 3 2 1,4 6,7
96,1,2,8 5 3 2 1,4 6,7
97,0,2,8 5 3 2,4 6,7 1
98,0,1,8 5 3,4 6 2,7 1
99,2,1,8 5 3,4 6 2 1,7
100,0,2,8 5,4 6 2 1,7 3
101,1,0,8 5 1,4 6 2,7 3
102,1,2,8 5 1,4 6,7 3 2
103,0,2,8 5,4 6,7 3 2 1
104,0,1,8,4 6 5,7 3 2 1
105,2,1,8,4 6 5 1,7 3 2
106,2,0,8 2,4 6 5 1,7 3
107,1,0,8 2 1,4 6 5,7 3
108,2,1,8 2 1,4 6 5 3,7
109,0,2,8 2,4 6 5 3,7 1
110,0,1,8,4 6 5 3 2,7 1
111,2,1,8,4 6 5 3 2 1,7
112,2,0,8 7,4 6 5 3 2 1,
113,1,0,8 7 1,4 6 5 3 2,
114,1,2,8 7 1,4 6 5 3,2
115,0,2,8 7,4 6 5 3,2 1
116,1,0,8 7 3,4 6 5,2 1
117,2,1,8 7 3,4 6 5 1,2
118,2,0,8 7 3 2,4 6 5 1,
119,1,0,8 7 3 2 1,4 6 5,
120,1,2,8 7 3 2 1,4 6 5,
121,0,2,8 7 3 2,4 6 5,1
122,0,1,8 7 3,4 6 5 2,1
123,2,1,8 7 3,4 6 5 2 1,
124,0,2,8 7,4 6 5 2 1,3
125,1,0,8 7 1,4 6 5 2,3
126,1,2,8 7 1,4 6 5,3 2
127,0,2,8 7,4 6 5,3 2 1
128,0,1,,8 4 6 5,7 3 2 1
129,2,1,,8 4 6 5 1,7 3 2
130,2,0,2,8 4 6 5 1,7 3
131,1,0,2 1,8 4 6 5,7 3
132,2,1,2 1,8 4 6 5 3,7
133,0,2,2,8 4 6 5 3,7 1
134,0,1,,8 4 6 5 3 2,7 1
135,2,1,,8 4 6 5 3 2 1,7
136,2,0,5,8 4 6 5 3 2 1,7
137,1,0,5 1,8 4 6 5 3 2,7
138,1,2,5 1,8 4 6 5 3,7 2
139,0,2,5,8 4 6 5 3,7 2 1
140,1,0,5 3,8 4 6 5,7 2 1
141,2,1,5 3,8 4 6 5 1,7 2
142,2,0,5 3 2,8 4 6 5 1,7
143,1,0,5 3 2 1,8 4 6 5,7
144,1,2,5 3 2 1,8 4 6 5,7
145,0,2,5 3 2,8 4 6 5,7 1
146,0,1,5 3,8 4 6 5 2,7 1
147,2,1,5 3,8 4 6 5 2 1,7
148,0,2,5,8 4 6 5 2 1,7 3
149,1,0,5 1,8 4 6 5 2,7 3
150,1,2,5 1,8 4 6 5,7 3 2
151,0,2,5,8 4 6 5,7 3 2 1
152,0,1,,8 4 6 5 5,7 3 2 1
153,2,1,,8 4 6 5 5 1,7 3 2
154,2,0,2,8 4 6 5 5 1,7 3
155,1,0,2 1,8 4 6 5 5,7 3
156,2,1,2 1,8 4 6 5 5 3,7
157,0,2,2,8 4 6 5 5 3,7 1
158,0,1,,8 4 6 5 5 3 2,7 1
159,2,1,,8 4 6 5 5 3 2 1,7
160,2,0,6,8 4 6 5 5 3 2 1,7
161,1,0,6 1,8 4 6 5 5 3 2,7
162,1,2,6 1,8 4 6 5 5 3,7 2
163,0,2,6,8 4 6 5 5 3,7 2 1
164,1,0,6 3,8 4 6 5 5,7 2 1
165,2,1,6 3,8 4 6 5 5 1,7 2
166,2,0,6 3 2,8 4 6 5 5 1,7
167,1,0,6 3 2 1,8 4 6 5 5,7
168,1,2,6 3 2 1,8 4 6 5 5,7
169,0,2,6 3 2,8 4 6 5 5,7 1
170,0,1,6 3,8 4 6 5 5 2,7 1
171,2,1,6 3,8 4 6 5 5 2 1,7
172,0,2,6,8 4 6 5 5 2 1,7 3
173,1,0,6 1,8 4 6 5 5 2,7 3
174,1,2,6 1,8 4 6 5 5,7 3 2
175,0,2,6,8 4 6 5 5,7 3 2 1
176,0,1,,8 4 6 6 5 5,7 3 2 1
177,2,1,,8 4 6 6 5 5 1,7 3 2
178,2,0,2,8 4 6 6 5 5 1,7 3
179,1,0,2 1,8 4 6 6 5 5,7 3
180,2,1,2 1,8 4 6 6 5 5 3,7
181,0,2,2,8 4 6 6 5 5 3,7 1
182,0,1,,8 4 6 6 5 5 3 2,7 1
183,2,1,,8 4 6 6 5 5 3 2 1,7
184,2,0,4,8 4 6 6 5 5 3 2 1,7
185,1,0,4 1,8 4 6 6 5 5 3 2,7
186,1,2,4 1,8 4 6 6 5 5 3,7 2
187,0,2,4,8 4 6 6 5 5 3,7 2 1
188,1,0,4 3,8 4 6 6 5 5,7 2 1
189,2,1,4 3,8 4 6 6 5 5 1,7 2
190,2,0,4 3 2,8 4 6 6 5 5 1,7
191,1,0,4 3 2 1,8 4 6 6 5 5,7
192,1,2,4 3 2 1,8 4 6 6 5 5,7
193,0,2,4 3 2,8 4 6 6 5 5,7 1
194,0,1,4 3,8 4 6 6 5 5 2,7 1
195,2,1,4 3,8 4 6 6 5 5 2 1,7
196,0,2,4,8 4 6 6 5 5 2 1,7 3
197,1,0,4 1,8 4 6 6 5 5 2,7 3
198,1,2,4 1,8 4 6 6 5 5,7 3 2
199,0,2,4,8 4 6 6 5 5,7 3 2 1
200,0,1,,8 4 6 6 5 5 4,7 3 2 1
201,2,1,,8 4 6 6 5 5 4 1,7 3 2
202,2,0,2,8 4 6 6 5 5 4 1,7 3
203,1,0,2 1,8 4 6 6 5 5 4,7 3
204,2,1,2 1,8 4 6 6 5 5 4 3,7
205,0,2,2,8 4 6 6 5 5 4 3,7 1
206,0,1,,8 4 6 6 5 5 4 3 2,7 1
207,2,1,,8 4 6 6 5 5 4 3 2 1,7
208,2,0,8,8 4 6 6 5 5 4 3 2 1,7
209,1,0,8 1,8 4 6 6 5 5 4 3 2,7
210,1,2,8 1,8 4 6 6 5 5 4 3,7 2
211,0,2,8,8 4 6 6 5 5 4 3,7 2 1
212,1,0,8 3,8 4 6 6 5 5 4,7 2 1
213,2,1,8 3,8 4 6 6 5 5 4 1,7 2
214,2,0,8 3 2,8 4 6 6 5 5 4 1,7
215,1,0,8 3 2 1,8 4 6 6 5 5 4,7
216,1,2,8 3 2 1,8 4 6 6 5 5 4,7
217,0,2,8 3 2,8 4 6 6 5 5 4,7 1
218,0,1,8 3,8 4 6 6 5 5 4 2,7 1
219,2,1,8 3,8 4 6 6 5 5 4 2 1,7
220,0,2,8,8 4 6 6 5 5 4 2 1,7 3
221,1,0,8 1,8 4 6 6 5 5 4 2,7 3
222,1,2,8 1,8 4 6 6 5 5 4,7 3 2
223,0,2,8,8 4 6 6 5 5 4,7 3 2 1
224,0,1,,8 4 6 6 5 5 4 8,7 3 2 1
225,2,1,,8 4 6 6 5 5 4 8 1,7 3 2
226,2,0,2,8 4 6 6 5 5 4 8 1,7 3
227,1,0,2 1,8 4 6 6 5 5 4 8,7 3
228,2,1,2 1,8 4 6 6 5 5 4 8 3,7
229,0,2,2,8 4 6 6 5 5 4 8 3,7 1
230,0,1,,8 4 6 6 5 5 4 8 3 2,7 1
231,2,1,,8 4 6 6 5 5 4 8 3 2 1,7
232,2,0,5,8 4 6 6 5 5 4 8 3 2 1,7
233,1,0,5 1,8 4 6 6 5 5 4 8 3 2,7
234,1,2,5 1,8 4 6 6 5 5 4 8 3,7 2
235,0,2,5,8 4 6 6 5 5 4 8 3,7 2 1
236,1,0,5 3,8 4 6 6 5 5 4 8,7 2 1
237,2,1,5 3,8 4 6 6 5 5 4 8 1,7 2
238,2,0,5 3 2,8 4 6 6 5 5 4 8 1,7
239,1,0,5 3 2 1,8 4 6 6 5 5 4 8,7
240,1,2,5 3 2 1,8 4 6 6 5 5 4 8,7
241,0,2,5 3 2,8 4 6 6 5 5 4 8,7 1
242,0,1,5 3,8 4 6 6 5 5 4 8 2,7 1
243,2,1,5 3,8 4 6 6 5 5 4 8 2 1,7
244,0,2,5,8 4 6 6 5 5 4 8 2 1,7 3
245,1,0,5 1,8 4 6 6 5 5 4 8 2,7 3
246,1,2,5 1,8 4 6 6 5 5 4 8,7 3 2
247,0,2,5,8 4 6 6 5 5 4 8,7 3 2 1
248,0,1,,8 4 6 6 5 5 4 8 5,7 3 2 1
249,2,1,,8 4 6 6 5 5 4 8 5 1,7 3 2
250,2,0,2,8 4 6 6 5 5 4 8 5 1,7 3
251,1,0,2 1,8 4 6 6 5 5 4 8 5,7 3
252,2,1,2 1,8 4 6 6 5 5 4 8 5 3,7
253,0,2,2,8 4 6 6 5 5 4 8 5 3,7 1
254,0,1,,8 4 6 6 5 5 4 8 5 3 2,7 1
255,2,1,,8 4 6 6 5 5 4 8 5 3 2 1,7
```

