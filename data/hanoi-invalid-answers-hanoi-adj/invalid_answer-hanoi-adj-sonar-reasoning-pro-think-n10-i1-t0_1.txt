# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=10, i=1
# valid_prefix_length=127, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 10 disks. The user wants the complete list of moves without any truncation. Hmm, I remember the classic recursive solution. For n disks, the minimum number of moves is 2^n - 1, so for 10 disks, that's 1023 moves. That's a lot, but the user insists on the full list.

The recursive approach is to move the top n-1 disks from the source peg to the auxiliary peg, then move the nth disk to the target peg, and finally move the n-1 disks from the auxiliary to the target. Each of these steps involves recursive calls. But how do I translate that into a sequence of individual moves?

Wait, the example given for 3 disks uses a specific move list. Let me check that. The example moves are [[1,0,2],[2,0,1],[1,2,1],[3,0,2],[1,1,0],[2,1,2],[1,0,2]]. So each move is [disk, from, to]. The disk numbers are 1 to n, with 1 being the smallest. The pegs are 0-indexed.

So for 10 disks, the algorithm would generate all these moves recursively. But generating the exact list programmatically would require implementing the recursive algorithm and tracking each move. Since I can't run code here, I need to figure out the pattern or find a way to represent the moves correctly.

Alternatively, maybe there's a pattern in the moves. For example, the smallest disk (1) moves every other step, alternating between pegs. But with 10 disks, that's a complex pattern. The recursive approach is the most straightforward way to generate the moves.

Let me think about the recursive steps. For each disk, the moves are determined by the Hanoi function. For disk 10, the steps would be:

1. Move disks 1-9 from peg 0 to peg 1 (using peg 2 as auxiliary).
2. Move disk 10 from peg 0 to peg 2.
3. Move disks 1-9 from peg 1 to peg 2 (using peg 0 as auxiliary).

Each of these steps involves breaking down into smaller subproblems. Each time a disk is moved, it's added to the move list. So the move list is built by recursively handling each subproblem.

But how to represent this without actual code? Maybe by following the recursive algorithm's logic and manually building the list. However, with 1023 moves, that's impractical. But the user requires the full list, so I have to generate it somehow.

Wait, the search results mention the recursive algorithm. Source [1] provides the steps: move n-1 disks from source to aux, move nth disk to dest, then move n-1 disks from aux to dest. Each of these steps is recursive. So the move list is generated by these recursive calls.

But to output the exact sequence, I need to simulate the recursion. Let's try to outline the moves for a smaller number of disks and see if a pattern emerges that can be generalized.

For n=1: [[1,0,2]]

For n=2:
- Move 1 from 0 to 1 (aux)
- Move 2 from 0 to 2 (dest)
- Move 1 from 1 to 2 (dest)
So moves = [[1,0,1], [2,0,2], [1,1,2]]

Wait, but in the example given for n=3, the first move is [1,0,2]. Hmm, maybe the auxiliary peg changes based on the current recursion level. Let me check the example again.

In the example with 3 disks, the moves start with moving disk 1 from 0 to 2. Then disk 2 from 0 to 1, etc. So the auxiliary peg alternates depending on the current step. This suggests that the order of pegs (source, aux, dest) changes during recursion.

The standard Tower of Hanoi recursive algorithm uses the parameters (n, source, dest, aux). So for each call, the source and aux swap roles depending on the step. Therefore, the moves are generated in the order of moving n-1 disks from source to aux, then moving the nth disk, then moving n-1 from aux to dest.

To generate the exact move list for 10 disks, I need to follow this recursive pattern, keeping track of the source, destination, and auxiliary pegs at each step. Each move of a disk is recorded as [disk_number, from_peg, to_peg].

But without implementing the actual recursion, how can I generate the list? Maybe by understanding that each disk's moves follow a specific pattern based on its size. For example, the smallest disk (1) moves every other move, alternating between pegs. The next disk (2) moves every 4th move, and so on. But I'm not sure if that's accurate.

Alternatively, the sequence of moves can be determined using binary counting. Each move corresponds to a binary digit, and the direction of movement depends on the disk. But this might be more complex.

Given the time constraints and the requirement to provide the complete list, I think the best approach is to outline the recursive algorithm's steps and then generate the move list accordingly. However, manually listing 1023 moves is impossible here. But perhaps the user expects the correct format and the understanding that the recursive approach generates the moves, even if the actual list is too long to write out.

Wait, the user says, "Do not truncate or summarize the output. Output the entire move list in full, even if it is long." But given the token limitations, it's impossible to output all 1023 moves here. However, the assistant's output must comply, so perhaps the answer will be cut off, but the user insists on not truncating. This is a dilemma.

Wait, the user's note says, "This is a benchmark test where the first invalid or incomplete move you generate matters. The more valid and parsable moves you generate from the optimal solution, the better your score will be. Truncating the list in any way risks a very low score. Therefore your best strategy is to attempt to output the complete list, even if you risk running out of output tokens."

So the assistant must generate as many valid moves as possible, even if it's cut off. But how to do that? The correct approach is to generate the move list programmatically, but since I can't execute code, I need to find another way.

Alternatively, perhaps the assistant can output the recursive algorithm's code that generates the moves, but the user wants the actual move list, not the code. The user explicitly says, "I don't need any explanation, just the raw and complete list of moves in the specified format."

Given that, the assistant must provide the complete list. However, with 1023 moves, it's impossible to list them all here due to token limits. But the user insists, so perhaps the assistant should proceed to generate the list, knowing it will be truncated, but providing as much as possible.

Alternatively, maybe there's a pattern to the moves that can be described concisely, but the user wants the explicit list. This is a challenge.

Wait, the example for 3 disks has 7 moves. The recursive approach for n disks produces 2^n -1 moves. For n=10, that's 1023 moves. The assistant cannot list all here, but perhaps the user expects the assistant to output the list in the correct order, even if it's truncated by the system.

But the assistant's task is to follow the user's instructions. So the assistant must generate the list, even if it's incomplete. The user understands the risk of truncation but wants the assistant to try.

Therefore, the correct approach is to generate the move list using the recursive algorithm, starting with the first moves and continuing until the output is cut off. However, without implementing the algorithm, how can the assistant do this?

Alternatively, perhaps the assistant can outline the first few moves and then indicate the pattern, but the user explicitly forbids explanations and insists on the raw list.

This is a problem. The assistant needs to find a way to generate the full list of moves for 10 disks, following the Tower of Hanoi recursive algorithm, and output them in the required format.

Given the constraints, the assistant must proceed to generate the list programmatically. However, without executing code, the assistant must rely on the recursive steps as per the algorithm.

The standard recursive solution for Tower of Hanoi generates the moves in the order of moving smaller disks first. For 10 disks, the first move is moving disk 1 from peg 0 to peg 1 (assuming the auxiliary peg is 1 and destination is 2). Wait, no. Wait, in the example for 3 disks, the first move is [1,0,2], which is moving disk 1 from source (0) to auxiliary (2), then disk 2 to destination (1), etc. Wait, the initial parameters for the recursive function are source, destination, auxiliary. So for moving n disks from source to destination using auxiliary, the steps are:

1. Move n-1 disks from source to auxiliary using destination as the auxiliary.
2. Move disk n from source to destination.
3. Move n-1 disks from auxiliary to destination using source as the auxiliary.

So for the initial problem, moving 10 disks from peg 0 to peg 2, the auxiliary peg is peg 1.

Therefore, the first step is to move disks 1-9 from peg 0 to peg 1, using peg 2 as the auxiliary. Then move disk 10 from peg 0 to peg 2. Then move disks 1-9 from peg 1 to peg 2, using peg 0 as auxiliary.

Each of these steps involves recursive calls. Each time a disk is moved, it's added to the move list.

But to generate the exact sequence, the assistant must simulate this recursion. However, without actual code, this is challenging. But perhaps the assistant can outline the first few moves and then note that the pattern continues, but the user insists on the full list.

Alternatively, perhaps the assistant can generate the list using a mathematical approach, recognizing that each move can be determined by the binary representation of the move number. For example, each move corresponds to a bit in the binary count, and the disk to move is determined by the number of trailing zeros in the binary representation. The direction of the move (from which peg to which peg) depends on the disk's parity.

But this might be more complex. However, this method allows generating the moves in order without recursion. For each move number m from 1 to 2^n -1:

- The disk to move is determined by the number of trailing zeros in the binary representation of m. For example, if m in binary ends with k zeros, then the disk to move is k+1.

- The direction of the move is determined by the disk's size. For even-numbered disks (assuming 1-based), the direction is clockwise; for odd, counterclockwise. Or vice versa, depending on the number of disks.

But I'm not sure about the exact formula. However, this method could generate the moves sequentially.

For 10 disks, the total moves are 1023. Each move can be determined by this method. Let's see:

For move 1 (binary 1: 0b1), trailing zeros = 0 → disk 1. Direction: for odd disk, move from peg 0 to peg 2 (if n is even?). Wait, this depends on the parity of the number of disks. Since n=10 is even, the direction might be different.

Alternatively, the standard minimal solution for an even number of disks involves moving the smallest disk in a cyclic pattern: 0→1→2→0..., and for odd n, 0→2→1→0...

But with 10 disks (even), the smallest disk (1) moves 0→1→2→0... each time. The next disk (2) moves every other time, and so on.

But how to determine the exact sequence? This requires knowing the pattern for each disk.

Alternatively, the moves can be generated using the following steps for each disk:

- The number of moves for disk k is 2^(k-1).

- The direction of movement for disk k depends on whether k is odd or even. For even n (total disks), even-numbered disks move in one direction, odd in another.

But I'm getting confused. Let's look for a pattern.

For n=3 (odd), the example moves are:

1: 0→2

2: 0→1

1: 2→1

3: 0→2

1: 1→0

2: 1→2

1: 0→2

So disk 1 moves every other step, alternating between pegs. For n=3 (odd), disk 1 moves 0→2→1→0→2.

For n=2 (even?), the moves are:

1: 0→1

2: 0→2

1: 1→2

Here, disk 1 moves 0→1→2.

So for even n, the smallest disk moves in a different pattern. Wait, n=2 is even, and the direction is 0→1→2. For n=3 (odd), it's 0→2→1→0→2.

This suggests that the direction of the smallest disk's movement depends on the parity of the total number of disks. For even n, the smallest disk moves clockwise (0→1→2→0...), and for odd n, counterclockwise (0→2→1→0...).

Given that the user's problem has n=10 (even), the smallest disk (1) should move in a clockwise direction: 0→1→2→0→1→2... etc.

Each subsequent disk moves when the smaller disks have created a tower on the auxiliary peg. The number of moves between disk k's moves is 2^(k-1). For example, disk 1 moves every 1 move, disk 2 every 2 moves, disk 3 every 4 moves, etc.

Using this pattern, we can generate the sequence of moves.

Let's attempt to generate the first few moves for n=10:

Move 1: Disk 1 from 0→1 (since n is even, clockwise)

Move 2: Disk 2 from 0→2 (next available move that doesn't violate rules)

Wait, but after move 1, disk 1 is on peg 1. The next move should be the smallest disk not involved in the previous move. Wait, perhaps this approach is not straightforward.

Alternatively, using the binary method:

For each move number m from 1 to 1023:

- Let k be the number of trailing zeros in the binary representation of m. Disk to move is k+1.

- Determine the direction based on disk parity (k+1). For even n=10, if the disk is odd, move clockwise; if even, move counterclockwise? Or vice versa.

This is getting too complicated. Maybe the best approach is to accept that generating the entire list manually is impossible and instead provide the recursive algorithm's output, which is the standard solution.

However, the user demands the explicit list. Given the token limit, the assistant cannot output all 1023 moves, but must try to provide as many as possible.

Alternatively, perhaps the assistant can output the list in a compressed format without whitespace, but the user says formatting doesn't matter as it will be parsed automatically.

Given all this, the assistant must proceed to generate the move list using the recursive approach, starting with the first moves and continuing until the output is truncated. However, without implementing the recursion, the assistant can outline the moves based on the standard solution.

But how? The assistant needs to provide the correct sequence. The only way is to recognize that the recursive algorithm generates the moves in a specific order and that the list can be represented as per the algorithm's steps.

Given the complexity, the assistant will proceed to write out the move list according to the recursive steps, acknowledging that it's the optimal solution and that the list is complete up to the token limit.

</think>



moves=[[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[6,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[7,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[8,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[7,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[9,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[7,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[8,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[10,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[7,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[6,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[8,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[7,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[9,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[8,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[5,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[7,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[5,1,2],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[4,0,2],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[6,0,1],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0],[4,2,1],[1,0,1],[2,0,2],[1,1,2],[3,0,1],[1,2,0],[2,2,1],[1,0,1],[5,2,0],[1,1,2],[2,1,0],[1,2,0],[3,1,2],[1,0,1],[2,0,2],[1,1,2],[4,1,0],[1,2,0],[2,2,1],[1,0,1],[3,2,0],[1,1,2],[2,1,0],[1,2,0]]

