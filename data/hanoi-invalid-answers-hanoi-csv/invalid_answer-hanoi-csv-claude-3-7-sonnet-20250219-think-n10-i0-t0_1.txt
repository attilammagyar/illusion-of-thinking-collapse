# model_name='claude-3-7-sonnet-20250219', reasoning_budget=32000, tries=0, n=10, i=0
# valid_prefix_length=15, is_valid_solution=0, first_correction=-1

<think>
This is the Tower of Hanoi problem with 10 disks. The goal is to move all disks from peg 0 to peg 2, following the rules of the Tower of Hanoi puzzle.

The Tower of Hanoi has a recursive solution. For a stack of n disks:
1. Move the top n-1 disks from the source peg to the auxiliary peg.
2. Move the largest disk (disk n) from the source peg to the destination peg.
3. Move the n-1 disks from the auxiliary peg to the destination peg.

Let me implement this solution and generate the complete list of moves for 10 disks:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 1:
            moves.append((1, source, destination))
            return
        
        _hanoi(n-1, source, destination, auxiliary)
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)
    
    _hanoi(n, source, auxiliary, destination)
    return moves

# Generate moves for 10 disks from peg 0 to peg 2, using peg 1 as auxiliary
moves = hanoi_moves(10, 0, 1, 2)

# Format moves for output
for disk, from_peg, to_peg in moves:
    print(f"{disk},{from_peg},{to_peg}")
```

Wait, there's an issue with the above implementation. The disk IDs are not being tracked correctly. Let me reimplement this:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)
    
    _hanoi(n, source, auxiliary, destination)
    return moves

# Generate moves for 10 disks from peg 0 to peg 2, using peg 1 as auxiliary
moves = hanoi_moves(10, 0, 1, 2)

# Format moves for output
for disk, from_peg, to_peg in moves:
    print(f"{disk},{from_peg},{to_peg}")
```

Actually, let me manually trace the execution for a small example (n=3) to make sure my understanding is correct:

For n=3, source=0, auxiliary=1, destination=2:

1. Call _hanoi(3, 0, 1, 2)
2. Call _hanoi(2, 0, 2, 1)
   3. Call _hanoi(1, 0, 1, 2)
      4. Add move: (1, 0, 2)
   5. Add move: (2, 0, 1)
   6. Call _hanoi(1, 2, 0, 1)
      7. Add move: (1, 2, 1)
8. Add move: (3, 0, 2)
9. Call _hanoi(2, 1, 0, 2)
   10. Call _hanoi(1, 1, 2, 0)
       11. Add move: (1, 1, 0)
   12. Add move: (2, 1, 2)
   13. Call _hanoi(1, 0, 1, 2)
       14. Add move: (1, 0, 2)

So the sequence of moves is:
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2

This matches the example in the problem statement, so our algorithm is correct. Now let's generate the complete list of moves for 10 disks.

For a Tower of Hanoi problem with n disks, the minimum number of moves required is 2^n - 1. For n=10, that's 2^10 - 1 = 1024 - 1 = 1023 moves. That's a lot of moves, but I'll generate the complete list.

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)
    
    _hanoi(n, source, auxiliary, destination)
    return moves

# Generate moves for 10 disks from peg 0 to peg 2, using peg 1 as auxiliary
moves = hanoi_moves(10, 0, 1, 2)
```

Let me manually compute the first few moves for n=10:

1. Call _hanoi(10, 0, 1, 2)
   - Need to move 9 disks from 0 to 1 using 2 as auxiliary
   - Then move disk 10 from 0 to 2
   - Then move 9 disks from 1 to 2 using 0 as auxiliary

2. To move 9 disks from 0 to 1 using 2 as auxiliary:
   - Need to move 8 disks from 0 to 2 using 1 as auxiliary
   - Then move disk 9 from 0 to 1
   - Then move 8 disks from 2 to 1 using 0 as auxiliary

3. To move 8 disks from 0 to 2 using 1 as auxiliary:
   - Need to move 7 disks from 0 to 1 using 2 as auxiliary
   - Then move disk 8 from 0 to 2
   - Then move 7 disks from 1 to 2 using 0 as auxiliary

And so on. This gets very complex very quickly, which is why the recursive algorithm is so useful.

Rather than manually trace this, let me implement the algorithm and generate the complete list of moves:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)
    
    _hanoi(n, source, auxiliary, destination)
    return moves

# Generate moves for 10 disks from peg 0 to peg 2, using peg 1 as auxiliary
moves = hanoi_moves(10, 0, 1, 2)
```

Let me print out the complete list of moves for n=10:

```
moves = hanoi_moves(10, 0, 1, 2)
for disk, from_peg, to_peg in moves:
    print(f"{disk},{from_peg},{to_peg}")
```

Actually, I should run this code to get the list. Let's simulate its execution:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)
    
    _hanoi(n, source, auxiliary, destination)
    return moves

# Generate moves for 10 disks from peg 0 to peg 2, using peg 1 as auxiliary
moves = hanoi_moves(10, 0, 1, 2)
```

Wait, I think there's an issue with my implementation. Let me reconsider the Tower of Hanoi algorithm:

1. Move n-1 disks from source to auxiliary, using destination as the extra peg.
2. Move the largest disk from source to destination.
3. Move n-1 disks from auxiliary to destination, using source as the extra peg.

Let me rewrite the code:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

Actually, no I think I got confused because I messed up the parameter names when I was "calling" the recursive function. The parameters should be (n, source, auxiliary, destination), not (n, source, destination, auxiliary).

Let me rewrite the function with clearer variable names:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, auxiliary, destination)  # This is wrong
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)  # This is wrong
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

Hmm, I think I'm getting confused again. Let me clearly write out the steps of the Tower of Hanoi algorithm:

1. To move n disks from source to destination, using auxiliary as the extra peg:
   a. Move n-1 disks from source to auxiliary, using destination as the extra peg.
   b. Move the largest disk from source to destination.
   c. Move n-1 disks from auxiliary to destination, using source as the extra peg.

Now let me rewrite the function:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)  # Move n-1 disks from source to auxiliary, using destination as the extra peg
        moves.append((n, source, destination))      # Move the largest disk from source to destination
        _hanoi(n-1, auxiliary, source, destination)  # Move n-1 disks from auxiliary to destination, using source as the extra peg
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

Hmm, I still think there's something wrong. Let me simplify:

1. To move n disks from source to destination, using auxiliary as the extra peg:
   a. Move n-1 disks from source to auxiliary, using destination as the extra peg.
   b. Move the largest disk from source to destination.
   c. Move n-1 disks from auxiliary to destination, using source as the extra peg.

So the recursive calls should be:
- First recursive call: (_hanoi(n-1, source, destination, auxiliary))
- Move the largest disk: moves.append((n, source, destination))
- Second recursive call: (_hanoi(n-1, auxiliary, source, destination))

Let's rewrite the function:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)  # Move n-1 disks from source to auxiliary, using destination as the extra peg
        moves.append((n, source, destination))      # Move the largest disk from source to destination
        _hanoi(n-1, auxiliary, source, destination)  # Move n-1 disks from auxiliary to destination, using source as the extra peg
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

Wait, I'm getting confused because the parameter names don't match the roles. Let's rename the parameters to match the roles:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)  # Move n-1 disks from source to auxiliary, using destination as the extra peg
        moves.append((n, source, destination))      # Move the largest disk from source to destination
        _hanoi(n-1, auxiliary, source, destination)  # Move n-1 disks from auxiliary to destination, using source as the extra peg
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

No, that's still not right. Let me draw it out:

For n=3, source=0, auxiliary=1, destination=2:
1. Move 2 disks from peg 0 to peg 1, using peg 2 as auxiliary.
2. Move disk 3 from peg 0 to peg 2.
3. Move 2 disks from peg 1 to peg 2, using peg 0 as auxiliary.

To move 2 disks from peg 0 to peg 1, using peg 2 as auxiliary:
1. Move 1 disk from peg 0 to peg 2, using peg 1 as auxiliary.
2. Move disk 2 from peg 0 to peg 1.
3. Move 1 disk from peg 2 to peg 1, using peg 0 as auxiliary.

Let me rewrite the function from scratch:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)  # Move n-1 disks from source to auxiliary, using destination as the extra peg
        moves.append((n, source, destination))      # Move the largest disk from source to destination
        _hanoi(n-1, auxiliary, source, destination)  # Move n-1 disks from auxiliary to destination, using source as the extra peg
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

That doesn't look right... Let me reason through it step by step again:

For n=3, source=0, auxiliary=1, destination=2:
1. Move 2 disks from peg 0 to peg 1, using peg 2 as auxiliary.
2. Move disk 3 from peg 0 to peg 2.
3. Move 2 disks from peg 1 to peg 2, using peg 0 as auxiliary.

For the first step, we're moving from source (0) to auxiliary (1), using destination (2) as the extra peg. This should be:
```python
_hanoi(n-1, source, destination, auxiliary)
```

For the third step, we're moving from auxiliary (1) to destination (2), using source (0) as the extra peg. This should be:
```python
_hanoi(n-1, auxiliary, source, destination)
```

So the full function should be:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

Wait, the recursive function's parameters are still not matching the roles. The parameters should be (n, source, auxiliary, destination), where source is the peg from which disks are moved, destination is the peg to which disks are moved, and auxiliary is the extra peg used for intermediate moves.

In the first recursive call, we're moving n-1 disks from source to auxiliary, using destination as the extra peg. This should be:
```python
_hanoi(n-1, source, destination, auxiliary)
```

Wait, that's wrong again... Let me break this down:

The parameters of the function _hanoi are:
- n: the number of disks to move
- source: the peg from which disks are moved
- auxiliary: the extra peg used for intermediate moves
- destination: the peg to which disks are moved

In the first recursive call, we want to move n-1 disks from source to auxiliary, using destination as the extra peg. So the call should be:
```python
_hanoi(n-1, source, destination, auxiliary)
```

But this doesn't match the parameter order of the function. We need to interchange the auxiliary and destination parameters. Let me redraw the parameter order and make sure I follow the algorithm correctly:

The parameters of the function _hanoi are:
- n: the number of disks to move
- from_peg: the peg from which disks are moved
- aux_peg: the extra peg used for intermediate moves
- to_peg: the peg to which disks are moved

In the first recursive call, we want to move n-1 disks from from_peg to aux_peg, using to_peg as the extra peg. So the call should be:
```python
_hanoi(n-1, from_peg, to_peg, aux_peg)
```

No wait, that's still wrong. Let me restate the Tower of Hanoi algorithm again:

1. To move n disks from peg A to peg C, using peg B as the extra peg:
   a. Move n-1 disks from peg A to peg B, using peg C as the extra peg.
   b. Move the largest disk from peg A to peg C.
   c. Move n-1 disks from peg B to peg C, using peg A as the extra peg.

So we'd write this as:

```python
def hanoi_moves(n, A, B, C):
    moves = []
    
    def _hanoi(n, source, auxiliary, destination):
        if n == 0:
            return
        
        _hanoi(n-1, source, destination, auxiliary)
        moves.append((n, source, destination))
        _hanoi(n-1, auxiliary, source, destination)
    
    _hanoi(n, A, B, C)
    return moves
```

But I think I got confused because the parameter names don't match the roles. Let me rename the parameters to match the roles:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, from_peg, aux_peg, to_peg):
        if n == 0:
            return
        
        _hanoi(n-1, from_peg, to_peg, aux_peg)
        moves.append((n, from_peg, to_peg))
        _hanoi(n-1, aux_peg, from_peg, to_peg)
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

Ok wait, I think I got it now. Let me trace through the algorithm for n=3:

For n=3, from_peg=0, aux_peg=1, to_peg=2:
1. Move 2 disks from peg 0 to peg 1, using peg 2 as auxiliary.
   a. Move 1 disk from peg 0 to peg 2, using peg 1 as auxiliary.
      i. Call _hanoi(0, 0, 1, 2) - base case, do nothing
      ii. Add move: (1, 0, 2)
      iii. Call _hanoi(0, 1, 0, 2) - base case, do nothing
   b. Add move: (2, 0, 1)
   c. Move 1 disk from peg 2 to peg 1, using peg 0 as auxiliary.
      i. Call _hanoi(0, 2, 0, 1) - base case, do nothing
      ii. Add move: (1, 2, 1)
      iii. Call _hanoi(0, 0, 2, 1) - base case, do nothing
2. Add move: (3, 0, 2)
3. Move 2 disks from peg 1 to peg 2, using peg 0 as auxiliary.
   a. Move 1 disk from peg 1 to peg 0, using peg 2 as auxiliary.
      i. Call _hanoi(0, 1, 2, 0) - base case, do nothing
      ii. Add move: (1, 1, 0)
      iii. Call _hanoi(0, 2, 1, 0) - base case, do nothing
   b. Add move: (2, 1, 2)
   c. Move 1 disk from peg 0 to peg 2, using peg 1 as auxiliary.
      i. Call _hanoi(0, 0, 1, 2) - base case, do nothing
      ii. Add move: (1, 0, 2)
      iii. Call _hanoi(0, 1, 0, 2) - base case, do nothing

So the sequence of moves is:
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2

This matches the example in the problem statement, so our algorithm is correct.

Now I'm ready to generate the complete list of moves for 10 disks. Here's the algorithm:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, from_peg, aux_peg, to_peg):
        if n == 0:
            return
        
        _hanoi(n-1, from_peg, to_peg, aux_peg)
        moves.append((n, from_peg, to_peg))
        _hanoi(n-1, aux_peg, from_peg, to_peg)
    
    _hanoi(n, source, auxiliary, destination)
    return moves

# Generate moves for 10 disks from peg 0 to peg 2, using peg 1 as auxiliary
moves = hanoi_moves(10, 0, 1, 2)
```

Let me use this algorithm to generate the complete list of moves for 10 disks:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, from_peg, aux_peg, to_peg):
        if n == 0:
            return
        
        _hanoi(n-1, from_peg, to_peg, aux_peg)
        moves.append((n, from_peg, to_peg))
        _hanoi(n-1, aux_peg, from_peg, to_peg)
    
    _hanoi(n, source, auxiliary, destination)
    return moves

# Generate moves for 10 disks from peg 0 to peg 2, using peg 1 as auxiliary
moves = hanoi_moves(10, 0, 1, 2)

# Format moves for output
for disk, from_peg, to_peg in moves:
    print(f"{disk},{from_peg},{to_peg}")
```

Actually, we need to run the code to get the complete list of moves. Since I can't run code directly, I'll manually generate the list of moves for n=10. This is going to be a long list (2^10 - 1 = 1023 moves), but I'll generate it.

Let me use the recursive algorithm to generate the list of moves:

For n=10, from_peg=0, aux_peg=1, to_peg=2:
1. Move 9 disks from peg 0 to peg 1, using peg 2 as auxiliary.
2. Move disk 10 from peg 0 to peg 2.
3. Move 9 disks from peg 1 to peg 2, using peg 0 as auxiliary.

For n=9, from_peg=0, aux_peg=2, to_peg=1:
1. Move 8 disks from peg 0 to peg 2, using peg 1 as auxiliary.
2. Move disk 9 from peg 0 to peg 1.
3. Move 8 disks from peg 2 to peg 1, using peg 0 as auxiliary.

For n=8, from_peg=0, aux_peg=1, to_peg=2:
1. Move 7 disks from peg 0 to peg 1, using peg 2 as auxiliary.
2. Move disk 8 from peg 0 to peg 2.
3. Move 7 disks from peg 1 to peg 2, using peg 0 as auxiliary.

For n=7, from_peg=0, aux_peg=2, to_peg=1:
1. Move 6 disks from peg 0 to peg 2, using peg 1 as auxiliary.
2. Move disk 7 from peg 0 to peg 1.
3. Move 6 disks from peg 2 to peg 1, using peg 0 as auxiliary.

For n=6, from_peg=0, aux_peg=1, to_peg=2:
1. Move 5 disks from peg 0 to peg 1, using peg 2 as auxiliary.
2. Move disk 6 from peg 0 to peg 2.
3. Move 5 disks from peg 1 to peg 2, using peg 0 as auxiliary.

For n=5, from_peg=0, aux_peg=2, to_peg=1:
1. Move 4 disks from peg 0 to peg 2, using peg 1 as auxiliary.
2. Move disk 5 from peg 0 to peg 1.
3. Move 4 disks from peg 2 to peg 1, using peg 0 as auxiliary.

For n=4, from_peg=0, aux_peg=1, to_peg=2:
1. Move 3 disks from peg 0 to peg 1, using peg 2 as auxiliary.
2. Move disk 4 from peg 0 to peg 2.
3. Move 3 disks from peg 1 to peg 2, using peg 0 as auxiliary.

For n=3, from_peg=0, aux_peg=2, to_peg=1:
1. Move 2 disks from peg 0 to peg 2, using peg 1 as auxiliary.
2. Move disk 3 from peg 0 to peg 1.
3. Move 2 disks from peg 2 to peg 1, using peg 0 as auxiliary.

For n=2, from_peg=0, aux_peg=1, to_peg=2:
1. Move 1 disk from peg 0 to peg 1, using peg 2 as auxiliary.
2. Move disk 2 from peg 0 to peg 2.
3. Move 1 disk from peg 1 to peg 2, using peg 0 as auxiliary.

For n=1, from_peg=0, aux_peg=2, to_peg=1:
1. Move disk 1 from peg 0 to peg 1.

At this point, we've reached the base case of the recursion. Let's start returning from the recursive calls and generating the moves:

1. Move disk 1 from peg 0 to peg 1.
2. Move disk 2 from peg 0 to peg 2.
3. Move disk 1 from peg 1 to peg 2.
4. Move disk 3 from peg 0 to peg 1.
5. Move disk 1 from peg 2 to peg 0.
6. Move disk 2 from peg 2 to peg 1.
7. Move disk 1 from peg 0 to peg 1.
8. Move disk 4 from peg 0 to peg 2.
9. Move disk 1 from peg 1 to peg 2.
10. Move disk 2 from peg 1 to peg 0.
11. Move disk 1 from peg 2 to peg 0.
12. Move disk 3 from peg 1 to peg 2.
13. Move disk 1 from peg 0 to peg 1.
14. Move disk 2 from peg 0 to peg 2.
15. Move disk 1 from peg 1 to peg 2.

Hmm, this is getting very complex and error-prone when done manually. Let me simplify the process by writing pseudocode for the algorithm, and then using that to generate the list of moves:

```
function hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    function _hanoi(n, from_peg, aux_peg, to_peg):
        if n == 0:
            return
        
        _hanoi(n-1, from_peg, to_peg, aux_peg)
        moves.append((n, from_peg, to_peg))
        _hanoi(n-1, aux_peg, from_peg, to_peg)
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

I think the best approach is to compute this programmatically rather than manually. Let me see if I can write a more efficient algorithm or approach for this.

Actually, I realize there's a pattern in the Tower of Hanoi puzzle. For a disk of size n:
- If n is odd, the first move is from the source peg to the destination peg.
- If n is even, the first move is from the source peg to the auxiliary peg.

And then, the disk alternates between the three pegs in a specific pattern until it reaches its final position.

Let me try to write an iterative algorithm based on this pattern:

```python
def hanoi_moves_iterative(n, source, auxiliary, destination):
    moves = []
    
    # Total number of moves required
    total_moves = 2**n - 1
    
    for i in range(1, total_moves + 1):
        # Determine which disk to move
        disk = 0
        for j in range(n):
            if i % (2**(j+1)) == 0:
                disk = j + 1
        
        # Determine from which peg to which peg
        if disk % 2 == 1:  # Odd-numbered disk
            if n % 2 == 1:  # Odd number of disks
                from_peg = (source + (i + 1) % 3) % 3
                to_peg = (source + i % 3) % 3
            else:  # Even number of disks
                from_peg = (source + i % 3) % 3
                to_peg = (source + (i + 1) % 3) % 3
        else:  # Even-numbered disk
            if n % 2 == 1:  # Odd number of disks
                from_peg = (source + i % 3) % 3
                to_peg = (source + (i + 2) % 3) % 3
            else:  # Even number of disks
                from_peg = (source + (i + 2) % 3) % 3
                to_peg = (source + i % 3) % 3
        
        moves.append((disk, from_peg, to_peg))
    
    return moves
```

Actually, this iterative algorithm is quite complex and error-prone as well. Let me go back to the recursive algorithm and try to generate the list of moves:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, from_peg, aux_peg, to_peg):
        if n == 0:
            return
        
        _hanoi(n-1, from_peg, to_peg, aux_peg)
        moves.append((n, from_peg, to_peg))
        _hanoi(n-1, aux_peg, from_peg, to_peg)
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

Let's try a different approach. Instead of trying to generate the entire list at once, let's generate it incrementally:

For n=1:
1. Move disk 1 from peg 0 to peg 2.

For n=2:
1. Move disk 1 from peg 0 to peg 1.
2. Move disk 2 from peg 0 to peg 2.
3. Move disk 1 from peg 1 to peg 2.

For n=3:
1. Move disk 1 from peg 0 to peg 2.
2. Move disk 2 from peg 0 to peg 1.
3. Move disk 1 from peg 2 to peg 1.
4. Move disk 3 from peg 0 to peg 2.
5. Move disk 1 from peg 1 to peg 0.
6. Move disk 2 from peg 1 to peg 2.
7. Move disk 1 from peg 0 to peg 2.

Actually, let me just directly generate the list of moves for n=10, using the recursive algorithm:

```
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, from_peg, aux_peg, to_peg):
        if n == 0:
            return
        
        _hanoi(n-1, from_peg, to_peg, aux_peg)
        moves.append((n, from_peg, to_peg))
        _hanoi(n-1, aux_peg, from_peg, to_peg)
    
    _hanoi(n, source, auxiliary, destination)
    return moves

# Generate moves for 10 disks from peg 0 to peg 2, using peg 1 as auxiliary
moves = hanoi_moves(10, 0, 1, 2)

# Format moves for output
for disk, from_peg, to_peg in moves:
    print(f"{disk},{from_peg},{to_peg}")
```

I'd need to execute this code to get the full list of moves. Since I can't execute code, I'll need to find another approach or pattern that I can use to generate the list manually.

Actually, let me use a known pattern for the Tower of Hanoi. For a tower with n disks, the optimal solution requires 2^n - 1 moves. The pattern of these moves can be described by the binary counting from 0 to 2^n - 1.

For each number i in the count:
1. The disk to move is the position of the rightmost 1 bit in the binary representation of i, counting from the right starting from 1.
2. The direction of the move (from_peg to to_peg) depends on the parity of the disk and the parity of n.

Let me use this pattern to generate the list of moves for n=10:

```python
def hanoi_moves_binary(n, source, auxiliary, destination):
    moves = []
    
    pegs = [source, auxiliary, destination]
    
    # Total number of moves required
    total_moves = 2**n - 1
    
    for i in range(1, total_moves + 1):
        # Determine which disk to move
        disk = 1
        j = i
        while j % 2 == 0:
            disk += 1
            j //= 2
        
        # Determine from which peg to which peg
        from_peg_idx = 0
        to_peg_idx = 0
        
        if disk % 2 == 1:  # Odd-numbered disk
            if n % 2 == 1:  # Odd number of disks
                from_peg_idx = 0
                to_peg_idx = 2
            else:  # Even number of disks
                from_peg_idx = 0
                to_peg_idx = 1
        else:  # Even-numbered disk
            if n % 2 == 1:  # Odd number of disks
                from_peg_idx = 0
                to_peg_idx = 1
            else:  # Even number of disks
                from_peg_idx = 0
                to_peg_idx = 2
        
        # Apply rotation based on move number
        from_peg_idx = (from_peg_idx + i % 3) % 3
        to_peg_idx = (to_peg_idx + i % 3) % 3
        
        from_peg = pegs[from_peg_idx]
        to_peg = pegs[to_peg_idx]
        
        moves.append((disk, from_peg, to_peg))
    
    return moves
```

Actually this is also complex and error-prone. Let me simplify.

Let's try a different approach. For n disks, the optimal solution is to:
1. Move the top n-1 disks from the source peg to the auxiliary peg.
2. Move the largest disk from the source peg to the destination peg.
3. Move the n-1 disks from the auxiliary peg to the destination peg.

We can use this recursive pattern to generate the list of moves:

```python
def hanoi_moves(n, source, auxiliary, destination):
    moves = []
    
    def _hanoi(n, from_peg, aux_peg, to_peg):
        if n == 0:
            return
        
        _hanoi(n-1, from_peg, to_peg, aux_peg)
        moves.append((n, from_peg, to_peg))
        _hanoi(n-1, aux_peg, from_peg, to_peg)
    
    _hanoi(n, source, auxiliary, destination)
    return moves
```

This should generate the correct list of moves, but I'd need to run the code to get the actual list. Instead, I'm going to use another approach based on the binary pattern of the Tower of Hanoi.

For n disks, the optimal solution requires 2^n - 1 moves. In the optimal solution:
- Disk 1 (the smallest) moves every odd step (1, 3, 5, ...).
- Disk 2 moves every 2 steps (2, 6, 10, ...).
- Disk 3 moves every 4 steps (4, 12, 20, ...).
- Disk k moves every 2^(k-1) steps.

The direction of the move depends on the parity of the disk and the parity of n:
- If both n and k are odd, or both are even, disk k moves in the direction source -> auxiliary -> destination -> source.
- If one is odd and the other is even, disk k moves in the direction source -> destination -> auxiliary -> source.

Let me use this pattern to generate the list of moves for n=10:

OK, so to avoid any complex algorithms, I'm going to do this the boring way: I'm just going to implement the recursive algorithm we discussed earlier and execute it step by step to generate the list of moves. 

For n=10, we have:
- Move 9 disks from peg 0 to peg 1, using peg 2 as auxiliary.
- Move disk 10 from peg 0 to peg 2.
- Move 9 disks from peg 1 to peg 2, using peg 0 as auxiliary.

Let me start executing this recursively:

Alright, I'm going to directly compute and output all the moves for the Tower of Hanoi with 10 disks. The total number of moves will be 2^10 - 1 = 1023. Let me start generating all the moves:

1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
8,0,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,1,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
9,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
8,2,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
10,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
8,2,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
9,2,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
8,2,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
</think>

disk_id,from_peg,to_peg
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
8,0,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,1,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
9,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
8,2,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
10,0,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
8,2,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
9,2,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
8,2,0
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
7,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,1,2
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,1,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,1,0
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,0
2,2,1
1,0,1
3,2,0
1,1,2
2,1,0
1,2,0
5,2,1
1,0,1
2,0,2
1,1,2
3,0,1
1,2,0
2,2,1
1,0,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0

