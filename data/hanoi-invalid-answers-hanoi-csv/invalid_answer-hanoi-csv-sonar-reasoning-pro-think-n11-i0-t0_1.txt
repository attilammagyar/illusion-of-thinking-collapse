# model_name='sonar-reasoning-pro', reasoning_budget=32000, tries=0, n=11, i=0
# valid_prefix_length=79, is_valid_solution=0, first_correction=-1

<think>

Okay, let's tackle this Tower of Hanoi problem with 11 disks. The user wants the complete list of moves without any truncation. First, I remember that the Tower of Hanoi is a classic recursive problem. The minimum number of moves required is 2^n - 1, so for 11 disks, that's 2047 moves. That's a lot, but the user insists on the full list.

The standard recursive approach is to move the top n-1 disks from the source peg to the auxiliary peg, then move the nth disk to the target peg, and finally move the n-1 disks from the auxiliary peg to the target peg. For 11 disks, this would involve repeating this process recursively for each smaller stack.

But generating all 2047 moves manually isn't feasible. However, there's a pattern based on the parity of the number of disks. Since 11 is odd, the first move should be disk 1 from peg 0 to peg 2. Then, subsequent moves follow the rule: always move the smallest disk possible, and alternate between moving it to the next peg in a cyclic manner (0→1→2→0 for odd, 0→2→1→0 for even). Wait, no, actually, for odd disks, the smallest disk moves in a cycle: 0→2→1→0, and for even, 0→1→2→0. Wait, I need to confirm that.

Looking at the search results, result [5] mentions that for the "odd" algorithm, the first step is to move Disk 1 to the left. Since the pegs are 0,1,2, moving left from 0 would wrap around to 2? Or maybe it's a different direction. The example in the query for 3 disks starts with moving disk 1 from 0 to 2. So for odd numbers, the smallest disk moves in a cycle 0→2→1→0. Each time you move the smallest disk, then make the only other possible move that doesn't involve the smallest disk.

So the pattern is: alternate between moving the smallest disk (always in one direction, say, 0→2→1→0 for odd n) and making the only other valid move. This generates the optimal sequence.

But how to translate this into a list of moves for 11 disks? Manually generating each step would take forever, but perhaps there's a systematic way. Each move can be determined by the binary representation of the move number, but I'm not sure. Alternatively, using the recursive approach, each move can be determined by the current state.

Alternatively, the solution can be generated using a non-recursive algorithm that determines each move based on the move number. For example, for each move number m (from 1 to 2^11 -1), determine which disk to move and where. The disk to move is determined by the number of trailing zeros in the binary representation of m, plus one. The direction depends on the disk's size parity. For odd-numbered disks (like 1,3,5...), the direction is 0→2→1→0, and for even-numbered disks, it's 0→1→2→0. Wait, maybe it's the other way around. Let me check.

From the example given in the query for 3 disks, the moves are:

1,0,2

2,0,1

1,2,1

3,0,2

1,1,0

2,1,2

1,0,2

Looking at the first move, disk 1 (smallest) moves from 0 to 2. Then disk 2 moves from 0 to 1. Then disk 1 from 2 to 1. Then disk 3 from 0 to 2. Then disk 1 from 1 to 0, disk 2 from 1 to 2, and disk 1 from 0 to 2.

So for disk 1 (odd), the direction is 0→2→1→0→2... So each time it moves in the cycle 0→2→1→0. For disk 2 (even), the direction is 0→1→2→0. Disk 3 (odd) moves once from 0 to 2.

So the rule is: for each disk, if it's odd-numbered, it moves in the cycle 0→2→1→0. If even-numbered, 0→1→2→0. The direction alternates based on the disk's parity.

Therefore, to generate the sequence, for each move, determine which disk is being moved (based on the move number), then determine the direction based on the disk's parity, and the current positions.

But how to implement this without actually simulating each move? Let's think about the iterative algorithm:

1. For the number of disks n, the total moves are 2^n -1.

2. For each move m from 1 to 2^n -1:

   a. Find the disk to move: the number of trailing zeros in the binary representation of m, plus 1.

   b. Determine the source and target pegs based on the disk's parity and the current move.

But I need to verify this. For example, in the 3-disk case:

Move 1 (binary 1): trailing zeros 0 → disk 1. Since disk 1 is odd, direction is 0→2. So from 0 to 2.

Move 2 (binary 10): trailing zeros 1 → disk 2. Even, direction 0→1. From 0 to 1.

Move 3 (binary 11): trailing zeros 0 → disk 1. From 2 to 1.

Move 4 (100): trailing zeros 2 → disk 3. Odd, direction 0→2. From 0 to 2.

Move 5 (101): trailing zeros 0 → disk 1. From 1 to 0.

Move 6 (110): trailing zeros 1 → disk 2. From 1 to 2.

Move 7 (111): trailing zeros 0 → disk 1. From 0 to 2.

Which matches the example. So this seems correct.

So the algorithm is:

For each move m from 1 to 2^n -1:

1. Find the number of trailing zeros in m's binary representation, call it tz. The disk to move is tz + 1.

2. Determine the direction for the disk:

   - If the disk number is odd, the direction is 0 → 2 → 1 → 0 → ...

   - If even, direction is 0 → 1 → 2 → 0 → ...

3. The number of times this disk has been moved before is floor((m) / 2^(tz+1)).

   Wait, perhaps a better way is to determine the direction based on the parity of the disk and the number of moves made so far for that disk.

Alternatively, for each disk k, the direction is determined by whether k is odd or even. For each move of disk k, it alternates between the two possible moves (since it can't move to the same peg twice in a row). Wait, maybe not. Let's think.

For disk 1 (odd), the moves are 0→2, then 2→1, then 1→0, then 0→2, etc. So each move is in the cycle 0→2→1→0.

For disk 2 (even), the moves are 0→1, then 1→2, then 2→0, etc.

So for each disk k, the direction cycle is:

- If k is odd: 0 → 2 → 1 → 0 → 2 → ...

- If k is even: 0 → 1 → 2 → 0 → 1 → ...

Now, the source and target pegs for each move of disk k can be determined by how many times it has been moved before. The first move for disk k is from the initial peg (0) to the next in its cycle. The second move is from the current peg to the next, etc.

But how to track the current peg for each disk? Since the Tower of Hanoi solution is deterministic, the position of each disk after each move can be determined without simulation.

Alternatively, for each disk k, the sequence of moves alternates between the two possible pegs in its cycle. The number of times disk k has been moved before move m is equal to the number of times it has been moved in the previous steps.

But this seems complicated. Instead, using the formula from the iterative approach:

For each move m, the disk to move is determined by the number of trailing zeros in m's binary representation. Then, the direction is determined by the disk's parity. The source peg is the current peg of the disk, and the target peg is the next in the cycle.

But how to find the current peg of the disk? Since each disk moves in a cycle, the number of times it has been moved before determines its current position.

For disk k, the number of times it has been moved before move m is equal to the number of times it has been the disk to move in the previous steps. Let's denote this as count_k. Then, the current peg is the starting peg (0) plus the direction steps modulo 3. Wait, perhaps for disk k, the first move is from 0 to the next peg in its cycle. The second move is from that peg to the next, etc.

For example, disk 1 (odd):

- First move: 0 → 2

- Second move: 2 → 1

- Third move: 1 → 0

- Fourth move: 0 → 2

So the direction cycle is 0→2→1→0→2→1→0...

For disk 2 (even):

- First move: 0 →1

- Second move:1 →2

- Third move:2 →0

- Fourth move:0 →1

So the cycle is 0→1→2→0→1→2...

Thus, for each disk k, the current peg after c moves is:

If k is odd:

peg = (0 + sum of steps) mod 3, where each step is +2, then -1, then +2, etc. Wait, maybe it's easier to model the sequence of pegs as 0, 2, 1, 0, 2, 1, 0...

For odd k, the sequence is 0 → 2 → 1 → 0 → 2 → 1...

For even k, the sequence is 0 →1 →2 →0 →1 →2...

So for disk k, the current peg after c moves is:

If k is odd: (0 + 2*c) mod 3

Wait, let's see:

c=0: 0

c=1: 2

c=2: (0 + 2*2) mod 3 =4 mod3=1

c=3: (0 +2*3)=6 mod3=0

c=4: 8 mod3=2

Yes, that works. So for odd k, current peg after c moves is (2c) mod3.

For even k, the sequence is 0,1,2,0,1,2...

So current peg after c moves is (0 + c) mod3.

But wait, for even k:

c=0: 0

c=1:1

c=2:2

c=3:0

Yes, so (c) mod3.

So, for each disk k, the number of times it has been moved before move m is equal to the number of times it was the disk to move in the previous steps. Let's denote this as count_k.

But how to compute count_k for each disk k up to move m-1? That's not straightforward. However, in the iterative approach, for each move m, we can determine the disk to move (k), and then compute the source and target based on the number of times k has been moved before.

Alternatively, using the formula for the source and target pegs based on the move number and disk parity.

Another approach: For each move m, the disk to move is d = tz(m) +1, where tz(m) is the number of trailing zeros in the binary representation of m.

Then, the direction for disk d is determined by whether d is odd or even.

For disk d:

If d is odd:

- The moves alternate between 0→2, 2→1, 1→0, etc.

If d is even:

- The moves alternate between 0→1, 1→2, 2→0, etc.

The source peg is the current peg of the disk, and the target peg is the next in the cycle.

But how to determine the current peg of the disk d before move m?

Each time disk d is moved, it alternates between the pegs in its cycle. The number of times disk d has been moved before move m is equal to the number of times it was the disk to move in the previous moves (i.e., for moves 1 to m-1, how many times the trailing zeros of the move number plus 1 equals d).

This seems complex, but perhaps there's a pattern. For disk d, the moves occur at positions where the move number is congruent to 2^(d-1) mod 2^d. Wait, the moves for disk d occur every 2^d moves. For example, disk 1 moves every other move (1,3,5,7...), disk 2 every 4 moves (2,6,10...), disk 3 every 8 moves (4,12,20...), etc.

So for disk d, the number of times it has been moved before move m is floor((m-1)/2^d) * 2^(d-1) + ... Hmm, maybe not. Alternatively, the number of times disk d has been moved before move m is equal to the number of times it has been the disk to move in the previous m-1 moves.

But this is getting too complicated. Let's think of it differently. For each move m, the disk to move is d, and the direction is determined by d's parity. The source and target pegs can be determined based on the number of times disk d has been moved so far.

For example, the first time disk d is moved, it's from peg 0 to the next peg in its cycle. The second time, from the current peg to the next, etc.

So for disk d, the number of times it has been moved before move m is equal to the number of times it was the disk in moves 1 to m-1. Let's call this count_d.

Then, for disk d:

If d is odd:

- The source peg is (2 * (count_d)) mod 3

- The target peg is (2 * (count_d + 1)) mod 3

If d is even:

- The source peg is (count_d) mod 3

- The target peg is (count_d +1) mod 3

Wait, let's test this with the example for 3 disks.

For move 1 (m=1):

d = tz(1) +1 =0 +1=1 (odd)

count_d = number of times d=1 was moved before m=1: 0

source = (2*0) mod3=0

target=(2*1) mod3=2

So move 1: 0→2. Correct.

Move 3 (m=3):

binary 11, tz=0 →d=1 (odd)

count_d = number of times d=1 was moved before m=3: moves 1 and 3? Wait, before m=3, moves 1 and 2. But d=1 was moved in move 1. So count_d=1.

source=(2*1) mod3=2

target=(2*2) mod3=4 mod3=1

So move 3: 2→1. Correct.

Move 5 (m=5):

binary 101, tz=0 →d=1 (odd)

count_d before m=5: moves 1,3,5? Wait, before m=5, moves 1,3. So count_d=2.

source=(2*2)=4 mod3=1

target=(2*3)=6 mod3=0

So move 5:1→0. Correct.

Similarly for disk 2 (even):

Move 2 (m=2):

d=tz(2)+1=1+1=2 (even)

count_d=0

source=0 mod3=0

target=1 mod3=1

So move 2:0→1. Correct.

Move 6 (m=6):

binary 110, tz=1 →d=2 (even)

count_d before m=6: moves 2 and 6? Wait, before m=6, moves 2 and 6 is the current move. So count_d=1.

source=1 mod3=1

target=2 mod3=2

So move 6:1→2. Correct.

This seems to work.

So the formula is:

For each move m:

1. Compute d = tz(m) +1.

2. Compute count_d = number of times d was the disk in moves 1 to m-1.

3. If d is odd:

   source = (2 * count_d) %3

   target = (2 * (count_d +1)) %3

4. If d is even:

   source = (count_d) %3

   target = (count_d +1) %3

But how to compute count_d?

Since disk d is moved every 2^(d) steps, starting at move 2^(d-1).

For example, disk 1 is moved at moves 1,3,5,7,... (every 2^1=2 steps starting at 1)

disk 2 at moves 2,6,10,... (every 2^2=4 steps starting at 2)

disk 3 at moves 4,12,20,... (every 2^3=8 steps starting at 4)

So for disk d, the moves are at m = (2k+1)*2^(d-1) for k=0,1,2,...

Thus, the number of times disk d has been moved before move m is floor((m-1)/2^d) * 2^(d-1) + ... Wait, perhaps a better way is to compute count_d = floor((m - 2^(d-1)) / (2^d)) ) +1, but only if m >=2^(d-1).

Alternatively, count_d for disk d up to move m is the number of times m' <=m where m' = (2k+1)*2^{d-1} for some k >=0.

This is equivalent to count_d = floor( (m + 2^{d-1}) / (2^d) ) )

For example, for d=1, 2^{d-1}=1, 2^d=2.

For m=1: (1+1)/2=1 → count_d=1

But wait, for m=1, count_d should be 0 before the move. Hmm, perhaps this formula gives the number of times including the current move. So to get count_d before move m, it's floor( (m-1 + 2^{d-1}) / (2^d) ) )

Testing for d=1, m=1:

floor( (1-1 +1)/2 )=floor(1/2)=0 → correct.

For m=3:

floor( (3-1 +1)/2 )=floor(3/2)=1 → count_d=1 (moves 1 and 3, but before m=3, count is 1)

Yes, this works.

So the formula for count_d before move m is:

count_d = floor( (m -1 + 2^{d-1}) / (2^d) ) )

Thus, for each move m, to compute count_d for disk d:

count_d = floor( (m -1 + 2^{d-1}) / (2^d) ) )

Now, putting it all together:

For each move m from 1 to 2^11 -1:

1. Compute d = number of trailing zeros in m's binary representation +1.

2. Compute count_d = floor( (m -1 + 2^{d-1}) / (2^d) )

3. If d is odd:

   source = (2 * count_d) %3

   target = (2 * (count_d +1)) %3

4. If d is even:

   source = (count_d) %3

   target = (count_d +1) %3

5. Output the move: disk_id=d, from_peg=source, to_peg=target.

This should generate the correct sequence.

Now, implementing this for 11 disks would require generating 2047 moves. Each move's disk, source, and target can be computed using the above steps.

But how to programmatically generate this? Since I can't write code here, I need to find a pattern or a way to list all moves.

Alternatively, since the user insists on the complete list, I can generate it using the recursive approach. However, writing out 2047 moves manually is impossible. But perhaps the assistant can generate the list algorithmically.

Wait, but the assistant is expected to output the list. Given the token limits, generating 2047 lines might exceed the output capacity, but the user insists on not truncating. So the assistant must proceed despite the risk.

But how? The assistant can't compute each move step-by-step here. However, based on the search results, the solution for 9 disks is 511 moves, as seen in result [4]. The user's example for 3 disks has 7 moves. So the pattern is 2^n -1 moves.

For 11 disks, the assistant needs to output 2047 moves. But how to generate them without actual code?

Alternatively, the assistant can recognize that the optimal solution follows the recursive pattern and can describe the moves in terms of the recursive steps, but the user wants the raw CSV list.

Given the constraints, the assistant must generate the list according to the iterative algorithm described above.

But since the assistant can't compute each move here, perhaps it's best to acknowledge that the list is too long but provide the initial and final moves, but the user explicitly said not to truncate. This is a dilemma.

Wait, the user's note says: "This is a benchmark test where the first invalid move you generate matters. The more valid and parsable moves you generate from the optimal solution, the better your score will be. Truncating the list in any way risks a low score. Therefore your best strategy is to attempt to output the complete list, even if you risk running out of output tokens."

So the assistant must output as many correct moves as possible, even if it can't finish. But how?

Alternatively, the assistant can generate the list programmatically using the iterative algorithm and output it. But without actual computation, it's impossible. However, perhaps the assistant can write a code snippet that generates the moves, but the user wants the CSV, not the code.

Alternatively, the assistant can use the formula to generate the first few moves and then indicate the pattern, but the user wants the complete list.

This is a challenge. Given the assistant's limitations, perhaps the best approach is to output the CSV list using the iterative algorithm formula, even if it's generated in a compressed way.

But how? The assistant can't compute each move here. However, based on the search results, especially result [5] which describes the algorithm for moving disks, the assistant can outline the steps.

Wait, result [5] mentions an algorithm where for odd-numbered disks, you move Disk 1 to the left (which for peg 0 would be peg 2), then move the next available disk, and repeat. The exact steps for larger disks would follow this pattern.

But without the exact move list for 11 disks, the assistant must rely on the recursive approach. The recursive solution for n disks is:

1. Move n-1 disks from peg 0 to peg 1, using peg 2 as auxiliary.

2. Move disk n from peg 0 to peg 2.

3. Move n-1 disks from peg 1 to peg 2, using peg 0 as auxiliary.

Thus, for 11 disks, the moves would be:

- Move 10 disks from 0→1 using 2.

- Move disk 11 from 0→2.

- Move 10 disks from 1→2 using 0.

Each of these steps would involve recursively moving the smaller disks.

But translating this into the actual move list would require expanding all recursive steps, resulting in 2047 moves.

Given that, the assistant must generate the list according to this recursive pattern. However, manually listing all 2047 moves is impractical. Therefore, the assistant must find a way to represent the entire sequence programmatically, but within the constraints of text output.

Alternatively, the assistant can generate the list using the iterative algorithm's formula, step by step, for each move from 1 to 2047.

But without actual computation, this is impossible. However, perhaps the assistant can use a pattern-based approach, recognizing that each disk's moves follow a specific cycle and can be generated accordingly.

Given the time constraints and the need to provide a complete answer, the assistant will proceed to generate the CSV list using the iterative algorithm described earlier, applying the formula for each move from 1 to 2047.

However, since this is beyond manual computation, the assistant must rely on the fact that the iterative algorithm correctly generates the moves and output the list accordingly. Therefore, the assistant will provide the complete CSV list as per the iterative approach, ensuring that each move follows the rules.

</think>



disk_id,from_peg,to_peg
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
9,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
10,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
9,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
11,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
9,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
10,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
5,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
7,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
5,0,2
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
8,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,2,1
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
6,0,1
1,2,1
2,2,0
1,1,0
3,2,1
1,0,2
2,0,1
1,2,1
4,2,0
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
5,0,2
1,1,0
2,1,2
1,0,2
3,1,0
1,2,1
2,2,0
1,1,0
4,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
7,1,2
1,0,2
2,0,1
1,2,1
3,0,2
1,1,0
2,1,2
1,0,2
4,0,1
1,2

